{"ast":null,"code":"var _jsxFileName = \"/Users/brucemcdougall/go/jalapeno-github/jalapeno-ui/src/components/NetworkGraph.js\",\n  _s = $RefreshSig$();\nimport React, { useEffect, useRef, useState } from 'react';\nimport CytoscapeComponent from 'react-cytoscapejs';\nimport cytoscape from 'cytoscape';\nimport cola from 'cytoscape-cola';\nimport { apiUrl } from '../config';\nimport '../styles/NetworkGraph.css';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst COLORS = {\n  igp_node: '#CC4A04',\n  // Cayenne orange for IGP nodes\n  bgp_node: '#1E88E5',\n  // Blue for BGP nodes\n  prefix: '#002921',\n  // Dark green for all prefix types\n  text: '#000',\n  // Black text\n  edge: '#1a365d' // Blue edges\n};\ncytoscape.use(cola);\nconst NetworkGraph = ({\n  collection\n}) => {\n  _s();\n  const cyRef = useRef(null);\n  const [graphData, setGraphData] = useState(null);\n  const [verticesData, setVerticesData] = useState({});\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(null);\n  useEffect(() => {\n    const loadGraphData = async () => {\n      if (!collection) return;\n      setIsLoading(true);\n      setError(null);\n      try {\n        const response = await fetch(`${apiUrl}/api/v1/collections/${collection}/topology`);\n        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);\n        const data = await response.json();\n        console.log('Topology data:', data); // Debug log\n        const elements = transformDataToCytoscape(data);\n        setGraphData(elements);\n      } catch (err) {\n        console.error('Detailed error:', err);\n        setError(`Failed to load graph data: ${err.message}`);\n      } finally {\n        setIsLoading(false);\n      }\n    };\n    loadGraphData();\n  }, [collection]);\n  const transformDataToCytoscape = data => {\n    console.log('Raw data:', {\n      edgeCount: data.edges.length,\n      vertexCount: Object.keys(data.vertices).length,\n      vertices: data.vertices,\n      edges: data.edges\n    });\n    const elements = {\n      nodes: new Set(),\n      edges: new Set()\n    };\n    if (!(data !== null && data !== void 0 && data.edges) || !(data !== null && data !== void 0 && data.vertices)) {\n      console.warn('Missing edges or vertices in data');\n      return [];\n    }\n\n    // First, add all vertices as nodes\n    Object.entries(data.vertices).forEach(([id, vertex]) => {\n      elements.nodes.add({\n        group: 'nodes',\n        data: {\n          id: id,\n          label: vertex.name || id.split('/')[1],\n          type: id.split('/')[0],\n          vertexData: vertex\n        }\n      });\n    });\n\n    // Then process edges (deduplicating as we go)\n    const processedEdgePairs = new Set();\n    data.edges.forEach(edge => {\n      if (edge._from && edge._to) {\n        // Create a consistent edge identifier by sorting vertex IDs\n        const vertices = [edge._from, edge._to].sort();\n        const edgeKey = vertices.join('_');\n        if (!processedEdgePairs.has(edgeKey)) {\n          processedEdgePairs.add(edgeKey);\n          elements.edges.add({\n            group: 'edges',\n            data: {\n              id: edgeKey,\n              source: vertices[0],\n              target: vertices[1]\n            }\n          });\n        }\n      }\n    });\n    const finalElements = [...Array.from(elements.nodes), ...Array.from(elements.edges)];\n    console.log('Transformed data:', {\n      totalElements: finalElements.length,\n      nodes: Array.from(elements.nodes).length,\n      edges: Array.from(elements.edges).length,\n      nodeTypes: Array.from(elements.nodes).reduce((acc, node) => {\n        const type = node.data.type;\n        acc[type] = (acc[type] || 0) + 1;\n        return acc;\n      }, {})\n    });\n    return finalElements;\n  };\n  const getTooltipContent = node => {\n    const vertexData = node.data('vertexData') || {};\n    const type = node.data('type');\n    let content = `<div class=\"tooltip-header\">${type}</div><div class=\"tooltip-body\">`;\n\n    // Add common fields if they exist\n    if (vertexData.name) {\n      content += `<div>Name: ${vertexData.name}</div>`;\n    }\n    if (vertexData.asn) {\n      content += `<div>ASN: ${vertexData.asn}</div>`;\n    }\n\n    // Add type-specific fields\n    switch (type) {\n      case 'igp_node':\n        if (vertexData.protocol) {\n          content += `<div>Protocol: ${vertexData.protocol}</div>`;\n        }\n        if (vertexData.sids && vertexData.sids.length > 0) {\n          content += `<div>SIDs: ${vertexData.sids.join(', ')}</div>`;\n        }\n        break;\n      case 'ls_prefix':\n        if (vertexData.prefix) {\n          content += `<div>Prefix: ${vertexData.prefix}</div>`;\n        }\n        break;\n      case 'bgp_node':\n        if (vertexData.peer_ip) {\n          content += `<div>Peer IP: ${vertexData.peer_ip}</div>`;\n        }\n        if (vertexData.address_family) {\n          content += `<div>Address Family: ${vertexData.address_family}</div>`;\n        }\n        break;\n    }\n    content += '</div>';\n    return content;\n  };\n\n  // Setup hover events after the graph is rendered\n  useEffect(() => {\n    if (cyRef.current) {\n      const cy = cyRef.current;\n\n      // Remove any existing event listeners\n      cy.nodes().unbind('mouseover mouseout');\n\n      // Add hover events\n      cy.nodes().bind('mouseover', event => {\n        const node = event.target;\n        const type = node.data('type');\n        const label = node.data('label');\n\n        // Create and position the tooltip div\n        let tooltip = document.getElementById('cy-tooltip');\n        if (!tooltip) {\n          tooltip = document.createElement('div');\n          tooltip.setAttribute('id', 'cy-tooltip');\n          document.body.appendChild(tooltip);\n        }\n        tooltip.innerHTML = `\n          <div class=\"tooltip-header\">${type}</div>\n          <div class=\"tooltip-body\">\n            <div>ID: ${label}</div>\n          </div>\n        `;\n        const renderedPosition = node.renderedPosition();\n        const zoom = cy.zoom();\n        tooltip.style.display = 'block';\n        tooltip.style.left = `${renderedPosition.x}px`;\n        tooltip.style.top = `${renderedPosition.y - 70}px`; // Offset above the node\n      });\n      cy.nodes().bind('mouseout', () => {\n        const tooltip = document.getElementById('cy-tooltip');\n        if (tooltip) {\n          tooltip.style.display = 'none';\n        }\n      });\n    }\n  }, [graphData]);\n  const detectTopology = elements => {\n    if (!elements || elements.length === 0) {\n      return {\n        isClos: false,\n        reason: 'No elements to analyze'\n      };\n    }\n    const nodes = elements.filter(ele => ele.group === 'nodes');\n    const edges = elements.filter(ele => ele.group === 'edges');\n\n    // Build adjacency map for IGP nodes only\n    const igpAdjacency = {};\n    edges.forEach(edge => {\n      const sourceNode = nodes.find(n => n.data.id === edge.data.source);\n      const targetNode = nodes.find(n => n.data.id === edge.data.target);\n\n      // Only consider edges between IGP nodes\n      if ((sourceNode === null || sourceNode === void 0 ? void 0 : sourceNode.data.type) === 'igp_node' && (targetNode === null || targetNode === void 0 ? void 0 : targetNode.data.type) === 'igp_node') {\n        if (!igpAdjacency[edge.data.source]) igpAdjacency[edge.data.source] = new Set();\n        if (!igpAdjacency[edge.data.target]) igpAdjacency[edge.data.target] = new Set();\n        igpAdjacency[edge.data.source].add(edge.data.target);\n        igpAdjacency[edge.data.target].add(edge.data.source);\n      }\n    });\n\n    // Get IGP nodes and their degrees\n    const igpNodes = nodes.filter(node => node.data.type === 'igp_node');\n    console.log('IGP nodes found:', igpNodes.length);\n\n    // Calculate and analyze IGP node degrees\n    const nodeDegrees = {};\n    igpNodes.forEach(node => {\n      var _igpAdjacency$node$da;\n      nodeDegrees[node.data.id] = ((_igpAdjacency$node$da = igpAdjacency[node.data.id]) === null || _igpAdjacency$node$da === void 0 ? void 0 : _igpAdjacency$node$da.size) || 0;\n    });\n    const degrees = Object.values(nodeDegrees);\n    const sortedDegrees = [...degrees].sort((a, b) => b - a);\n    console.log('Degree distribution:', {\n      degrees: sortedDegrees,\n      nodeCount: igpNodes.length,\n      uniqueDegrees: [...new Set(sortedDegrees)]\n    });\n\n    // CLOS criteria adjusted for your topology\n    const uniqueDegrees = new Set(sortedDegrees);\n    const hasExactlyTwoDegrees = uniqueDegrees.size === 2;\n    const degreesAreEven = [...uniqueDegrees].every(d => d % 2 === 0);\n    const hasRegularPattern = hasExactlyTwoDegrees && degreesAreEven;\n    console.log('Refined CLOS analysis:', {\n      uniqueDegrees: [...uniqueDegrees],\n      hasExactlyTwoDegrees,\n      degreesAreEven,\n      hasRegularPattern,\n      higherDegreeCount: sortedDegrees.filter(d => d === Math.max(...sortedDegrees)).length,\n      lowerDegreeCount: sortedDegrees.filter(d => d === Math.min(...sortedDegrees)).length\n    });\n    const isClos = hasRegularPattern;\n    return {\n      isClos,\n      reason: isClos ? 'Regular CLOS pattern detected' : 'Node degree distribution does not match CLOS pattern',\n      analysis: {\n        hasRegularPattern,\n        spineCount: sortedDegrees.filter(d => d === Math.max(...sortedDegrees)).length,\n        leafCount: sortedDegrees.filter(d => d === Math.min(...sortedDegrees)).length,\n        spineNodes: igpNodes.filter(n => nodeDegrees[n.data.id] === Math.max(...sortedDegrees)).map(n => n.data.id)\n      }\n    };\n  };\n  const isPrefix = type => {\n    return type === 'ls_prefix' || type === 'bgp_prefix';\n  };\n  const getLayout = elements => {\n    const cy = cyRef.current;\n    if (!cy) return null;\n\n    // First position non-prefix nodes in a circle\n    const coreLayout = {\n      name: 'circle',\n      animate: false,\n      padding: 50,\n      radius: 200,\n      startAngle: 3 / 2 * Math.PI,\n      // Start from top\n      sweep: 2 * Math.PI,\n      // Full circle\n      clockwise: true,\n      sort: undefined,\n      // Leave nodes in order they were added\n      nodes: cy.nodes().filter(node => !isPrefix(node.data('type')))\n    };\n    cy.nodes().filter(node => !isPrefix(node.data('type'))).layout(coreLayout).run();\n\n    // Then position prefixes around the perimeter\n    return {\n      name: 'preset',\n      positions: node => {\n        var _node$data;\n        if (!(node !== null && node !== void 0 && (_node$data = node.data) !== null && _node$data !== void 0 && _node$data.type)) return null;\n        const width = cy.width();\n        const height = cy.height();\n        const centerX = width / 2;\n        const centerY = height / 2;\n        const radius = Math.min(width, height) * 0.4; // Slightly larger radius for prefixes\n\n        // For prefix nodes\n        if (isPrefix(node.data.type)) {\n          const connectedEdges = cy.edges().filter(edge => edge.source().id() === node.id() || edge.target().id() === node.id());\n          if (connectedEdges.length > 0) {\n            const connectedNode = connectedEdges[0].source().id() === node.id() ? connectedEdges[0].target() : connectedEdges[0].source();\n            if (connectedNode.position()) {\n              // Calculate angle based on connected node's position\n              const nodePos = connectedNode.position();\n              const angle = Math.atan2(nodePos.y - centerY, nodePos.x - centerX);\n\n              // Add small random offset to avoid stacking\n              const offsetAngle = angle + (Math.random() - 0.5) * Math.PI / 6;\n              return {\n                x: centerX + radius * Math.cos(offsetAngle),\n                y: centerY + radius * Math.sin(offsetAngle)\n              };\n            }\n          }\n\n          // Fallback for unconnected prefixes\n          const angle = 2 * Math.PI * Math.random();\n          return {\n            x: centerX + radius * Math.cos(angle),\n            y: centerY + radius * Math.sin(angle)\n          };\n        }\n\n        // Return existing positions for core nodes\n        return node.position();\n      },\n      fit: true,\n      padding: 50\n    };\n  };\n\n  // Ensure layout is applied after graph data changes\n  useEffect(() => {\n    if (graphData && cyRef.current) {\n      console.log('Applying layout to graph');\n      const layout = getLayout(graphData);\n      if (layout) {\n        cyRef.current.layout(layout).run();\n      }\n    }\n  }, [graphData]);\n  const stylesheet = [{\n    selector: 'node',\n    style: {\n      'background-color': ele => {\n        const type = ele.data('type');\n        // Treat all prefix types the same\n        if (isPrefix(type)) return COLORS.prefix;\n        return COLORS[type] || COLORS.igp_node;\n      },\n      'label': 'data(label)',\n      'width': 30,\n      'height': 30,\n      'color': COLORS.text,\n      'text-outline-width': 2,\n      'text-outline-color': '#fff',\n      'font-family': 'Consolas',\n      'font-size': '10px',\n      'text-wrap': 'wrap',\n      'text-max-width': '100px'\n    }\n  }, {\n    selector: 'edge',\n    style: {\n      'width': 1.5,\n      'line-color': COLORS.edge,\n      'curve-style': 'bezier',\n      'target-arrow-color': COLORS.edge,\n      'target-arrow-shape': 'triangle',\n      'arrow-scale': 0.8\n    }\n  }];\n  const Legend = () => /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"graph-legend\",\n    children: [/*#__PURE__*/_jsxDEV(\"h3\", {\n      children: \"Legend\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 412,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"legend-item\",\n      children: [/*#__PURE__*/_jsxDEV(\"span\", {\n        className: \"legend-color\",\n        style: {\n          backgroundColor: COLORS.igp_node\n        }\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 414,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"span\", {\n        children: \"IGP Nodes\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 415,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 413,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"legend-item\",\n      children: [/*#__PURE__*/_jsxDEV(\"span\", {\n        className: \"legend-color\",\n        style: {\n          backgroundColor: COLORS.bgp_node\n        }\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 418,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"span\", {\n        children: \"BGP Nodes\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 419,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 417,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"legend-item\",\n      children: [/*#__PURE__*/_jsxDEV(\"span\", {\n        className: \"legend-color\",\n        style: {\n          backgroundColor: COLORS.prefix\n        }\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 422,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"span\", {\n        children: \"Prefixes\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 423,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 421,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 411,\n    columnNumber: 5\n  }, this);\n  if (isLoading) {\n    return /*#__PURE__*/_jsxDEV(\"div\", {\n      style: {\n        padding: '20px',\n        fontFamily: 'Consolas'\n      },\n      children: \"Loading graph data...\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 429,\n      columnNumber: 12\n    }, this);\n  }\n  if (error) {\n    return /*#__PURE__*/_jsxDEV(\"div\", {\n      style: {\n        padding: '20px',\n        color: 'red',\n        fontFamily: 'Consolas'\n      },\n      children: error\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 433,\n      columnNumber: 12\n    }, this);\n  }\n  if (!graphData) {\n    return /*#__PURE__*/_jsxDEV(\"div\", {\n      style: {\n        padding: '20px',\n        fontFamily: 'Consolas'\n      },\n      children: \"Select a graph to visualize\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 437,\n      columnNumber: 12\n    }, this);\n  }\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"network-graph-container\",\n    children: [/*#__PURE__*/_jsxDEV(Legend, {}, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 442,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"graph-area\",\n      children: /*#__PURE__*/_jsxDEV(CytoscapeComponent, {\n        elements: graphData,\n        layout: getLayout(graphData),\n        stylesheet: stylesheet,\n        cy: cy => {\n          cyRef.current = cy;\n        },\n        style: {\n          width: '100%',\n          height: '100%'\n        }\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 444,\n        columnNumber: 9\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 443,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 441,\n    columnNumber: 5\n  }, this);\n};\n_s(NetworkGraph, \"zfD1i51Y64EV2AGtN6zwmxwQ5FA=\");\n_c = NetworkGraph;\nexport default NetworkGraph;\nvar _c;\n$RefreshReg$(_c, \"NetworkGraph\");","map":{"version":3,"names":["React","useEffect","useRef","useState","CytoscapeComponent","cytoscape","cola","apiUrl","jsxDEV","_jsxDEV","COLORS","igp_node","bgp_node","prefix","text","edge","use","NetworkGraph","collection","_s","cyRef","graphData","setGraphData","verticesData","setVerticesData","isLoading","setIsLoading","error","setError","loadGraphData","response","fetch","ok","Error","status","data","json","console","log","elements","transformDataToCytoscape","err","message","edgeCount","edges","length","vertexCount","Object","keys","vertices","nodes","Set","warn","entries","forEach","id","vertex","add","group","label","name","split","type","vertexData","processedEdgePairs","_from","_to","sort","edgeKey","join","has","source","target","finalElements","Array","from","totalElements","nodeTypes","reduce","acc","node","getTooltipContent","content","asn","protocol","sids","peer_ip","address_family","current","cy","unbind","bind","event","tooltip","document","getElementById","createElement","setAttribute","body","appendChild","innerHTML","renderedPosition","zoom","style","display","left","x","top","y","detectTopology","isClos","reason","filter","ele","igpAdjacency","sourceNode","find","n","targetNode","igpNodes","nodeDegrees","_igpAdjacency$node$da","size","degrees","values","sortedDegrees","a","b","nodeCount","uniqueDegrees","hasExactlyTwoDegrees","degreesAreEven","every","d","hasRegularPattern","higherDegreeCount","Math","max","lowerDegreeCount","min","analysis","spineCount","leafCount","spineNodes","map","isPrefix","getLayout","coreLayout","animate","padding","radius","startAngle","PI","sweep","clockwise","undefined","layout","run","positions","_node$data","width","height","centerX","centerY","connectedEdges","connectedNode","position","nodePos","angle","atan2","offsetAngle","random","cos","sin","fit","stylesheet","selector","Legend","className","children","fileName","_jsxFileName","lineNumber","columnNumber","backgroundColor","fontFamily","color","_c","$RefreshReg$"],"sources":["/Users/brucemcdougall/go/jalapeno-github/jalapeno-ui/src/components/NetworkGraph.js"],"sourcesContent":["import React, { useEffect, useRef, useState } from 'react';\nimport CytoscapeComponent from 'react-cytoscapejs';\nimport cytoscape from 'cytoscape';\nimport cola from 'cytoscape-cola';\nimport { apiUrl } from '../config';\nimport '../styles/NetworkGraph.css';\n\nconst COLORS = {\n  igp_node: '#CC4A04',    // Cayenne orange for IGP nodes\n  bgp_node: '#1E88E5',    // Blue for BGP nodes\n  prefix: '#002921',      // Dark green for all prefix types\n  text: '#000',           // Black text\n  edge: '#1a365d'         // Blue edges\n};\n\ncytoscape.use(cola);\n\nconst NetworkGraph = ({ collection }) => {\n  const cyRef = useRef(null);\n  const [graphData, setGraphData] = useState(null);\n  const [verticesData, setVerticesData] = useState({});\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(null);\n\n  useEffect(() => {\n    const loadGraphData = async () => {\n      if (!collection) return;\n      setIsLoading(true);\n      setError(null);\n\n      try {\n        const response = await fetch(`${apiUrl}/api/v1/collections/${collection}/topology`);\n        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);\n        const data = await response.json();\n        console.log('Topology data:', data); // Debug log\n        const elements = transformDataToCytoscape(data);\n        setGraphData(elements);\n      } catch (err) {\n        console.error('Detailed error:', err);\n        setError(`Failed to load graph data: ${err.message}`);\n      } finally {\n        setIsLoading(false);\n      }\n    };\n\n    loadGraphData();\n  }, [collection]);\n\n  const transformDataToCytoscape = (data) => {\n    console.log('Raw data:', {\n      edgeCount: data.edges.length,\n      vertexCount: Object.keys(data.vertices).length,\n      vertices: data.vertices,\n      edges: data.edges\n    });\n\n    const elements = {\n      nodes: new Set(),\n      edges: new Set()\n    };\n\n    if (!data?.edges || !data?.vertices) {\n      console.warn('Missing edges or vertices in data');\n      return [];\n    }\n\n    // First, add all vertices as nodes\n    Object.entries(data.vertices).forEach(([id, vertex]) => {\n      elements.nodes.add({\n        group: 'nodes',\n        data: {\n          id: id,\n          label: vertex.name || id.split('/')[1],\n          type: id.split('/')[0],\n          vertexData: vertex\n        }\n      });\n    });\n\n    // Then process edges (deduplicating as we go)\n    const processedEdgePairs = new Set();\n\n    data.edges.forEach(edge => {\n      if (edge._from && edge._to) {\n        // Create a consistent edge identifier by sorting vertex IDs\n        const vertices = [edge._from, edge._to].sort();\n        const edgeKey = vertices.join('_');\n\n        if (!processedEdgePairs.has(edgeKey)) {\n          processedEdgePairs.add(edgeKey);\n          \n          elements.edges.add({\n            group: 'edges',\n            data: {\n              id: edgeKey,\n              source: vertices[0],\n              target: vertices[1]\n            }\n          });\n        }\n      }\n    });\n\n    const finalElements = [...Array.from(elements.nodes), ...Array.from(elements.edges)];\n    \n    console.log('Transformed data:', {\n      totalElements: finalElements.length,\n      nodes: Array.from(elements.nodes).length,\n      edges: Array.from(elements.edges).length,\n      nodeTypes: Array.from(elements.nodes).reduce((acc, node) => {\n        const type = node.data.type;\n        acc[type] = (acc[type] || 0) + 1;\n        return acc;\n      }, {})\n    });\n\n    return finalElements;\n  };\n\n  const getTooltipContent = (node) => {\n    const vertexData = node.data('vertexData') || {};\n    const type = node.data('type');\n    \n    let content = `<div class=\"tooltip-header\">${type}</div><div class=\"tooltip-body\">`;\n    \n    // Add common fields if they exist\n    if (vertexData.name) {\n      content += `<div>Name: ${vertexData.name}</div>`;\n    }\n    if (vertexData.asn) {\n      content += `<div>ASN: ${vertexData.asn}</div>`;\n    }\n\n    // Add type-specific fields\n    switch (type) {\n      case 'igp_node':\n        if (vertexData.protocol) {\n          content += `<div>Protocol: ${vertexData.protocol}</div>`;\n        }\n        if (vertexData.sids && vertexData.sids.length > 0) {\n          content += `<div>SIDs: ${vertexData.sids.join(', ')}</div>`;\n        }\n        break;\n      \n      case 'ls_prefix':\n        if (vertexData.prefix) {\n          content += `<div>Prefix: ${vertexData.prefix}</div>`;\n        }\n        break;\n\n      case 'bgp_node':\n        if (vertexData.peer_ip) {\n          content += `<div>Peer IP: ${vertexData.peer_ip}</div>`;\n        }\n        if (vertexData.address_family) {\n          content += `<div>Address Family: ${vertexData.address_family}</div>`;\n        }\n        break;\n    }\n    \n    content += '</div>';\n    return content;\n  };\n\n  // Setup hover events after the graph is rendered\n  useEffect(() => {\n    if (cyRef.current) {\n      const cy = cyRef.current;\n      \n      // Remove any existing event listeners\n      cy.nodes().unbind('mouseover mouseout');\n      \n      // Add hover events\n      cy.nodes().bind('mouseover', (event) => {\n        const node = event.target;\n        const type = node.data('type');\n        const label = node.data('label');\n        \n        // Create and position the tooltip div\n        let tooltip = document.getElementById('cy-tooltip');\n        if (!tooltip) {\n          tooltip = document.createElement('div');\n          tooltip.setAttribute('id', 'cy-tooltip');\n          document.body.appendChild(tooltip);\n        }\n        \n        tooltip.innerHTML = `\n          <div class=\"tooltip-header\">${type}</div>\n          <div class=\"tooltip-body\">\n            <div>ID: ${label}</div>\n          </div>\n        `;\n        \n        const renderedPosition = node.renderedPosition();\n        const zoom = cy.zoom();\n        \n        tooltip.style.display = 'block';\n        tooltip.style.left = `${renderedPosition.x}px`;\n        tooltip.style.top = `${renderedPosition.y - 70}px`; // Offset above the node\n      });\n      \n      cy.nodes().bind('mouseout', () => {\n        const tooltip = document.getElementById('cy-tooltip');\n        if (tooltip) {\n          tooltip.style.display = 'none';\n        }\n      });\n    }\n  }, [graphData]);\n\n  const detectTopology = (elements) => {\n    if (!elements || elements.length === 0) {\n      return { isClos: false, reason: 'No elements to analyze' };\n    }\n\n    const nodes = elements.filter(ele => ele.group === 'nodes');\n    const edges = elements.filter(ele => ele.group === 'edges');\n\n    // Build adjacency map for IGP nodes only\n    const igpAdjacency = {};\n    edges.forEach(edge => {\n      const sourceNode = nodes.find(n => n.data.id === edge.data.source);\n      const targetNode = nodes.find(n => n.data.id === edge.data.target);\n      \n      // Only consider edges between IGP nodes\n      if (sourceNode?.data.type === 'igp_node' && targetNode?.data.type === 'igp_node') {\n        if (!igpAdjacency[edge.data.source]) igpAdjacency[edge.data.source] = new Set();\n        if (!igpAdjacency[edge.data.target]) igpAdjacency[edge.data.target] = new Set();\n        igpAdjacency[edge.data.source].add(edge.data.target);\n        igpAdjacency[edge.data.target].add(edge.data.source);\n      }\n    });\n\n    // Get IGP nodes and their degrees\n    const igpNodes = nodes.filter(node => node.data.type === 'igp_node');\n    console.log('IGP nodes found:', igpNodes.length);\n\n    // Calculate and analyze IGP node degrees\n    const nodeDegrees = {};\n    igpNodes.forEach(node => {\n      nodeDegrees[node.data.id] = igpAdjacency[node.data.id]?.size || 0;\n    });\n\n    const degrees = Object.values(nodeDegrees);\n    const sortedDegrees = [...degrees].sort((a, b) => b - a);\n    \n    console.log('Degree distribution:', {\n      degrees: sortedDegrees,\n      nodeCount: igpNodes.length,\n      uniqueDegrees: [...new Set(sortedDegrees)]\n    });\n\n    // CLOS criteria adjusted for your topology\n    const uniqueDegrees = new Set(sortedDegrees);\n    const hasExactlyTwoDegrees = uniqueDegrees.size === 2;\n    const degreesAreEven = [...uniqueDegrees].every(d => d % 2 === 0);\n    const hasRegularPattern = hasExactlyTwoDegrees && degreesAreEven;\n\n    console.log('Refined CLOS analysis:', {\n      uniqueDegrees: [...uniqueDegrees],\n      hasExactlyTwoDegrees,\n      degreesAreEven,\n      hasRegularPattern,\n      higherDegreeCount: sortedDegrees.filter(d => d === Math.max(...sortedDegrees)).length,\n      lowerDegreeCount: sortedDegrees.filter(d => d === Math.min(...sortedDegrees)).length\n    });\n\n    const isClos = hasRegularPattern;\n\n    return {\n      isClos,\n      reason: isClos ? 'Regular CLOS pattern detected' : 'Node degree distribution does not match CLOS pattern',\n      analysis: {\n        hasRegularPattern,\n        spineCount: sortedDegrees.filter(d => d === Math.max(...sortedDegrees)).length,\n        leafCount: sortedDegrees.filter(d => d === Math.min(...sortedDegrees)).length,\n        spineNodes: igpNodes\n          .filter(n => nodeDegrees[n.data.id] === Math.max(...sortedDegrees))\n          .map(n => n.data.id)\n      }\n    };\n  };\n\n  const isPrefix = (type) => {\n    return type === 'ls_prefix' || type === 'bgp_prefix';\n  };\n\n  const getLayout = (elements) => {\n    const cy = cyRef.current;\n    if (!cy) return null;\n\n    // First position non-prefix nodes in a circle\n    const coreLayout = {\n      name: 'circle',\n      animate: false,\n      padding: 50,\n      radius: 200,\n      startAngle: 3/2 * Math.PI, // Start from top\n      sweep: 2 * Math.PI,        // Full circle\n      clockwise: true,\n      sort: undefined,           // Leave nodes in order they were added\n      nodes: cy.nodes().filter(node => !isPrefix(node.data('type')))\n    };\n\n    cy.nodes().filter(node => !isPrefix(node.data('type')))\n      .layout(coreLayout)\n      .run();\n\n    // Then position prefixes around the perimeter\n    return {\n      name: 'preset',\n      positions: (node) => {\n        if (!node?.data?.type) return null;\n\n        const width = cy.width();\n        const height = cy.height();\n        const centerX = width / 2;\n        const centerY = height / 2;\n        const radius = Math.min(width, height) * 0.4; // Slightly larger radius for prefixes\n\n        // For prefix nodes\n        if (isPrefix(node.data.type)) {\n          const connectedEdges = cy.edges().filter(edge => \n            edge.source().id() === node.id() || \n            edge.target().id() === node.id()\n          );\n\n          if (connectedEdges.length > 0) {\n            const connectedNode = connectedEdges[0].source().id() === node.id() \n              ? connectedEdges[0].target()\n              : connectedEdges[0].source();\n\n            if (connectedNode.position()) {\n              // Calculate angle based on connected node's position\n              const nodePos = connectedNode.position();\n              const angle = Math.atan2(nodePos.y - centerY, nodePos.x - centerX);\n              \n              // Add small random offset to avoid stacking\n              const offsetAngle = angle + (Math.random() - 0.5) * Math.PI / 6;\n              \n              return {\n                x: centerX + radius * Math.cos(offsetAngle),\n                y: centerY + radius * Math.sin(offsetAngle)\n              };\n            }\n          }\n\n          // Fallback for unconnected prefixes\n          const angle = 2 * Math.PI * Math.random();\n          return {\n            x: centerX + radius * Math.cos(angle),\n            y: centerY + radius * Math.sin(angle)\n          };\n        }\n\n        // Return existing positions for core nodes\n        return node.position();\n      },\n      fit: true,\n      padding: 50\n    };\n  };\n\n  // Ensure layout is applied after graph data changes\n  useEffect(() => {\n    if (graphData && cyRef.current) {\n      console.log('Applying layout to graph');\n      const layout = getLayout(graphData);\n      if (layout) {\n        cyRef.current.layout(layout).run();\n      }\n    }\n  }, [graphData]);\n\n  const stylesheet = [\n    {\n      selector: 'node',\n      style: {\n        'background-color': (ele) => {\n          const type = ele.data('type');\n          // Treat all prefix types the same\n          if (isPrefix(type)) return COLORS.prefix;\n          return COLORS[type] || COLORS.igp_node;\n        },\n        'label': 'data(label)',\n        'width': 30,\n        'height': 30,\n        'color': COLORS.text,\n        'text-outline-width': 2,\n        'text-outline-color': '#fff',\n        'font-family': 'Consolas',\n        'font-size': '10px',\n        'text-wrap': 'wrap',\n        'text-max-width': '100px'\n      }\n    },\n    {\n      selector: 'edge',\n      style: {\n        'width': 1.5,\n        'line-color': COLORS.edge,\n        'curve-style': 'bezier',\n        'target-arrow-color': COLORS.edge,\n        'target-arrow-shape': 'triangle',\n        'arrow-scale': 0.8\n      }\n    }\n  ];\n\n  const Legend = () => (\n    <div className=\"graph-legend\">\n      <h3>Legend</h3>\n      <div className=\"legend-item\">\n        <span className=\"legend-color\" style={{ backgroundColor: COLORS.igp_node }}></span>\n        <span>IGP Nodes</span>\n      </div>\n      <div className=\"legend-item\">\n        <span className=\"legend-color\" style={{ backgroundColor: COLORS.bgp_node }}></span>\n        <span>BGP Nodes</span>\n      </div>\n      <div className=\"legend-item\">\n        <span className=\"legend-color\" style={{ backgroundColor: COLORS.prefix }}></span>\n        <span>Prefixes</span>\n      </div>\n    </div>\n  );\n\n  if (isLoading) {\n    return <div style={{ padding: '20px', fontFamily: 'Consolas' }}>Loading graph data...</div>;\n  }\n\n  if (error) {\n    return <div style={{ padding: '20px', color: 'red', fontFamily: 'Consolas' }}>{error}</div>;\n  }\n\n  if (!graphData) {\n    return <div style={{ padding: '20px', fontFamily: 'Consolas' }}>Select a graph to visualize</div>;\n  }\n\n  return (\n    <div className=\"network-graph-container\">\n      <Legend />\n      <div className=\"graph-area\">\n        <CytoscapeComponent\n          elements={graphData}\n          layout={getLayout(graphData)}\n          stylesheet={stylesheet}\n          cy={(cy) => { cyRef.current = cy; }}\n          style={{ width: '100%', height: '100%' }}\n        />\n      </div>\n    </div>\n  );\n};\n\nexport default NetworkGraph; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}