{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar pqueue_1 = require(\"./pqueue\");\nvar Neighbour = function () {\n  function Neighbour(id, distance) {\n    this.id = id;\n    this.distance = distance;\n  }\n  return Neighbour;\n}();\nvar Node = function () {\n  function Node(id) {\n    this.id = id;\n    this.neighbours = [];\n  }\n  return Node;\n}();\nvar QueueEntry = function () {\n  function QueueEntry(node, prev, d) {\n    this.node = node;\n    this.prev = prev;\n    this.d = d;\n  }\n  return QueueEntry;\n}();\nvar Calculator = function () {\n  function Calculator(n, es, getSourceIndex, getTargetIndex, getLength) {\n    this.n = n;\n    this.es = es;\n    this.neighbours = new Array(this.n);\n    var i = this.n;\n    while (i--) this.neighbours[i] = new Node(i);\n    i = this.es.length;\n    while (i--) {\n      var e = this.es[i];\n      var u = getSourceIndex(e),\n        v = getTargetIndex(e);\n      var d = getLength(e);\n      this.neighbours[u].neighbours.push(new Neighbour(v, d));\n      this.neighbours[v].neighbours.push(new Neighbour(u, d));\n    }\n  }\n  Calculator.prototype.DistanceMatrix = function () {\n    var D = new Array(this.n);\n    for (var i = 0; i < this.n; ++i) {\n      D[i] = this.dijkstraNeighbours(i);\n    }\n    return D;\n  };\n  Calculator.prototype.DistancesFromNode = function (start) {\n    return this.dijkstraNeighbours(start);\n  };\n  Calculator.prototype.PathFromNodeToNode = function (start, end) {\n    return this.dijkstraNeighbours(start, end);\n  };\n  Calculator.prototype.PathFromNodeToNodeWithPrevCost = function (start, end, prevCost) {\n    var q = new pqueue_1.PriorityQueue(function (a, b) {\n        return a.d <= b.d;\n      }),\n      u = this.neighbours[start],\n      qu = new QueueEntry(u, null, 0),\n      visitedFrom = {};\n    q.push(qu);\n    while (!q.empty()) {\n      qu = q.pop();\n      u = qu.node;\n      if (u.id === end) {\n        break;\n      }\n      var i = u.neighbours.length;\n      while (i--) {\n        var neighbour = u.neighbours[i],\n          v = this.neighbours[neighbour.id];\n        if (qu.prev && v.id === qu.prev.node.id) continue;\n        var viduid = v.id + ',' + u.id;\n        if (viduid in visitedFrom && visitedFrom[viduid] <= qu.d) continue;\n        var cc = qu.prev ? prevCost(qu.prev.node.id, u.id, v.id) : 0,\n          t = qu.d + neighbour.distance + cc;\n        visitedFrom[viduid] = t;\n        q.push(new QueueEntry(v, qu, t));\n      }\n    }\n    var path = [];\n    while (qu.prev) {\n      qu = qu.prev;\n      path.push(qu.node.id);\n    }\n    return path;\n  };\n  Calculator.prototype.dijkstraNeighbours = function (start, dest) {\n    if (dest === void 0) {\n      dest = -1;\n    }\n    var q = new pqueue_1.PriorityQueue(function (a, b) {\n        return a.d <= b.d;\n      }),\n      i = this.neighbours.length,\n      d = new Array(i);\n    while (i--) {\n      var node = this.neighbours[i];\n      node.d = i === start ? 0 : Number.POSITIVE_INFINITY;\n      node.q = q.push(node);\n    }\n    while (!q.empty()) {\n      var u = q.pop();\n      d[u.id] = u.d;\n      if (u.id === dest) {\n        var path = [];\n        var v = u;\n        while (typeof v.prev !== 'undefined') {\n          path.push(v.prev.id);\n          v = v.prev;\n        }\n        return path;\n      }\n      i = u.neighbours.length;\n      while (i--) {\n        var neighbour = u.neighbours[i];\n        var v = this.neighbours[neighbour.id];\n        var t = u.d + neighbour.distance;\n        if (u.d !== Number.MAX_VALUE && v.d > t) {\n          v.d = t;\n          v.prev = u;\n          q.reduceKey(v.q, v, function (e, q) {\n            return e.q = q;\n          });\n        }\n      }\n    }\n    return d;\n  };\n  return Calculator;\n}();\nexports.Calculator = Calculator;","map":{"version":3,"names":["pqueue_1","require","Neighbour","id","distance","Node","neighbours","QueueEntry","node","prev","d","Calculator","n","es","getSourceIndex","getTargetIndex","getLength","Array","i","length","e","u","v","push","prototype","DistanceMatrix","D","dijkstraNeighbours","DistancesFromNode","start","PathFromNodeToNode","end","PathFromNodeToNodeWithPrevCost","prevCost","q","PriorityQueue","a","b","qu","visitedFrom","empty","pop","neighbour","viduid","cc","t","path","dest","Number","POSITIVE_INFINITY","MAX_VALUE","reduceKey","exports"],"sources":["/Users/brucemcdougall/go/jalapeno-github/jalapeno-ui/node_modules/webcola/WebCola/src/shortestpaths.ts"],"sourcesContent":["import {PairingHeap, PriorityQueue} from './pqueue'\r\n\r\nclass Neighbour {\r\n    constructor(public id: number, public distance: number) { }\r\n}\r\n\r\nclass Node {\r\n    constructor(public id: number) {\r\n        this.neighbours = [];\r\n    }\r\n    neighbours: Neighbour[];\r\n    d: number;\r\n    prev: Node;\r\n    q: PairingHeap<Node>;\r\n}\r\n\r\nclass QueueEntry {\r\n    constructor(public node: Node, public prev: QueueEntry, public d: number) {}\r\n}\r\n\r\n/**\r\n * calculates all-pairs shortest paths or shortest paths from a single node\r\n * @class Calculator\r\n * @constructor\r\n * @param n {number} number of nodes\r\n * @param es {Edge[]} array of edges\r\n */\r\nexport class Calculator<Link> {\r\n    private neighbours: Node[];\r\n\r\n    constructor(public n: number, public es: Link[], getSourceIndex: (l: Link) => number, getTargetIndex: (l: Link) => number, getLength: (l: Link) => number) {\r\n        this.neighbours = new Array(this.n);\r\n        var i = this.n; while (i--) this.neighbours[i] = new Node(i);\r\n\r\n        i = this.es.length; while (i--) {\r\n            var e = this.es[i];\r\n            var u: number = getSourceIndex(e), v: number = getTargetIndex(e);\r\n            var d = getLength(e);\r\n            this.neighbours[u].neighbours.push(new Neighbour(v, d));\r\n            this.neighbours[v].neighbours.push(new Neighbour(u, d));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * compute shortest paths for graph over n nodes with edges an array of source/target pairs\r\n     * edges may optionally have a length attribute.  1 is the default.\r\n     * Uses Johnson's algorithm.\r\n     *\r\n     * @method DistanceMatrix\r\n     * @return the distance matrix\r\n     */\r\n    DistanceMatrix(): number[][] {\r\n        var D = new Array(this.n);\r\n        for (var i = 0; i < this.n; ++i) {\r\n            D[i] = this.dijkstraNeighbours(i);\r\n        }\r\n        return D;\r\n    }\r\n\r\n    /**\r\n     * get shortest paths from a specified start node\r\n     * @method DistancesFromNode\r\n     * @param start node index\r\n     * @return array of path lengths\r\n     */\r\n    DistancesFromNode(start: number): number[] {\r\n        return this.dijkstraNeighbours(start);\r\n    }\r\n\r\n    PathFromNodeToNode(start: number, end: number): number[] {\r\n        return this.dijkstraNeighbours(start, end);\r\n    }\r\n\r\n    // find shortest path from start to end, with the opportunity at\r\n    // each edge traversal to compute a custom cost based on the\r\n    // previous edge.  For example, to penalise bends.\r\n    PathFromNodeToNodeWithPrevCost(\r\n        start: number,\r\n        end: number,\r\n        prevCost: (u:number,v:number,w:number)=>number): number[]\r\n    {\r\n        var q = new PriorityQueue<QueueEntry>((a, b) => a.d <= b.d),\r\n            u: Node = this.neighbours[start],\r\n            qu: QueueEntry = new QueueEntry(u,null,0),\r\n            visitedFrom = {};\r\n        q.push(qu);\r\n        while(!q.empty()) {\r\n            qu = q.pop();\r\n            u = qu.node;\r\n            if (u.id === end) {\r\n                break;\r\n            }\r\n            var i = u.neighbours.length; while (i--) {\r\n                var neighbour = u.neighbours[i],\r\n                    v = this.neighbours[neighbour.id];\r\n\r\n                // don't double back\r\n                if (qu.prev && v.id === qu.prev.node.id) continue;\r\n\r\n                // don't retraverse an edge if it has already been explored\r\n                // from a lower cost route\r\n                var viduid = v.id + ',' + u.id;\r\n                if(viduid in visitedFrom && visitedFrom[viduid] <= qu.d)\r\n                    continue;\r\n\r\n                var cc = qu.prev ? prevCost(qu.prev.node.id, u.id, v.id) : 0,\r\n                    t = qu.d + neighbour.distance + cc;\r\n\r\n                // store cost of this traversal\r\n                visitedFrom[viduid] = t;\r\n                q.push(new QueueEntry(v, qu, t));\r\n            }\r\n        }\r\n        var path:number[] = [];\r\n        while (qu.prev) {\r\n            qu = qu.prev;\r\n            path.push(qu.node.id);\r\n        }\r\n        return path;\r\n    }\r\n\r\n    private dijkstraNeighbours(start: number, dest: number = -1): number[] {\r\n        var q = new PriorityQueue<Node>((a, b) => a.d <= b.d),\r\n            i = this.neighbours.length,\r\n            d: number[] = new Array(i);\r\n        while (i--) {\r\n            var node: Node = this.neighbours[i];\r\n            node.d = i === start ? 0 : Number.POSITIVE_INFINITY;\r\n            node.q = q.push(node);\r\n        }\r\n        while (!q.empty()) {\r\n            // console.log(q.toString(function (u) { return u.id + \"=\" + (u.d === Number.POSITIVE_INFINITY ? \"\\u221E\" : u.d.toFixed(2) )}));\r\n            var u = q.pop();\r\n            d[u.id] = u.d;\r\n            if (u.id === dest) {\r\n                var path: number[] = [];\r\n                var v = u;\r\n                while (typeof v.prev !== 'undefined') {\r\n                    path.push(v.prev.id);\r\n                    v = v.prev;\r\n                }\r\n                return path;\r\n            }\r\n            i = u.neighbours.length; while (i--) {\r\n                var neighbour = u.neighbours[i];\r\n                var v = this.neighbours[neighbour.id];\r\n                var t = u.d + neighbour.distance;\r\n                if (u.d !== Number.MAX_VALUE && v.d > t) {\r\n                    v.d = t;\r\n                    v.prev = u;\r\n                    q.reduceKey(v.q, v, (e,q)=>e.q = q);\r\n                }\r\n            }\r\n        }\r\n        return d;\r\n    }\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}