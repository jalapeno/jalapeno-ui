{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar vpsc_1 = require(\"./vpsc\");\nvar rbtree_1 = require(\"./rbtree\");\nfunction computeGroupBounds(g) {\n  g.bounds = typeof g.leaves !== \"undefined\" ? g.leaves.reduce(function (r, c) {\n    return c.bounds.union(r);\n  }, Rectangle.empty()) : Rectangle.empty();\n  if (typeof g.groups !== \"undefined\") g.bounds = g.groups.reduce(function (r, c) {\n    return computeGroupBounds(c).union(r);\n  }, g.bounds);\n  g.bounds = g.bounds.inflate(g.padding);\n  return g.bounds;\n}\nexports.computeGroupBounds = computeGroupBounds;\nvar Rectangle = function () {\n  function Rectangle(x, X, y, Y) {\n    this.x = x;\n    this.X = X;\n    this.y = y;\n    this.Y = Y;\n  }\n  Rectangle.empty = function () {\n    return new Rectangle(Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY);\n  };\n  Rectangle.prototype.cx = function () {\n    return (this.x + this.X) / 2;\n  };\n  Rectangle.prototype.cy = function () {\n    return (this.y + this.Y) / 2;\n  };\n  Rectangle.prototype.overlapX = function (r) {\n    var ux = this.cx(),\n      vx = r.cx();\n    if (ux <= vx && r.x < this.X) return this.X - r.x;\n    if (vx <= ux && this.x < r.X) return r.X - this.x;\n    return 0;\n  };\n  Rectangle.prototype.overlapY = function (r) {\n    var uy = this.cy(),\n      vy = r.cy();\n    if (uy <= vy && r.y < this.Y) return this.Y - r.y;\n    if (vy <= uy && this.y < r.Y) return r.Y - this.y;\n    return 0;\n  };\n  Rectangle.prototype.setXCentre = function (cx) {\n    var dx = cx - this.cx();\n    this.x += dx;\n    this.X += dx;\n  };\n  Rectangle.prototype.setYCentre = function (cy) {\n    var dy = cy - this.cy();\n    this.y += dy;\n    this.Y += dy;\n  };\n  Rectangle.prototype.width = function () {\n    return this.X - this.x;\n  };\n  Rectangle.prototype.height = function () {\n    return this.Y - this.y;\n  };\n  Rectangle.prototype.union = function (r) {\n    return new Rectangle(Math.min(this.x, r.x), Math.max(this.X, r.X), Math.min(this.y, r.y), Math.max(this.Y, r.Y));\n  };\n  Rectangle.prototype.lineIntersections = function (x1, y1, x2, y2) {\n    var sides = [[this.x, this.y, this.X, this.y], [this.X, this.y, this.X, this.Y], [this.X, this.Y, this.x, this.Y], [this.x, this.Y, this.x, this.y]];\n    var intersections = [];\n    for (var i = 0; i < 4; ++i) {\n      var r = Rectangle.lineIntersection(x1, y1, x2, y2, sides[i][0], sides[i][1], sides[i][2], sides[i][3]);\n      if (r !== null) intersections.push({\n        x: r.x,\n        y: r.y\n      });\n    }\n    return intersections;\n  };\n  Rectangle.prototype.rayIntersection = function (x2, y2) {\n    var ints = this.lineIntersections(this.cx(), this.cy(), x2, y2);\n    return ints.length > 0 ? ints[0] : null;\n  };\n  Rectangle.prototype.vertices = function () {\n    return [{\n      x: this.x,\n      y: this.y\n    }, {\n      x: this.X,\n      y: this.y\n    }, {\n      x: this.X,\n      y: this.Y\n    }, {\n      x: this.x,\n      y: this.Y\n    }];\n  };\n  Rectangle.lineIntersection = function (x1, y1, x2, y2, x3, y3, x4, y4) {\n    var dx12 = x2 - x1,\n      dx34 = x4 - x3,\n      dy12 = y2 - y1,\n      dy34 = y4 - y3,\n      denominator = dy34 * dx12 - dx34 * dy12;\n    if (denominator == 0) return null;\n    var dx31 = x1 - x3,\n      dy31 = y1 - y3,\n      numa = dx34 * dy31 - dy34 * dx31,\n      a = numa / denominator,\n      numb = dx12 * dy31 - dy12 * dx31,\n      b = numb / denominator;\n    if (a >= 0 && a <= 1 && b >= 0 && b <= 1) {\n      return {\n        x: x1 + a * dx12,\n        y: y1 + a * dy12\n      };\n    }\n    return null;\n  };\n  Rectangle.prototype.inflate = function (pad) {\n    return new Rectangle(this.x - pad, this.X + pad, this.y - pad, this.Y + pad);\n  };\n  return Rectangle;\n}();\nexports.Rectangle = Rectangle;\nfunction makeEdgeBetween(source, target, ah) {\n  var si = source.rayIntersection(target.cx(), target.cy()) || {\n      x: source.cx(),\n      y: source.cy()\n    },\n    ti = target.rayIntersection(source.cx(), source.cy()) || {\n      x: target.cx(),\n      y: target.cy()\n    },\n    dx = ti.x - si.x,\n    dy = ti.y - si.y,\n    l = Math.sqrt(dx * dx + dy * dy),\n    al = l - ah;\n  return {\n    sourceIntersection: si,\n    targetIntersection: ti,\n    arrowStart: {\n      x: si.x + al * dx / l,\n      y: si.y + al * dy / l\n    }\n  };\n}\nexports.makeEdgeBetween = makeEdgeBetween;\nfunction makeEdgeTo(s, target, ah) {\n  var ti = target.rayIntersection(s.x, s.y);\n  if (!ti) ti = {\n    x: target.cx(),\n    y: target.cy()\n  };\n  var dx = ti.x - s.x,\n    dy = ti.y - s.y,\n    l = Math.sqrt(dx * dx + dy * dy);\n  return {\n    x: ti.x - ah * dx / l,\n    y: ti.y - ah * dy / l\n  };\n}\nexports.makeEdgeTo = makeEdgeTo;\nvar Node = function () {\n  function Node(v, r, pos) {\n    this.v = v;\n    this.r = r;\n    this.pos = pos;\n    this.prev = makeRBTree();\n    this.next = makeRBTree();\n  }\n  return Node;\n}();\nvar Event = function () {\n  function Event(isOpen, v, pos) {\n    this.isOpen = isOpen;\n    this.v = v;\n    this.pos = pos;\n  }\n  return Event;\n}();\nfunction compareEvents(a, b) {\n  if (a.pos > b.pos) {\n    return 1;\n  }\n  if (a.pos < b.pos) {\n    return -1;\n  }\n  if (a.isOpen) {\n    return -1;\n  }\n  if (b.isOpen) {\n    return 1;\n  }\n  return 0;\n}\nfunction makeRBTree() {\n  return new rbtree_1.RBTree(function (a, b) {\n    return a.pos - b.pos;\n  });\n}\nvar xRect = {\n  getCentre: function (r) {\n    return r.cx();\n  },\n  getOpen: function (r) {\n    return r.y;\n  },\n  getClose: function (r) {\n    return r.Y;\n  },\n  getSize: function (r) {\n    return r.width();\n  },\n  makeRect: function (open, close, center, size) {\n    return new Rectangle(center - size / 2, center + size / 2, open, close);\n  },\n  findNeighbours: findXNeighbours\n};\nvar yRect = {\n  getCentre: function (r) {\n    return r.cy();\n  },\n  getOpen: function (r) {\n    return r.x;\n  },\n  getClose: function (r) {\n    return r.X;\n  },\n  getSize: function (r) {\n    return r.height();\n  },\n  makeRect: function (open, close, center, size) {\n    return new Rectangle(open, close, center - size / 2, center + size / 2);\n  },\n  findNeighbours: findYNeighbours\n};\nfunction generateGroupConstraints(root, f, minSep, isContained) {\n  if (isContained === void 0) {\n    isContained = false;\n  }\n  var padding = root.padding,\n    gn = typeof root.groups !== 'undefined' ? root.groups.length : 0,\n    ln = typeof root.leaves !== 'undefined' ? root.leaves.length : 0,\n    childConstraints = !gn ? [] : root.groups.reduce(function (ccs, g) {\n      return ccs.concat(generateGroupConstraints(g, f, minSep, true));\n    }, []),\n    n = (isContained ? 2 : 0) + ln + gn,\n    vs = new Array(n),\n    rs = new Array(n),\n    i = 0,\n    add = function (r, v) {\n      rs[i] = r;\n      vs[i++] = v;\n    };\n  if (isContained) {\n    var b = root.bounds,\n      c = f.getCentre(b),\n      s = f.getSize(b) / 2,\n      open = f.getOpen(b),\n      close = f.getClose(b),\n      min = c - s + padding / 2,\n      max = c + s - padding / 2;\n    root.minVar.desiredPosition = min;\n    add(f.makeRect(open, close, min, padding), root.minVar);\n    root.maxVar.desiredPosition = max;\n    add(f.makeRect(open, close, max, padding), root.maxVar);\n  }\n  if (ln) root.leaves.forEach(function (l) {\n    return add(l.bounds, l.variable);\n  });\n  if (gn) root.groups.forEach(function (g) {\n    var b = g.bounds;\n    add(f.makeRect(f.getOpen(b), f.getClose(b), f.getCentre(b), f.getSize(b)), g.minVar);\n  });\n  var cs = generateConstraints(rs, vs, f, minSep);\n  if (gn) {\n    vs.forEach(function (v) {\n      v.cOut = [], v.cIn = [];\n    });\n    cs.forEach(function (c) {\n      c.left.cOut.push(c), c.right.cIn.push(c);\n    });\n    root.groups.forEach(function (g) {\n      var gapAdjustment = (g.padding - f.getSize(g.bounds)) / 2;\n      g.minVar.cIn.forEach(function (c) {\n        return c.gap += gapAdjustment;\n      });\n      g.minVar.cOut.forEach(function (c) {\n        c.left = g.maxVar;\n        c.gap += gapAdjustment;\n      });\n    });\n  }\n  return childConstraints.concat(cs);\n}\nfunction generateConstraints(rs, vars, rect, minSep) {\n  var i,\n    n = rs.length;\n  var N = 2 * n;\n  console.assert(vars.length >= n);\n  var events = new Array(N);\n  for (i = 0; i < n; ++i) {\n    var r = rs[i];\n    var v = new Node(vars[i], r, rect.getCentre(r));\n    events[i] = new Event(true, v, rect.getOpen(r));\n    events[i + n] = new Event(false, v, rect.getClose(r));\n  }\n  events.sort(compareEvents);\n  var cs = new Array();\n  var scanline = makeRBTree();\n  for (i = 0; i < N; ++i) {\n    var e = events[i];\n    var v = e.v;\n    if (e.isOpen) {\n      scanline.insert(v);\n      rect.findNeighbours(v, scanline);\n    } else {\n      scanline.remove(v);\n      var makeConstraint = function (l, r) {\n        var sep = (rect.getSize(l.r) + rect.getSize(r.r)) / 2 + minSep;\n        cs.push(new vpsc_1.Constraint(l.v, r.v, sep));\n      };\n      var visitNeighbours = function (forward, reverse, mkcon) {\n        var u,\n          it = v[forward].iterator();\n        while ((u = it[forward]()) !== null) {\n          mkcon(u, v);\n          u[reverse].remove(v);\n        }\n      };\n      visitNeighbours(\"prev\", \"next\", function (u, v) {\n        return makeConstraint(u, v);\n      });\n      visitNeighbours(\"next\", \"prev\", function (u, v) {\n        return makeConstraint(v, u);\n      });\n    }\n  }\n  console.assert(scanline.size === 0);\n  return cs;\n}\nfunction findXNeighbours(v, scanline) {\n  var f = function (forward, reverse) {\n    var it = scanline.findIter(v);\n    var u;\n    while ((u = it[forward]()) !== null) {\n      var uovervX = u.r.overlapX(v.r);\n      if (uovervX <= 0 || uovervX <= u.r.overlapY(v.r)) {\n        v[forward].insert(u);\n        u[reverse].insert(v);\n      }\n      if (uovervX <= 0) {\n        break;\n      }\n    }\n  };\n  f(\"next\", \"prev\");\n  f(\"prev\", \"next\");\n}\nfunction findYNeighbours(v, scanline) {\n  var f = function (forward, reverse) {\n    var u = scanline.findIter(v)[forward]();\n    if (u !== null && u.r.overlapX(v.r) > 0) {\n      v[forward].insert(u);\n      u[reverse].insert(v);\n    }\n  };\n  f(\"next\", \"prev\");\n  f(\"prev\", \"next\");\n}\nfunction generateXConstraints(rs, vars) {\n  return generateConstraints(rs, vars, xRect, 1e-6);\n}\nexports.generateXConstraints = generateXConstraints;\nfunction generateYConstraints(rs, vars) {\n  return generateConstraints(rs, vars, yRect, 1e-6);\n}\nexports.generateYConstraints = generateYConstraints;\nfunction generateXGroupConstraints(root) {\n  return generateGroupConstraints(root, xRect, 1e-6);\n}\nexports.generateXGroupConstraints = generateXGroupConstraints;\nfunction generateYGroupConstraints(root) {\n  return generateGroupConstraints(root, yRect, 1e-6);\n}\nexports.generateYGroupConstraints = generateYGroupConstraints;\nfunction removeOverlaps(rs) {\n  var vs = rs.map(function (r) {\n    return new vpsc_1.Variable(r.cx());\n  });\n  var cs = generateXConstraints(rs, vs);\n  var solver = new vpsc_1.Solver(vs, cs);\n  solver.solve();\n  vs.forEach(function (v, i) {\n    return rs[i].setXCentre(v.position());\n  });\n  vs = rs.map(function (r) {\n    return new vpsc_1.Variable(r.cy());\n  });\n  cs = generateYConstraints(rs, vs);\n  solver = new vpsc_1.Solver(vs, cs);\n  solver.solve();\n  vs.forEach(function (v, i) {\n    return rs[i].setYCentre(v.position());\n  });\n}\nexports.removeOverlaps = removeOverlaps;\nvar IndexedVariable = function (_super) {\n  __extends(IndexedVariable, _super);\n  function IndexedVariable(index, w) {\n    var _this = _super.call(this, 0, w) || this;\n    _this.index = index;\n    return _this;\n  }\n  return IndexedVariable;\n}(vpsc_1.Variable);\nexports.IndexedVariable = IndexedVariable;\nvar Projection = function () {\n  function Projection(nodes, groups, rootGroup, constraints, avoidOverlaps) {\n    var _this = this;\n    if (rootGroup === void 0) {\n      rootGroup = null;\n    }\n    if (constraints === void 0) {\n      constraints = null;\n    }\n    if (avoidOverlaps === void 0) {\n      avoidOverlaps = false;\n    }\n    this.nodes = nodes;\n    this.groups = groups;\n    this.rootGroup = rootGroup;\n    this.avoidOverlaps = avoidOverlaps;\n    this.variables = nodes.map(function (v, i) {\n      return v.variable = new IndexedVariable(i, 1);\n    });\n    if (constraints) this.createConstraints(constraints);\n    if (avoidOverlaps && rootGroup && typeof rootGroup.groups !== 'undefined') {\n      nodes.forEach(function (v) {\n        if (!v.width || !v.height) {\n          v.bounds = new Rectangle(v.x, v.x, v.y, v.y);\n          return;\n        }\n        var w2 = v.width / 2,\n          h2 = v.height / 2;\n        v.bounds = new Rectangle(v.x - w2, v.x + w2, v.y - h2, v.y + h2);\n      });\n      computeGroupBounds(rootGroup);\n      var i = nodes.length;\n      groups.forEach(function (g) {\n        _this.variables[i] = g.minVar = new IndexedVariable(i++, typeof g.stiffness !== \"undefined\" ? g.stiffness : 0.01);\n        _this.variables[i] = g.maxVar = new IndexedVariable(i++, typeof g.stiffness !== \"undefined\" ? g.stiffness : 0.01);\n      });\n    }\n  }\n  Projection.prototype.createSeparation = function (c) {\n    return new vpsc_1.Constraint(this.nodes[c.left].variable, this.nodes[c.right].variable, c.gap, typeof c.equality !== \"undefined\" ? c.equality : false);\n  };\n  Projection.prototype.makeFeasible = function (c) {\n    var _this = this;\n    if (!this.avoidOverlaps) return;\n    var axis = 'x',\n      dim = 'width';\n    if (c.axis === 'x') axis = 'y', dim = 'height';\n    var vs = c.offsets.map(function (o) {\n      return _this.nodes[o.node];\n    }).sort(function (a, b) {\n      return a[axis] - b[axis];\n    });\n    var p = null;\n    vs.forEach(function (v) {\n      if (p) {\n        var nextPos = p[axis] + p[dim];\n        if (nextPos > v[axis]) {\n          v[axis] = nextPos;\n        }\n      }\n      p = v;\n    });\n  };\n  Projection.prototype.createAlignment = function (c) {\n    var _this = this;\n    var u = this.nodes[c.offsets[0].node].variable;\n    this.makeFeasible(c);\n    var cs = c.axis === 'x' ? this.xConstraints : this.yConstraints;\n    c.offsets.slice(1).forEach(function (o) {\n      var v = _this.nodes[o.node].variable;\n      cs.push(new vpsc_1.Constraint(u, v, o.offset, true));\n    });\n  };\n  Projection.prototype.createConstraints = function (constraints) {\n    var _this = this;\n    var isSep = function (c) {\n      return typeof c.type === 'undefined' || c.type === 'separation';\n    };\n    this.xConstraints = constraints.filter(function (c) {\n      return c.axis === \"x\" && isSep(c);\n    }).map(function (c) {\n      return _this.createSeparation(c);\n    });\n    this.yConstraints = constraints.filter(function (c) {\n      return c.axis === \"y\" && isSep(c);\n    }).map(function (c) {\n      return _this.createSeparation(c);\n    });\n    constraints.filter(function (c) {\n      return c.type === 'alignment';\n    }).forEach(function (c) {\n      return _this.createAlignment(c);\n    });\n  };\n  Projection.prototype.setupVariablesAndBounds = function (x0, y0, desired, getDesired) {\n    this.nodes.forEach(function (v, i) {\n      if (v.fixed) {\n        v.variable.weight = v.fixedWeight ? v.fixedWeight : 1000;\n        desired[i] = getDesired(v);\n      } else {\n        v.variable.weight = 1;\n      }\n      var w = (v.width || 0) / 2,\n        h = (v.height || 0) / 2;\n      var ix = x0[i],\n        iy = y0[i];\n      v.bounds = new Rectangle(ix - w, ix + w, iy - h, iy + h);\n    });\n  };\n  Projection.prototype.xProject = function (x0, y0, x) {\n    if (!this.rootGroup && !(this.avoidOverlaps || this.xConstraints)) return;\n    this.project(x0, y0, x0, x, function (v) {\n      return v.px;\n    }, this.xConstraints, generateXGroupConstraints, function (v) {\n      return v.bounds.setXCentre(x[v.variable.index] = v.variable.position());\n    }, function (g) {\n      var xmin = x[g.minVar.index] = g.minVar.position();\n      var xmax = x[g.maxVar.index] = g.maxVar.position();\n      var p2 = g.padding / 2;\n      g.bounds.x = xmin - p2;\n      g.bounds.X = xmax + p2;\n    });\n  };\n  Projection.prototype.yProject = function (x0, y0, y) {\n    if (!this.rootGroup && !this.yConstraints) return;\n    this.project(x0, y0, y0, y, function (v) {\n      return v.py;\n    }, this.yConstraints, generateYGroupConstraints, function (v) {\n      return v.bounds.setYCentre(y[v.variable.index] = v.variable.position());\n    }, function (g) {\n      var ymin = y[g.minVar.index] = g.minVar.position();\n      var ymax = y[g.maxVar.index] = g.maxVar.position();\n      var p2 = g.padding / 2;\n      g.bounds.y = ymin - p2;\n      ;\n      g.bounds.Y = ymax + p2;\n    });\n  };\n  Projection.prototype.projectFunctions = function () {\n    var _this = this;\n    return [function (x0, y0, x) {\n      return _this.xProject(x0, y0, x);\n    }, function (x0, y0, y) {\n      return _this.yProject(x0, y0, y);\n    }];\n  };\n  Projection.prototype.project = function (x0, y0, start, desired, getDesired, cs, generateConstraints, updateNodeBounds, updateGroupBounds) {\n    this.setupVariablesAndBounds(x0, y0, desired, getDesired);\n    if (this.rootGroup && this.avoidOverlaps) {\n      computeGroupBounds(this.rootGroup);\n      cs = cs.concat(generateConstraints(this.rootGroup));\n    }\n    this.solve(this.variables, cs, start, desired);\n    this.nodes.forEach(updateNodeBounds);\n    if (this.rootGroup && this.avoidOverlaps) {\n      this.groups.forEach(updateGroupBounds);\n      computeGroupBounds(this.rootGroup);\n    }\n  };\n  Projection.prototype.solve = function (vs, cs, starting, desired) {\n    var solver = new vpsc_1.Solver(vs, cs);\n    solver.setStartingPositions(starting);\n    solver.setDesiredPositions(desired);\n    solver.solve();\n  };\n  return Projection;\n}();\nexports.Projection = Projection;","map":{"version":3,"names":["vpsc_1","require","rbtree_1","computeGroupBounds","g","bounds","leaves","reduce","r","c","union","Rectangle","empty","groups","inflate","padding","exports","x","X","y","Y","Number","POSITIVE_INFINITY","NEGATIVE_INFINITY","prototype","cx","cy","overlapX","ux","vx","overlapY","uy","vy","setXCentre","dx","setYCentre","dy","width","height","Math","min","max","lineIntersections","x1","y1","x2","y2","sides","intersections","i","lineIntersection","push","rayIntersection","ints","length","vertices","x3","y3","x4","y4","dx12","dx34","dy12","dy34","denominator","dx31","dy31","numa","a","numb","b","pad","makeEdgeBetween","source","target","ah","si","ti","l","sqrt","al","sourceIntersection","targetIntersection","arrowStart","makeEdgeTo","s","Node","v","pos","prev","makeRBTree","next","Event","isOpen","compareEvents","RBTree","xRect","getCentre","getOpen","getClose","getSize","makeRect","open","close","center","size","findNeighbours","findXNeighbours","yRect","findYNeighbours","generateGroupConstraints","root","f","minSep","isContained","gn","ln","childConstraints","ccs","concat","n","vs","Array","rs","add","minVar","desiredPosition","maxVar","forEach","variable","cs","generateConstraints","cOut","cIn","left","right","gapAdjustment","gap","vars","rect","N","console","assert","events","sort","scanline","e","insert","remove","makeConstraint","sep","Constraint","visitNeighbours","forward","reverse","mkcon","u","it","iterator","findIter","uovervX","generateXConstraints","generateYConstraints","generateXGroupConstraints","generateYGroupConstraints","removeOverlaps","map","Variable","solver","Solver","solve","position","IndexedVariable","_super","__extends","index","w","_this","call","Projection","nodes","rootGroup","constraints","avoidOverlaps","variables","createConstraints","w2","h2","stiffness","createSeparation","equality","makeFeasible","axis","dim","offsets","o","node","p","nextPos","createAlignment","xConstraints","yConstraints","slice","offset","isSep","type","filter","setupVariablesAndBounds","x0","y0","desired","getDesired","fixed","weight","fixedWeight","h","ix","iy","xProject","project","px","xmin","xmax","p2","yProject","py","ymin","ymax","projectFunctions","start","updateNodeBounds","updateGroupBounds","starting","setStartingPositions","setDesiredPositions"],"sources":["/Users/brucemcdougall/go/jalapeno-github/jalapeno-ui/node_modules/webcola/WebCola/src/rectangle.ts"],"sourcesContent":["import {Constraint, Variable, Solver} from './vpsc'\r\nimport {RBTree} from './rbtree'\r\nimport {Point} from './geom'\r\n\r\n    export interface Leaf {\r\n        bounds: Rectangle;\r\n        variable: Variable;\r\n    }\r\n\r\n    export interface ProjectionGroup {\r\n        bounds: Rectangle;\r\n        padding: number;\r\n        stiffness: number;\r\n        leaves: Leaf[];\r\n        groups: ProjectionGroup[];\r\n        minVar: Variable;\r\n        maxVar: Variable;\r\n    }\r\n\r\n    export function computeGroupBounds(g: ProjectionGroup): Rectangle {\r\n        g.bounds = typeof g.leaves !== \"undefined\" ?\r\n            g.leaves.reduce((r: Rectangle, c) => c.bounds.union(r), Rectangle.empty()) :\r\n            Rectangle.empty();\r\n        if (typeof g.groups !== \"undefined\")\r\n            g.bounds = <Rectangle>g.groups.reduce((r: Rectangle, c) => computeGroupBounds(c).union(r), g.bounds);\r\n        g.bounds = g.bounds.inflate(g.padding);\r\n        return g.bounds;\r\n    }\r\n\r\n    export class Rectangle {\r\n        constructor(\r\n            public x: number,\r\n            public X: number,\r\n            public y: number,\r\n            public Y: number) { }\r\n\r\n        static empty(): Rectangle { return new Rectangle(Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY); }\r\n\r\n        cx(): number { return (this.x + this.X) / 2; }\r\n\r\n        cy(): number { return (this.y + this.Y) / 2; }\r\n\r\n        overlapX(r: Rectangle): number {\r\n            var ux = this.cx(), vx = r.cx();\r\n            if (ux <= vx && r.x < this.X) return this.X - r.x;\r\n            if (vx <= ux && this.x < r.X) return r.X - this.x;\r\n            return 0;\r\n        }\r\n\r\n        overlapY(r: Rectangle): number {\r\n            var uy = this.cy(), vy = r.cy();\r\n            if (uy <= vy && r.y < this.Y) return this.Y - r.y;\r\n            if (vy <= uy && this.y < r.Y) return r.Y - this.y;\r\n            return 0;\r\n        }\r\n\r\n        setXCentre(cx: number): void {\r\n            var dx = cx - this.cx();\r\n            this.x += dx;\r\n            this.X += dx;\r\n        }\r\n\r\n        setYCentre(cy: number): void {\r\n            var dy = cy - this.cy();\r\n            this.y += dy;\r\n            this.Y += dy;\r\n        }\r\n\r\n        width(): number {\r\n            return this.X - this.x;\r\n        }\r\n\r\n        height(): number {\r\n            return this.Y - this.y;\r\n        }\r\n\r\n        union(r: Rectangle): Rectangle {\r\n            return new Rectangle(Math.min(this.x, r.x), Math.max(this.X, r.X), Math.min(this.y, r.y), Math.max(this.Y, r.Y));\r\n        }\r\n\r\n        /**\r\n         * return any intersection points between the given line and the sides of this rectangle\r\n         * @method lineIntersection\r\n         * @param x1 number first x coord of line\r\n         * @param y1 number first y coord of line\r\n         * @param x2 number second x coord of line\r\n         * @param y2 number second y coord of line\r\n         * @return any intersection points found\r\n         */\r\n        lineIntersections(x1: number, y1: number, x2: number, y2: number): Array<Point> {\r\n            var sides = [[this.x, this.y, this.X, this.y],\r\n                    [this.X, this.y, this.X, this.Y],\r\n                    [this.X, this.Y, this.x, this.Y],\r\n                [this.x, this.Y, this.x, this.y]];\r\n            var intersections = [];\r\n            for (var i = 0; i < 4; ++i) {\r\n                var r = Rectangle.lineIntersection(x1, y1, x2, y2, sides[i][0], sides[i][1], sides[i][2], sides[i][3]);\r\n                if (r !== null) intersections.push({ x: r.x, y: r.y });\r\n            }\r\n            return intersections;\r\n        }\r\n\r\n        /**\r\n         * return any intersection points between a line extending from the centre of this rectangle to the given point,\r\n         *  and the sides of this rectangle\r\n         * @method lineIntersection\r\n         * @param x2 number second x coord of line\r\n         * @param y2 number second y coord of line\r\n         * @return any intersection points found\r\n         */\r\n        rayIntersection(x2: number, y2: number): Point {\r\n            var ints = this.lineIntersections(this.cx(), this.cy(), x2, y2);\r\n            return ints.length > 0 ? ints[0] : null;\r\n        }\r\n\r\n        vertices(): Point[] {\r\n            return [\r\n                { x: this.x, y: this.y },\r\n                { x: this.X, y: this.y },\r\n                { x: this.X, y: this.Y },\r\n                { x: this.x, y: this.Y }];\r\n        }\r\n\r\n        static lineIntersection(\r\n            x1: number, y1: number,\r\n            x2: number, y2: number,\r\n            x3: number, y3: number,\r\n            x4: number, y4: number): Point {\r\n            var dx12 = x2 - x1, dx34 = x4 - x3,\r\n                dy12 = y2 - y1, dy34 = y4 - y3,\r\n                denominator = dy34 * dx12 - dx34 * dy12;\r\n            if (denominator == 0) return null;\r\n            var dx31 = x1 - x3, dy31 = y1 - y3,\r\n                numa = dx34 * dy31 - dy34 * dx31,\r\n                a = numa / denominator,\r\n                numb = dx12 * dy31 - dy12 * dx31,\r\n                b = numb / denominator;\r\n            if (a >= 0 && a <= 1 && b >= 0 && b <= 1) {\r\n                return {\r\n                    x: x1 + a * dx12,\r\n                    y: y1 + a * dy12\r\n                };\r\n            }\r\n            return null;\r\n        }\r\n\r\n        inflate(pad: number): Rectangle {\r\n            return new Rectangle(this.x - pad, this.X + pad, this.y - pad, this.Y + pad);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the endpoints of a line that connects the centre of two rectangles.\r\n     * @param {Rectangle} [source] The source Rectangle.\r\n     * @param {Rectangle} [target] The target Rectangle.\r\n     * @param {number} [ah] The size of the arrow head, a distance to shorten the\r\n     *                      line by.\r\n     * @return An object with three point properties, the intersection with the\r\n     *         source rectangle (sourceIntersection), the intersection with then\r\n     *         target rectangle (targetIntersection), and the point an arrow\r\n     *         head of the specified size would need to start (arrowStart).\r\n     */\r\n    export function makeEdgeBetween(source: Rectangle, target: Rectangle, ah: number)\r\n        : { sourceIntersection: Point; targetIntersection: Point; arrowStart: Point } {\r\n        const si = source.rayIntersection(target.cx(), target.cy()) || { x: source.cx(), y: source.cy() },\r\n            ti = target.rayIntersection(source.cx(), source.cy()) || { x: target.cx(), y: target.cy() },\r\n            dx = ti.x - si.x,\r\n            dy = ti.y - si.y,\r\n            l = Math.sqrt(dx * dx + dy * dy), al = l - ah;\r\n        return {\r\n            sourceIntersection: si,\r\n            targetIntersection: ti,\r\n            arrowStart: { x: si.x + al * dx / l, y: si.y + al * dy / l }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the intersection of a line from the given point to the centre\r\n     * of the target rectangle where it intersects the rectanngle.\r\n     * @param [source] The source point.\r\n     * @param {Rectangle} [target] The target Rectangle.\r\n     * @param {number} [ah] The size of the arrow head, a distance to shorten the\r\n     *                      line by.\r\n     * @return The point an arrow head of the specified size would need to start.\r\n     */\r\n    export function makeEdgeTo(s: { x: number; y: number }, target: Rectangle, ah: number): Point {\r\n        var ti = target.rayIntersection(s.x, s.y);\r\n        if (!ti) ti = { x: target.cx(), y: target.cy() };\r\n        var dx = ti.x - s.x,\r\n            dy = ti.y - s.y,\r\n            l = Math.sqrt(dx * dx + dy * dy);\r\n        return { x: ti.x - ah * dx / l, y: ti.y - ah * dy / l };\r\n    }\r\n\r\n    class Node {\r\n        prev: RBTree<Node>;\r\n        next: RBTree<Node>;\r\n\r\n        constructor(public v: Variable, public r: Rectangle, public pos: number) {\r\n            this.prev = makeRBTree();\r\n            this.next = makeRBTree();\r\n        }\r\n    }\r\n\r\n    class Event {\r\n        constructor(public isOpen: boolean, public v: Node, public pos: number) {}\r\n    }\r\n\r\n    function compareEvents(a: Event, b: Event): number {\r\n        if (a.pos > b.pos) {\r\n            return 1;\r\n        }\r\n        if (a.pos < b.pos) {\r\n            return -1;\r\n        }\r\n        if (a.isOpen) {\r\n            // open must come before close\r\n            return -1;\r\n        }\r\n        if (b.isOpen) {\r\n            // open must come before close\r\n            return 1;\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    function makeRBTree(): RBTree<Node> {\r\n        return new RBTree<Node>((a, b) => a.pos - b.pos);\r\n    }\r\n\r\n    interface RectAccessors {\r\n        getCentre: (r: Rectangle) => number;\r\n        getOpen: (r: Rectangle) => number;\r\n        getClose: (r: Rectangle) => number;\r\n        getSize: (r: Rectangle) => number;\r\n        makeRect: (open: number, close: number, center: number, size: number) => Rectangle;\r\n        findNeighbours: (v: Node, scanline: RBTree<Node>) => void;\r\n    }\r\n\r\n    var xRect: RectAccessors = {\r\n        getCentre: r=> r.cx(),\r\n        getOpen: r=> r.y,\r\n        getClose: r=> r.Y,\r\n        getSize: r=> r.width(),\r\n        makeRect: (open, close, center, size) => new Rectangle(center - size / 2, center + size / 2, open, close) ,\r\n        findNeighbours: findXNeighbours\r\n    };\r\n\r\n    var yRect: RectAccessors = {\r\n        getCentre: r=> r.cy(),\r\n        getOpen: r=> r.x,\r\n        getClose: r=> r.X,\r\n        getSize: r=> r.height(),\r\n        makeRect: (open, close, center, size) => new Rectangle(open, close, center - size / 2, center + size / 2),\r\n        findNeighbours: findYNeighbours\r\n    };\r\n\r\n    function generateGroupConstraints(root: ProjectionGroup, f: RectAccessors, minSep: number, isContained: boolean = false): Constraint[]\r\n    {\r\n        var padding = root.padding,\r\n            gn = typeof root.groups !== 'undefined' ? root.groups.length : 0,\r\n            ln = typeof root.leaves !== 'undefined' ? root.leaves.length : 0,\r\n            childConstraints: Constraint[] = !gn ? []\r\n            : root.groups.reduce((ccs: Constraint[], g) => ccs.concat(generateGroupConstraints(g, f, minSep, true)), []),\r\n            n = (isContained ? 2 : 0) + ln + gn,\r\n            vs: Variable[] = new Array(n),\r\n            rs: Rectangle[] = new Array(n),\r\n            i = 0,\r\n            add = (r, v) => { rs[i] = r; vs[i++] = v };\r\n        if (isContained) {\r\n            // if this group is contained by another, then we add two dummy vars and rectangles for the borders\r\n            var b: Rectangle = root.bounds,\r\n                c = f.getCentre(b), s = f.getSize(b) / 2,\r\n                open = f.getOpen(b), close = f.getClose(b),\r\n                min = c - s + padding / 2, max = c + s - padding / 2;\r\n            root.minVar.desiredPosition = min;\r\n            add(f.makeRect(open, close, min, padding), root.minVar);\r\n            root.maxVar.desiredPosition = max;\r\n            add(f.makeRect(open, close, max, padding), root.maxVar);\r\n        }\r\n        if (ln) root.leaves.forEach(l => add(l.bounds, l.variable));\r\n        if (gn) root.groups.forEach(g => {\r\n            var b: Rectangle = g.bounds;\r\n            add(f.makeRect(f.getOpen(b), f.getClose(b), f.getCentre(b), f.getSize(b)), g.minVar);\r\n        });\r\n        var cs = generateConstraints(rs, vs, f, minSep);\r\n        if (gn) {\r\n            vs.forEach(v => { v.cOut = [], v.cIn = [] });\r\n            cs.forEach(c => { c.left.cOut.push(c), c.right.cIn.push(c) });\r\n            root.groups.forEach(g => {\r\n                var gapAdjustment = (g.padding - f.getSize(g.bounds)) / 2;\r\n                g.minVar.cIn.forEach(c => c.gap += gapAdjustment);\r\n                g.minVar.cOut.forEach(c => { c.left = g.maxVar; c.gap += gapAdjustment; });\r\n            });\r\n        }\r\n        return childConstraints.concat(cs);\r\n    }\r\n\r\n    function generateConstraints(rs: Rectangle[], vars: Variable[],\r\n        rect: RectAccessors, minSep: number): Constraint[]\r\n    {\r\n        var i, n = rs.length;\r\n        var N = 2 * n;\r\n        console.assert(vars.length >= n);\r\n        var events = new Array<Event>(N);\r\n        for (i = 0; i < n; ++i) {\r\n            var r = rs[i];\r\n            var v = new Node(vars[i], r, rect.getCentre(r));\r\n            events[i] = new Event(true, v, rect.getOpen(r));\r\n            events[i + n] = new Event(false, v, rect.getClose(r));\r\n        }\r\n        events.sort(compareEvents);\r\n        var cs = new Array<Constraint>();\r\n        var scanline = makeRBTree();\r\n        for (i = 0; i < N; ++i) {\r\n            var e = events[i];\r\n            var v = e.v;\r\n            if (e.isOpen) {\r\n                scanline.insert(v);\r\n                rect.findNeighbours(v, scanline);\r\n            } else {\r\n                // close event\r\n                scanline.remove(v);\r\n                var makeConstraint = (l, r) => {\r\n                    var sep = (rect.getSize(l.r) + rect.getSize(r.r)) / 2 + minSep;\r\n                    cs.push(new Constraint(l.v, r.v, sep));\r\n                };\r\n                var visitNeighbours = (forward, reverse, mkcon) => {\r\n                    var u, it = v[forward].iterator();\r\n                    while ((u = it[forward]()) !== null) {\r\n                        mkcon(u, v);\r\n                        u[reverse].remove(v);\r\n                    }\r\n                };\r\n                visitNeighbours(\"prev\", \"next\", (u, v) => makeConstraint(u, v));\r\n                visitNeighbours(\"next\", \"prev\", (u, v) => makeConstraint(v, u));\r\n            }\r\n        }\r\n        console.assert(scanline.size === 0);\r\n        return cs;\r\n    }\r\n\r\n    function findXNeighbours(v: Node, scanline: RBTree<Node>): void {\r\n        var f = (forward, reverse) => {\r\n            var it = scanline.findIter(v);\r\n            var u;\r\n            while ((u = it[forward]()) !== null) {\r\n                var uovervX = u.r.overlapX(v.r);\r\n                if (uovervX <= 0 || uovervX <= u.r.overlapY(v.r)) {\r\n                    v[forward].insert(u);\r\n                    u[reverse].insert(v);\r\n                }\r\n                if (uovervX <= 0) {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        f(\"next\", \"prev\");\r\n        f(\"prev\", \"next\");\r\n    }\r\n\r\n    function findYNeighbours(v: Node, scanline: RBTree<Node>): void {\r\n        var f = (forward, reverse) => {\r\n            var u = scanline.findIter(v)[forward]();\r\n            if (u !== null && u.r.overlapX(v.r) > 0) {\r\n                v[forward].insert(u);\r\n                u[reverse].insert(v);\r\n            }\r\n        }\r\n        f(\"next\", \"prev\");\r\n        f(\"prev\", \"next\");\r\n    }\r\n\r\n    export function generateXConstraints(rs: Rectangle[], vars: Variable[]): Constraint[] {\r\n        return generateConstraints(rs, vars, xRect, 1e-6);\r\n    }\r\n\r\n    export function generateYConstraints(rs: Rectangle[], vars: Variable[]): Constraint[] {\r\n        return generateConstraints(rs, vars, yRect, 1e-6);\r\n    }\r\n\r\n    export function generateXGroupConstraints(root: ProjectionGroup): Constraint[] {\r\n        return generateGroupConstraints(root, xRect, 1e-6);\r\n    }\r\n\r\n    export function generateYGroupConstraints(root: ProjectionGroup): Constraint[] {\r\n        return generateGroupConstraints(root, yRect, 1e-6);\r\n    }\r\n\r\n    export function removeOverlaps(rs: Rectangle[]): void {\r\n        var vs = rs.map(r => new Variable(r.cx()));\r\n        var cs = generateXConstraints(rs, vs);\r\n        var solver = new Solver(vs, cs);\r\n        solver.solve();\r\n        vs.forEach((v, i) => rs[i].setXCentre(v.position()));\r\n        vs = rs.map(r=> new Variable(r.cy()));\r\n        cs = generateYConstraints(rs, vs);\r\n        solver = new Solver(vs, cs);\r\n        solver.solve();\r\n        vs.forEach((v, i) => rs[i].setYCentre(v.position()));\r\n    }\r\n\r\n    export interface GraphNode extends Leaf {\r\n        fixed: boolean;\r\n        fixedWeight?: number;\r\n        width: number;\r\n        height: number;\r\n        x: number;\r\n        y: number;\r\n        px: number;\r\n        py: number;\r\n    }\r\n\r\n    export class IndexedVariable extends Variable {\r\n        constructor(public index: number, w: number) {\r\n            super(0, w);\r\n        }\r\n    }\r\n\r\n    export class Projection {\r\n        private xConstraints: Constraint[];\r\n        private yConstraints: Constraint[];\r\n        private variables: Variable[];\r\n\r\n        constructor(private nodes: GraphNode[],\r\n            private groups: ProjectionGroup[],\r\n            private rootGroup: ProjectionGroup = null,\r\n            constraints: any[]= null,\r\n            private avoidOverlaps: boolean = false)\r\n        {\r\n            this.variables = nodes.map((v, i) => {\r\n                return v.variable = new IndexedVariable(i, 1);\r\n            });\r\n\r\n            if (constraints) this.createConstraints(constraints);\r\n\r\n            if (avoidOverlaps && rootGroup && typeof rootGroup.groups !== 'undefined') {\r\n                nodes.forEach(v => {\r\n\t\t\t\t\tif (!v.width || !v.height)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t//If undefined, default to nothing\r\n\t\t\t\t\t\tv.bounds = new Rectangle(v.x, v.x, v.y, v.y);\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}\r\n                    var w2 = v.width / 2, h2 = v.height / 2;\r\n                    v.bounds = new Rectangle(v.x - w2, v.x + w2, v.y - h2, v.y + h2);\r\n                });\r\n                computeGroupBounds(rootGroup);\r\n                var i = nodes.length;\r\n                groups.forEach(g => {\r\n                    this.variables[i] = g.minVar = new IndexedVariable(i++, typeof g.stiffness !== \"undefined\" ? g.stiffness : 0.01);\r\n                    this.variables[i] = g.maxVar = new IndexedVariable(i++, typeof g.stiffness !== \"undefined\" ? g.stiffness : 0.01);\r\n                });\r\n            }\r\n        }\r\n\r\n\r\n        private createSeparation(c: any) : Constraint {\r\n            return new Constraint(\r\n                this.nodes[c.left].variable,\r\n                this.nodes[c.right].variable,\r\n                c.gap,\r\n                typeof c.equality !== \"undefined\" ? c.equality : false);\r\n        }\r\n\r\n        // simple satisfaction of alignment constraints to ensure initial feasibility\r\n        private makeFeasible(c: any) {\r\n            if (!this.avoidOverlaps) return;\r\n            // sort nodes in constraint by position (along \"guideline\")\r\n            var axis = 'x', dim = 'width';\r\n            if (c.axis === 'x') axis = 'y', dim = 'height';\r\n            var vs: GraphNode[] = c.offsets.map(o => this.nodes[o.node]).sort((a, b) => a[axis] - b[axis]);\r\n            var p: GraphNode = null;\r\n            vs.forEach(v => {\r\n                // if two nodes overlap then shove the second one along\r\n                if (p) {\r\n                    let nextPos = p[axis] + p[dim];\r\n                    if (nextPos > v[axis]) {\r\n                        v[axis] = nextPos;\r\n                    }\r\n                }\r\n                p = v;\r\n            });\r\n        }\r\n\r\n        private createAlignment(c: any) {\r\n            var u = this.nodes[c.offsets[0].node].variable;\r\n            this.makeFeasible(c);\r\n            var cs = c.axis === 'x' ? this.xConstraints : this.yConstraints;\r\n            c.offsets.slice(1).forEach(o => {\r\n                var v = this.nodes[o.node].variable;\r\n                cs.push(new Constraint(u, v, o.offset, true));\r\n            });\r\n        }\r\n\r\n        private createConstraints(constraints: any[]) {\r\n            var isSep = c => typeof c.type === 'undefined' || c.type === 'separation';\r\n            this.xConstraints = constraints\r\n                .filter(c => c.axis === \"x\" && isSep(c))\r\n                .map(c => this.createSeparation(c));\r\n            this.yConstraints = constraints\r\n                .filter(c => c.axis === \"y\" && isSep(c))\r\n                .map(c => this.createSeparation(c));\r\n            constraints\r\n                .filter(c => c.type === 'alignment')\r\n                .forEach(c => this.createAlignment(c));\r\n        }\r\n\r\n        private setupVariablesAndBounds(x0: number[], y0: number[], desired: number[], getDesired: (v: GraphNode) => number) {\r\n            this.nodes.forEach((v, i) => {\r\n                if (v.fixed) {\r\n                    v.variable.weight = v.fixedWeight ? v.fixedWeight : 1000;\r\n                    desired[i] = getDesired(v);\r\n                } else {\r\n                    v.variable.weight = 1;\r\n                }\r\n                var w = (v.width || 0) / 2, h = (v.height || 0) / 2;\r\n                var ix = x0[i], iy = y0[i];\r\n                v.bounds = new Rectangle(ix - w, ix + w, iy - h, iy + h);\r\n            });\r\n        }\r\n\r\n        xProject(x0: number[], y0: number[], x: number[]) {\r\n            if (!this.rootGroup && !(this.avoidOverlaps || this.xConstraints)) return;\r\n            this.project(x0, y0, x0, x, v=> v.px, this.xConstraints, generateXGroupConstraints,\r\n                v => v.bounds.setXCentre(x[(<IndexedVariable>v.variable).index] = v.variable.position()),\r\n                g => {\r\n                    var xmin = x[(<IndexedVariable>g.minVar).index] = g.minVar.position();\r\n                    var xmax = x[(<IndexedVariable>g.maxVar).index] = g.maxVar.position();\r\n                    var p2 = g.padding / 2;\r\n                    g.bounds.x = xmin - p2;\r\n                    g.bounds.X = xmax + p2;\r\n                });\r\n        }\r\n\r\n        yProject(x0: number[], y0: number[], y: number[]) {\r\n            if (!this.rootGroup && !this.yConstraints) return;\r\n            this.project(x0, y0, y0, y, v=> v.py, this.yConstraints, generateYGroupConstraints,\r\n                v => v.bounds.setYCentre(y[(<IndexedVariable>v.variable).index] = v.variable.position()),\r\n                g => {\r\n                    var ymin = y[(<IndexedVariable>g.minVar).index] = g.minVar.position();\r\n                    var ymax = y[(<IndexedVariable>g.maxVar).index] = g.maxVar.position();\r\n                    var p2 = g.padding / 2;\r\n                    g.bounds.y = ymin - p2;;\r\n                    g.bounds.Y = ymax + p2;\r\n                });\r\n        }\r\n\r\n        projectFunctions(): { (x0: number[], y0: number[], r: number[]): void }[]{\r\n            return [\r\n                (x0, y0, x) => this.xProject(x0, y0, x),\r\n                (x0, y0, y) => this.yProject(x0, y0, y)\r\n            ];\r\n        }\r\n\r\n        private project(x0: number[], y0: number[], start: number[], desired: number[],\r\n            getDesired: (v: GraphNode) => number,\r\n            cs: Constraint[],\r\n            generateConstraints: (g: ProjectionGroup) => Constraint[],\r\n            updateNodeBounds: (v: GraphNode) => any,\r\n            updateGroupBounds: (g: ProjectionGroup) => any)\r\n        {\r\n            this.setupVariablesAndBounds(x0, y0, desired, getDesired);\r\n            if (this.rootGroup && this.avoidOverlaps) {\r\n                computeGroupBounds(this.rootGroup);\r\n                cs = cs.concat(generateConstraints(this.rootGroup));\r\n            }\r\n            this.solve(this.variables, cs, start, desired);\r\n            this.nodes.forEach(updateNodeBounds);\r\n            if (this.rootGroup && this.avoidOverlaps) {\r\n                this.groups.forEach(updateGroupBounds);\r\n                computeGroupBounds(this.rootGroup);\r\n            }\r\n        }\r\n\r\n        private solve(vs: Variable[], cs: Constraint[], starting: number[], desired: number[]) {\r\n            var solver = new Solver(vs, cs);\r\n            solver.setStartingPositions(starting);\r\n            solver.setDesiredPositions(desired);\r\n            solver.solve();\r\n        }\r\n    }\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}