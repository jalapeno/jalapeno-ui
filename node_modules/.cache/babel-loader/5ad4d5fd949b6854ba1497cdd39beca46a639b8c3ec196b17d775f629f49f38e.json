{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar powergraph = require(\"./powergraph\");\nvar linklengths_1 = require(\"./linklengths\");\nvar descent_1 = require(\"./descent\");\nvar rectangle_1 = require(\"./rectangle\");\nvar shortestpaths_1 = require(\"./shortestpaths\");\nvar geom_1 = require(\"./geom\");\nvar handledisconnected_1 = require(\"./handledisconnected\");\nvar EventType;\n(function (EventType) {\n  EventType[EventType[\"start\"] = 0] = \"start\";\n  EventType[EventType[\"tick\"] = 1] = \"tick\";\n  EventType[EventType[\"end\"] = 2] = \"end\";\n})(EventType = exports.EventType || (exports.EventType = {}));\n;\nfunction isGroup(g) {\n  return typeof g.leaves !== 'undefined' || typeof g.groups !== 'undefined';\n}\nvar Layout = function () {\n  function Layout() {\n    var _this = this;\n    this._canvasSize = [1, 1];\n    this._linkDistance = 20;\n    this._defaultNodeSize = 10;\n    this._linkLengthCalculator = null;\n    this._linkType = null;\n    this._avoidOverlaps = false;\n    this._handleDisconnected = true;\n    this._running = false;\n    this._nodes = [];\n    this._groups = [];\n    this._rootGroup = null;\n    this._links = [];\n    this._constraints = [];\n    this._distanceMatrix = null;\n    this._descent = null;\n    this._directedLinkConstraints = null;\n    this._threshold = 0.01;\n    this._visibilityGraph = null;\n    this._groupCompactness = 1e-6;\n    this.event = null;\n    this.linkAccessor = {\n      getSourceIndex: Layout.getSourceIndex,\n      getTargetIndex: Layout.getTargetIndex,\n      setLength: Layout.setLinkLength,\n      getType: function (l) {\n        return typeof _this._linkType === \"function\" ? _this._linkType(l) : 0;\n      }\n    };\n  }\n  Layout.prototype.on = function (e, listener) {\n    if (!this.event) this.event = {};\n    if (typeof e === 'string') {\n      this.event[EventType[e]] = listener;\n    } else {\n      this.event[e] = listener;\n    }\n    return this;\n  };\n  Layout.prototype.trigger = function (e) {\n    if (this.event && typeof this.event[e.type] !== 'undefined') {\n      this.event[e.type](e);\n    }\n  };\n  Layout.prototype.kick = function () {\n    while (!this.tick());\n  };\n  Layout.prototype.tick = function () {\n    if (this._alpha < this._threshold) {\n      this._running = false;\n      this.trigger({\n        type: EventType.end,\n        alpha: this._alpha = 0,\n        stress: this._lastStress\n      });\n      return true;\n    }\n    var n = this._nodes.length,\n      m = this._links.length;\n    var o, i;\n    this._descent.locks.clear();\n    for (i = 0; i < n; ++i) {\n      o = this._nodes[i];\n      if (o.fixed) {\n        if (typeof o.px === 'undefined' || typeof o.py === 'undefined') {\n          o.px = o.x;\n          o.py = o.y;\n        }\n        var p = [o.px, o.py];\n        this._descent.locks.add(i, p);\n      }\n    }\n    var s1 = this._descent.rungeKutta();\n    if (s1 === 0) {\n      this._alpha = 0;\n    } else if (typeof this._lastStress !== 'undefined') {\n      this._alpha = s1;\n    }\n    this._lastStress = s1;\n    this.updateNodePositions();\n    this.trigger({\n      type: EventType.tick,\n      alpha: this._alpha,\n      stress: this._lastStress\n    });\n    return false;\n  };\n  Layout.prototype.updateNodePositions = function () {\n    var x = this._descent.x[0],\n      y = this._descent.x[1];\n    var o,\n      i = this._nodes.length;\n    while (i--) {\n      o = this._nodes[i];\n      o.x = x[i];\n      o.y = y[i];\n    }\n  };\n  Layout.prototype.nodes = function (v) {\n    if (!v) {\n      if (this._nodes.length === 0 && this._links.length > 0) {\n        var n = 0;\n        this._links.forEach(function (l) {\n          n = Math.max(n, l.source, l.target);\n        });\n        this._nodes = new Array(++n);\n        for (var i = 0; i < n; ++i) {\n          this._nodes[i] = {};\n        }\n      }\n      return this._nodes;\n    }\n    this._nodes = v;\n    return this;\n  };\n  Layout.prototype.groups = function (x) {\n    var _this = this;\n    if (!x) return this._groups;\n    this._groups = x;\n    this._rootGroup = {};\n    this._groups.forEach(function (g) {\n      if (typeof g.padding === \"undefined\") g.padding = 1;\n      if (typeof g.leaves !== \"undefined\") {\n        g.leaves.forEach(function (v, i) {\n          if (typeof v === 'number') (g.leaves[i] = _this._nodes[v]).parent = g;\n        });\n      }\n      if (typeof g.groups !== \"undefined\") {\n        g.groups.forEach(function (gi, i) {\n          if (typeof gi === 'number') (g.groups[i] = _this._groups[gi]).parent = g;\n        });\n      }\n    });\n    this._rootGroup.leaves = this._nodes.filter(function (v) {\n      return typeof v.parent === 'undefined';\n    });\n    this._rootGroup.groups = this._groups.filter(function (g) {\n      return typeof g.parent === 'undefined';\n    });\n    return this;\n  };\n  Layout.prototype.powerGraphGroups = function (f) {\n    var g = powergraph.getGroups(this._nodes, this._links, this.linkAccessor, this._rootGroup);\n    this.groups(g.groups);\n    f(g);\n    return this;\n  };\n  Layout.prototype.avoidOverlaps = function (v) {\n    if (!arguments.length) return this._avoidOverlaps;\n    this._avoidOverlaps = v;\n    return this;\n  };\n  Layout.prototype.handleDisconnected = function (v) {\n    if (!arguments.length) return this._handleDisconnected;\n    this._handleDisconnected = v;\n    return this;\n  };\n  Layout.prototype.flowLayout = function (axis, minSeparation) {\n    if (!arguments.length) axis = 'y';\n    this._directedLinkConstraints = {\n      axis: axis,\n      getMinSeparation: typeof minSeparation === 'number' ? function () {\n        return minSeparation;\n      } : minSeparation\n    };\n    return this;\n  };\n  Layout.prototype.links = function (x) {\n    if (!arguments.length) return this._links;\n    this._links = x;\n    return this;\n  };\n  Layout.prototype.constraints = function (c) {\n    if (!arguments.length) return this._constraints;\n    this._constraints = c;\n    return this;\n  };\n  Layout.prototype.distanceMatrix = function (d) {\n    if (!arguments.length) return this._distanceMatrix;\n    this._distanceMatrix = d;\n    return this;\n  };\n  Layout.prototype.size = function (x) {\n    if (!x) return this._canvasSize;\n    this._canvasSize = x;\n    return this;\n  };\n  Layout.prototype.defaultNodeSize = function (x) {\n    if (!x) return this._defaultNodeSize;\n    this._defaultNodeSize = x;\n    return this;\n  };\n  Layout.prototype.groupCompactness = function (x) {\n    if (!x) return this._groupCompactness;\n    this._groupCompactness = x;\n    return this;\n  };\n  Layout.prototype.linkDistance = function (x) {\n    if (!x) {\n      return this._linkDistance;\n    }\n    this._linkDistance = typeof x === \"function\" ? x : +x;\n    this._linkLengthCalculator = null;\n    return this;\n  };\n  Layout.prototype.linkType = function (f) {\n    this._linkType = f;\n    return this;\n  };\n  Layout.prototype.convergenceThreshold = function (x) {\n    if (!x) return this._threshold;\n    this._threshold = typeof x === \"function\" ? x : +x;\n    return this;\n  };\n  Layout.prototype.alpha = function (x) {\n    if (!arguments.length) return this._alpha;else {\n      x = +x;\n      if (this._alpha) {\n        if (x > 0) this._alpha = x;else this._alpha = 0;\n      } else if (x > 0) {\n        if (!this._running) {\n          this._running = true;\n          this.trigger({\n            type: EventType.start,\n            alpha: this._alpha = x\n          });\n          this.kick();\n        }\n      }\n      return this;\n    }\n  };\n  Layout.prototype.getLinkLength = function (link) {\n    return typeof this._linkDistance === \"function\" ? +this._linkDistance(link) : this._linkDistance;\n  };\n  Layout.setLinkLength = function (link, length) {\n    link.length = length;\n  };\n  Layout.prototype.getLinkType = function (link) {\n    return typeof this._linkType === \"function\" ? this._linkType(link) : 0;\n  };\n  Layout.prototype.symmetricDiffLinkLengths = function (idealLength, w) {\n    var _this = this;\n    if (w === void 0) {\n      w = 1;\n    }\n    this.linkDistance(function (l) {\n      return idealLength * l.length;\n    });\n    this._linkLengthCalculator = function () {\n      return linklengths_1.symmetricDiffLinkLengths(_this._links, _this.linkAccessor, w);\n    };\n    return this;\n  };\n  Layout.prototype.jaccardLinkLengths = function (idealLength, w) {\n    var _this = this;\n    if (w === void 0) {\n      w = 1;\n    }\n    this.linkDistance(function (l) {\n      return idealLength * l.length;\n    });\n    this._linkLengthCalculator = function () {\n      return linklengths_1.jaccardLinkLengths(_this._links, _this.linkAccessor, w);\n    };\n    return this;\n  };\n  Layout.prototype.start = function (initialUnconstrainedIterations, initialUserConstraintIterations, initialAllConstraintsIterations, gridSnapIterations, keepRunning, centerGraph) {\n    var _this = this;\n    if (initialUnconstrainedIterations === void 0) {\n      initialUnconstrainedIterations = 0;\n    }\n    if (initialUserConstraintIterations === void 0) {\n      initialUserConstraintIterations = 0;\n    }\n    if (initialAllConstraintsIterations === void 0) {\n      initialAllConstraintsIterations = 0;\n    }\n    if (gridSnapIterations === void 0) {\n      gridSnapIterations = 0;\n    }\n    if (keepRunning === void 0) {\n      keepRunning = true;\n    }\n    if (centerGraph === void 0) {\n      centerGraph = true;\n    }\n    var i,\n      j,\n      n = this.nodes().length,\n      N = n + 2 * this._groups.length,\n      m = this._links.length,\n      w = this._canvasSize[0],\n      h = this._canvasSize[1];\n    var x = new Array(N),\n      y = new Array(N);\n    var G = null;\n    var ao = this._avoidOverlaps;\n    this._nodes.forEach(function (v, i) {\n      v.index = i;\n      if (typeof v.x === 'undefined') {\n        v.x = w / 2, v.y = h / 2;\n      }\n      x[i] = v.x, y[i] = v.y;\n    });\n    if (this._linkLengthCalculator) this._linkLengthCalculator();\n    var distances;\n    if (this._distanceMatrix) {\n      distances = this._distanceMatrix;\n    } else {\n      distances = new shortestpaths_1.Calculator(N, this._links, Layout.getSourceIndex, Layout.getTargetIndex, function (l) {\n        return _this.getLinkLength(l);\n      }).DistanceMatrix();\n      G = descent_1.Descent.createSquareMatrix(N, function () {\n        return 2;\n      });\n      this._links.forEach(function (l) {\n        if (typeof l.source == \"number\") l.source = _this._nodes[l.source];\n        if (typeof l.target == \"number\") l.target = _this._nodes[l.target];\n      });\n      this._links.forEach(function (e) {\n        var u = Layout.getSourceIndex(e),\n          v = Layout.getTargetIndex(e);\n        G[u][v] = G[v][u] = e.weight || 1;\n      });\n    }\n    var D = descent_1.Descent.createSquareMatrix(N, function (i, j) {\n      return distances[i][j];\n    });\n    if (this._rootGroup && typeof this._rootGroup.groups !== 'undefined') {\n      var i = n;\n      var addAttraction = function (i, j, strength, idealDistance) {\n        G[i][j] = G[j][i] = strength;\n        D[i][j] = D[j][i] = idealDistance;\n      };\n      this._groups.forEach(function (g) {\n        addAttraction(i, i + 1, _this._groupCompactness, 0.1);\n        x[i] = 0, y[i++] = 0;\n        x[i] = 0, y[i++] = 0;\n      });\n    } else this._rootGroup = {\n      leaves: this._nodes,\n      groups: []\n    };\n    var curConstraints = this._constraints || [];\n    if (this._directedLinkConstraints) {\n      this.linkAccessor.getMinSeparation = this._directedLinkConstraints.getMinSeparation;\n      curConstraints = curConstraints.concat(linklengths_1.generateDirectedEdgeConstraints(n, this._links, this._directedLinkConstraints.axis, this.linkAccessor));\n    }\n    this.avoidOverlaps(false);\n    this._descent = new descent_1.Descent([x, y], D);\n    this._descent.locks.clear();\n    for (var i = 0; i < n; ++i) {\n      var o = this._nodes[i];\n      if (o.fixed) {\n        o.px = o.x;\n        o.py = o.y;\n        var p = [o.x, o.y];\n        this._descent.locks.add(i, p);\n      }\n    }\n    this._descent.threshold = this._threshold;\n    this.initialLayout(initialUnconstrainedIterations, x, y);\n    if (curConstraints.length > 0) this._descent.project = new rectangle_1.Projection(this._nodes, this._groups, this._rootGroup, curConstraints).projectFunctions();\n    this._descent.run(initialUserConstraintIterations);\n    this.separateOverlappingComponents(w, h, centerGraph);\n    this.avoidOverlaps(ao);\n    if (ao) {\n      this._nodes.forEach(function (v, i) {\n        v.x = x[i], v.y = y[i];\n      });\n      this._descent.project = new rectangle_1.Projection(this._nodes, this._groups, this._rootGroup, curConstraints, true).projectFunctions();\n      this._nodes.forEach(function (v, i) {\n        x[i] = v.x, y[i] = v.y;\n      });\n    }\n    this._descent.G = G;\n    this._descent.run(initialAllConstraintsIterations);\n    if (gridSnapIterations) {\n      this._descent.snapStrength = 1000;\n      this._descent.snapGridSize = this._nodes[0].width;\n      this._descent.numGridSnapNodes = n;\n      this._descent.scaleSnapByMaxH = n != N;\n      var G0 = descent_1.Descent.createSquareMatrix(N, function (i, j) {\n        if (i >= n || j >= n) return G[i][j];\n        return 0;\n      });\n      this._descent.G = G0;\n      this._descent.run(gridSnapIterations);\n    }\n    this.updateNodePositions();\n    this.separateOverlappingComponents(w, h, centerGraph);\n    return keepRunning ? this.resume() : this;\n  };\n  Layout.prototype.initialLayout = function (iterations, x, y) {\n    if (this._groups.length > 0 && iterations > 0) {\n      var n = this._nodes.length;\n      var edges = this._links.map(function (e) {\n        return {\n          source: e.source.index,\n          target: e.target.index\n        };\n      });\n      var vs = this._nodes.map(function (v) {\n        return {\n          index: v.index\n        };\n      });\n      this._groups.forEach(function (g, i) {\n        vs.push({\n          index: g.index = n + i\n        });\n      });\n      this._groups.forEach(function (g, i) {\n        if (typeof g.leaves !== 'undefined') g.leaves.forEach(function (v) {\n          return edges.push({\n            source: g.index,\n            target: v.index\n          });\n        });\n        if (typeof g.groups !== 'undefined') g.groups.forEach(function (gg) {\n          return edges.push({\n            source: g.index,\n            target: gg.index\n          });\n        });\n      });\n      new Layout().size(this.size()).nodes(vs).links(edges).avoidOverlaps(false).linkDistance(this.linkDistance()).symmetricDiffLinkLengths(5).convergenceThreshold(1e-4).start(iterations, 0, 0, 0, false);\n      this._nodes.forEach(function (v) {\n        x[v.index] = vs[v.index].x;\n        y[v.index] = vs[v.index].y;\n      });\n    } else {\n      this._descent.run(iterations);\n    }\n  };\n  Layout.prototype.separateOverlappingComponents = function (width, height, centerGraph) {\n    var _this = this;\n    if (centerGraph === void 0) {\n      centerGraph = true;\n    }\n    if (!this._distanceMatrix && this._handleDisconnected) {\n      var x_1 = this._descent.x[0],\n        y_1 = this._descent.x[1];\n      this._nodes.forEach(function (v, i) {\n        v.x = x_1[i], v.y = y_1[i];\n      });\n      var graphs = handledisconnected_1.separateGraphs(this._nodes, this._links);\n      handledisconnected_1.applyPacking(graphs, width, height, this._defaultNodeSize, 1, centerGraph);\n      this._nodes.forEach(function (v, i) {\n        _this._descent.x[0][i] = v.x, _this._descent.x[1][i] = v.y;\n        if (v.bounds) {\n          v.bounds.setXCentre(v.x);\n          v.bounds.setYCentre(v.y);\n        }\n      });\n    }\n  };\n  Layout.prototype.resume = function () {\n    return this.alpha(0.1);\n  };\n  Layout.prototype.stop = function () {\n    return this.alpha(0);\n  };\n  Layout.prototype.prepareEdgeRouting = function (nodeMargin) {\n    if (nodeMargin === void 0) {\n      nodeMargin = 0;\n    }\n    this._visibilityGraph = new geom_1.TangentVisibilityGraph(this._nodes.map(function (v) {\n      return v.bounds.inflate(-nodeMargin).vertices();\n    }));\n  };\n  Layout.prototype.routeEdge = function (edge, ah, draw) {\n    if (ah === void 0) {\n      ah = 5;\n    }\n    var lineData = [];\n    var vg2 = new geom_1.TangentVisibilityGraph(this._visibilityGraph.P, {\n        V: this._visibilityGraph.V,\n        E: this._visibilityGraph.E\n      }),\n      port1 = {\n        x: edge.source.x,\n        y: edge.source.y\n      },\n      port2 = {\n        x: edge.target.x,\n        y: edge.target.y\n      },\n      start = vg2.addPoint(port1, edge.source.index),\n      end = vg2.addPoint(port2, edge.target.index);\n    vg2.addEdgeIfVisible(port1, port2, edge.source.index, edge.target.index);\n    if (typeof draw !== 'undefined') {\n      draw(vg2);\n    }\n    var sourceInd = function (e) {\n        return e.source.id;\n      },\n      targetInd = function (e) {\n        return e.target.id;\n      },\n      length = function (e) {\n        return e.length();\n      },\n      spCalc = new shortestpaths_1.Calculator(vg2.V.length, vg2.E, sourceInd, targetInd, length),\n      shortestPath = spCalc.PathFromNodeToNode(start.id, end.id);\n    if (shortestPath.length === 1 || shortestPath.length === vg2.V.length) {\n      var route = rectangle_1.makeEdgeBetween(edge.source.innerBounds, edge.target.innerBounds, ah);\n      lineData = [route.sourceIntersection, route.arrowStart];\n    } else {\n      var n = shortestPath.length - 2,\n        p = vg2.V[shortestPath[n]].p,\n        q = vg2.V[shortestPath[0]].p,\n        lineData = [edge.source.innerBounds.rayIntersection(p.x, p.y)];\n      for (var i = n; i >= 0; --i) lineData.push(vg2.V[shortestPath[i]].p);\n      lineData.push(rectangle_1.makeEdgeTo(q, edge.target.innerBounds, ah));\n    }\n    return lineData;\n  };\n  Layout.getSourceIndex = function (e) {\n    return typeof e.source === 'number' ? e.source : e.source.index;\n  };\n  Layout.getTargetIndex = function (e) {\n    return typeof e.target === 'number' ? e.target : e.target.index;\n  };\n  Layout.linkId = function (e) {\n    return Layout.getSourceIndex(e) + \"-\" + Layout.getTargetIndex(e);\n  };\n  Layout.dragStart = function (d) {\n    if (isGroup(d)) {\n      Layout.storeOffset(d, Layout.dragOrigin(d));\n    } else {\n      Layout.stopNode(d);\n      d.fixed |= 2;\n    }\n  };\n  Layout.stopNode = function (v) {\n    v.px = v.x;\n    v.py = v.y;\n  };\n  Layout.storeOffset = function (d, origin) {\n    if (typeof d.leaves !== 'undefined') {\n      d.leaves.forEach(function (v) {\n        v.fixed |= 2;\n        Layout.stopNode(v);\n        v._dragGroupOffsetX = v.x - origin.x;\n        v._dragGroupOffsetY = v.y - origin.y;\n      });\n    }\n    if (typeof d.groups !== 'undefined') {\n      d.groups.forEach(function (g) {\n        return Layout.storeOffset(g, origin);\n      });\n    }\n  };\n  Layout.dragOrigin = function (d) {\n    if (isGroup(d)) {\n      return {\n        x: d.bounds.cx(),\n        y: d.bounds.cy()\n      };\n    } else {\n      return d;\n    }\n  };\n  Layout.drag = function (d, position) {\n    if (isGroup(d)) {\n      if (typeof d.leaves !== 'undefined') {\n        d.leaves.forEach(function (v) {\n          d.bounds.setXCentre(position.x);\n          d.bounds.setYCentre(position.y);\n          v.px = v._dragGroupOffsetX + position.x;\n          v.py = v._dragGroupOffsetY + position.y;\n        });\n      }\n      if (typeof d.groups !== 'undefined') {\n        d.groups.forEach(function (g) {\n          return Layout.drag(g, position);\n        });\n      }\n    } else {\n      d.px = position.x;\n      d.py = position.y;\n    }\n  };\n  Layout.dragEnd = function (d) {\n    if (isGroup(d)) {\n      if (typeof d.leaves !== 'undefined') {\n        d.leaves.forEach(function (v) {\n          Layout.dragEnd(v);\n          delete v._dragGroupOffsetX;\n          delete v._dragGroupOffsetY;\n        });\n      }\n      if (typeof d.groups !== 'undefined') {\n        d.groups.forEach(Layout.dragEnd);\n      }\n    } else {\n      d.fixed &= ~6;\n    }\n  };\n  Layout.mouseOver = function (d) {\n    d.fixed |= 4;\n    d.px = d.x, d.py = d.y;\n  };\n  Layout.mouseOut = function (d) {\n    d.fixed &= ~4;\n  };\n  return Layout;\n}();\nexports.Layout = Layout;","map":{"version":3,"names":["powergraph","require","linklengths_1","descent_1","rectangle_1","shortestpaths_1","geom_1","handledisconnected_1","EventType","exports","isGroup","g","leaves","groups","Layout","_this","_canvasSize","_linkDistance","_defaultNodeSize","_linkLengthCalculator","_linkType","_avoidOverlaps","_handleDisconnected","_running","_nodes","_groups","_rootGroup","_links","_constraints","_distanceMatrix","_descent","_directedLinkConstraints","_threshold","_visibilityGraph","_groupCompactness","event","linkAccessor","getSourceIndex","getTargetIndex","setLength","setLinkLength","getType","l","prototype","on","e","listener","trigger","type","kick","tick","_alpha","end","alpha","stress","_lastStress","n","length","m","o","i","locks","clear","fixed","px","py","x","y","p","add","s1","rungeKutta","updateNodePositions","nodes","v","forEach","Math","max","source","target","Array","padding","parent","gi","filter","powerGraphGroups","f","getGroups","avoidOverlaps","arguments","handleDisconnected","flowLayout","axis","minSeparation","getMinSeparation","links","constraints","c","distanceMatrix","d","size","defaultNodeSize","groupCompactness","linkDistance","linkType","convergenceThreshold","start","getLinkLength","link","getLinkType","symmetricDiffLinkLengths","idealLength","w","jaccardLinkLengths","initialUnconstrainedIterations","initialUserConstraintIterations","initialAllConstraintsIterations","gridSnapIterations","keepRunning","centerGraph","j","N","h","G","ao","index","distances","Calculator","DistanceMatrix","Descent","createSquareMatrix","u","weight","D","addAttraction","strength","idealDistance","curConstraints","concat","generateDirectedEdgeConstraints","threshold","initialLayout","project","Projection","projectFunctions","run","separateOverlappingComponents","snapStrength","snapGridSize","width","numGridSnapNodes","scaleSnapByMaxH","G0","resume","iterations","edges","map","vs","push","gg","height","x_1","y_1","graphs","separateGraphs","applyPacking","bounds","setXCentre","setYCentre","stop","prepareEdgeRouting","nodeMargin","TangentVisibilityGraph","inflate","vertices","routeEdge","edge","ah","draw","lineData","vg2","P","V","E","port1","port2","addPoint","addEdgeIfVisible","sourceInd","id","targetInd","spCalc","shortestPath","PathFromNodeToNode","route","makeEdgeBetween","innerBounds","sourceIntersection","arrowStart","q","rayIntersection","makeEdgeTo","linkId","dragStart","storeOffset","dragOrigin","stopNode","origin","_dragGroupOffsetX","_dragGroupOffsetY","cx","cy","drag","position","dragEnd","mouseOver","mouseOut"],"sources":["/Users/brucemcdougall/go/jalapeno-github/jalapeno-ui/node_modules/webcola/WebCola/src/layout.ts"],"sourcesContent":["import * as powergraph from './powergraph'\r\nimport {LinkLengthAccessor, symmetricDiffLinkLengths, jaccardLinkLengths, generateDirectedEdgeConstraints} from './linklengths'\r\nimport {Descent} from './descent'\r\nimport {Rectangle, Projection, makeEdgeTo, makeEdgeBetween} from './rectangle'\r\nimport {Calculator} from './shortestpaths'\r\nimport {TangentVisibilityGraph, TVGPoint} from './geom'\r\nimport {separateGraphs, applyPacking} from './handledisconnected'\r\n    /**\r\n     * The layout process fires three events:\r\n     *  - start: layout iterations started\r\n     *  - tick: fired once per iteration, listen to this to animate\r\n     *  - end: layout converged, you might like to zoom-to-fit or something at notification of this event\r\n     */\r\n    export enum EventType { start, tick, end };\r\n    export interface Event {\r\n        type: EventType;\r\n        alpha: number;\r\n        stress?: number;\r\n        listener?: () => void;\r\n    }\r\n    export interface InputNode {\r\n        /**\r\n         * index in nodes array, this is initialized by Layout.start()\r\n         */\r\n        index?: number;\r\n        /**\r\n         * x and y will be computed by layout as the Node's centroid\r\n         */\r\n        x?: number;\r\n        /**\r\n         * x and y will be computed by layout as the Node's centroid\r\n         */\r\n        y?: number;\r\n        /**\r\n         * specify a width and height of the node's bounding box if you turn on avoidOverlaps\r\n         */\r\n        width?: number;\r\n        /**\r\n         * specify a width and height of the node's bounding box if you turn on avoidOverlaps\r\n         */\r\n        height?: number;\r\n        /**\r\n         * selective bit mask.  !=0 means layout will not move.\r\n         */\r\n        fixed?: number;\r\n    }\r\n    export interface Node extends InputNode {\r\n      // Client-passed node may be missing these properties, which will be set\r\n      // upon ingestion\r\n      x: number;\r\n      y: number;\r\n    }\r\n\r\n    export interface Group {\r\n        bounds?: Rectangle;\r\n        leaves?: Node[];\r\n        groups?: Group[];\r\n        padding: number;\r\n    }\r\n\r\n    function isGroup(g: any): g is Group {\r\n        return typeof g.leaves !== 'undefined' || typeof g.groups !== 'undefined';\r\n    }\r\n\r\n    export interface Link<NodeRefType> {\r\n        source: NodeRefType;\r\n        target: NodeRefType;\r\n\r\n        // ideal length the layout should try to achieve for this link\r\n        length?: number;\r\n\r\n        // how hard we should try to satisfy this link's ideal length\r\n        // must be in the range: 0 < weight <= 1\r\n        // if unspecified 1 is the default\r\n        weight?: number;\r\n    }\r\n\r\n    export type LinkNumericPropertyAccessor = (t: Link<Node | number>) => number;\r\n\r\n    export interface LinkLengthTypeAccessor extends LinkLengthAccessor<Link<Node | number>> {\r\n        getType: LinkNumericPropertyAccessor;\r\n    }\r\n    /**\r\n     * Main interface to cola layout.\r\n     * @class Layout\r\n     */\r\n    export class Layout {\r\n        private _canvasSize = [1, 1];\r\n        private _linkDistance: number | LinkNumericPropertyAccessor = 20;\r\n        private _defaultNodeSize: number = 10;\r\n        private _linkLengthCalculator = null;\r\n        private _linkType = null;\r\n        private _avoidOverlaps = false;\r\n        private _handleDisconnected = true;\r\n        private _alpha;\r\n        private _lastStress;\r\n        private _running = false;\r\n        private _nodes = [];\r\n        private _groups = [];\r\n        private _rootGroup = null;\r\n        private _links: Link<Node | number>[] = [];\r\n        private _constraints = [];\r\n        private _distanceMatrix = null;\r\n        private _descent: Descent = null;\r\n        private _directedLinkConstraints = null;\r\n        private _threshold = 0.01;\r\n        private _visibilityGraph = null;\r\n        private _groupCompactness = 1e-6;\r\n\r\n        // sub-class and override this property to replace with a more sophisticated eventing mechanism\r\n        protected event = null;\r\n\r\n        // subscribe a listener to an event\r\n        // sub-class and override this method to replace with a more sophisticated eventing mechanism\r\n        public on(e: EventType | string, listener: (event?: Event) => void): this {\r\n            // override me!\r\n            if (!this.event) this.event = {};\r\n            if (typeof e === 'string') {\r\n                this.event[EventType[e]] = listener;\r\n            } else {\r\n                this.event[e] = listener;\r\n            }\r\n            return this;\r\n        }\r\n\r\n        // a function that is notified of events like \"tick\"\r\n        // sub-classes can override this method to replace with a more sophisticated eventing mechanism\r\n        protected trigger(e: Event) {\r\n            if (this.event && typeof this.event[e.type] !== 'undefined') {\r\n                this.event[e.type](e);\r\n            }\r\n        }\r\n\r\n        // a function that kicks off the iteration tick loop\r\n        // it calls tick() repeatedly until tick returns true (is converged)\r\n        // subclass and override it with something fancier (e.g. dispatch tick on a timer)\r\n        protected kick(): void {\r\n            while (!this.tick());\r\n        }\r\n\r\n        /**\r\n         * iterate the layout.  Returns true when layout converged.\r\n         */\r\n        protected tick(): boolean {\r\n            if (this._alpha < this._threshold) {\r\n                this._running = false;\r\n                this.trigger({ type: EventType.end, alpha: this._alpha = 0, stress: this._lastStress });\r\n                return true;\r\n            }\r\n            const n = this._nodes.length,\r\n                  m = this._links.length;\r\n            let o, i;\r\n\r\n            this._descent.locks.clear();\r\n            for (i = 0; i < n; ++i) {\r\n                o = this._nodes[i];\r\n                if (o.fixed) {\r\n                    if (typeof o.px === 'undefined' || typeof o.py === 'undefined') {\r\n                        o.px = o.x;\r\n                        o.py = o.y;\r\n                    }\r\n                    var p = [o.px, o.py];\r\n                    this._descent.locks.add(i, p);\r\n                }\r\n            }\r\n\r\n            let s1 = this._descent.rungeKutta();\r\n            //var s1 = descent.reduceStress();\r\n            if (s1 === 0) {\r\n                this._alpha = 0;\r\n            } else if (typeof this._lastStress !== 'undefined') {\r\n                this._alpha = s1; //Math.abs(Math.abs(this._lastStress / s1) - 1);\r\n            }\r\n            this._lastStress = s1;\r\n\r\n            this.updateNodePositions();\r\n\r\n            this.trigger({ type: EventType.tick, alpha: this._alpha, stress: this._lastStress });\r\n            return false;\r\n        }\r\n\r\n        // copy positions out of descent instance into each of the nodes' center coords\r\n        private updateNodePositions(): void {\r\n            const x = this._descent.x[0], y = this._descent.x[1];\r\n            let o, i = this._nodes.length;\r\n            while (i--) {\r\n                o = this._nodes[i];\r\n                o.x = x[i];\r\n                o.y = y[i];\r\n            }\r\n        }\r\n\r\n        /**\r\n         * the list of nodes.\r\n         * If nodes has not been set, but links has, then we instantiate a nodes list here, of the correct size,\r\n         * before returning it.\r\n         * @property nodes {Array}\r\n         * @default empty list\r\n         */\r\n        nodes(): Array<Node>\r\n        nodes(v: Array<InputNode>): this\r\n        nodes(v?: any): any {\r\n            if (!v) {\r\n                if (this._nodes.length === 0 && this._links.length > 0) {\r\n                    // if we have links but no nodes, create the nodes array now with empty objects for the links to point at.\r\n                    // in this case the links are expected to be numeric indices for nodes in the range 0..n-1 where n is the number of nodes\r\n                    var n = 0;\r\n                    this._links.forEach(function (l) {\r\n                        n = Math.max(n, <number>l.source, <number>l.target);\r\n                    });\r\n                    this._nodes = new Array(++n);\r\n                    for (var i = 0; i < n; ++i) {\r\n                        this._nodes[i] = {};\r\n                    }\r\n                }\r\n                return this._nodes;\r\n            }\r\n            this._nodes = v;\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * a list of hierarchical groups defined over nodes\r\n         * @property groups {Array}\r\n         * @default empty list\r\n         */\r\n        groups(): Array<Group>\r\n        groups(x: Array<Group>): this\r\n        groups(x?: Array<Group>): any {\r\n            if (!x) return this._groups;\r\n            this._groups = x;\r\n            this._rootGroup = {};\r\n            this._groups.forEach(g => {\r\n                if (typeof g.padding === \"undefined\")\r\n                    g.padding = 1;\r\n                if (typeof g.leaves !== \"undefined\") {\r\n                    g.leaves.forEach((v, i) => {\r\n                        if (typeof v === 'number')\r\n                            (g.leaves[i] = this._nodes[v]).parent = g\r\n                    });\r\n                }\r\n                if (typeof g.groups !== \"undefined\") {\r\n                    g.groups.forEach((gi, i) => {\r\n                        if (typeof gi === 'number')\r\n                            (g.groups[i] = this._groups[gi]).parent = g\r\n                    });\r\n                }\r\n            });\r\n            this._rootGroup.leaves = this._nodes.filter(v => typeof v.parent === 'undefined');\r\n            this._rootGroup.groups = this._groups.filter(g => typeof g.parent === 'undefined');\r\n            return this;\r\n        }\r\n\r\n        powerGraphGroups(f: Function): this {\r\n            var g = powergraph.getGroups(this._nodes, this._links, this.linkAccessor, this._rootGroup);\r\n            this.groups(g.groups);\r\n            f(g);\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * if true, the layout will not permit overlaps of the node bounding boxes (defined by the width and height properties on nodes)\r\n         * @property avoidOverlaps\r\n         * @type bool\r\n         * @default false\r\n         */\r\n        avoidOverlaps(): boolean\r\n        avoidOverlaps(v: boolean): this\r\n        avoidOverlaps(v?: boolean): any {\r\n            if (!arguments.length) return this._avoidOverlaps;\r\n            this._avoidOverlaps = v;\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * if true, the final step of the start method will be to nicely pack connected components of the graph.\r\n         * works best if start() is called with a reasonable number of iterations specified and\r\n         * each node has a bounding box (defined by the width and height properties on nodes).\r\n         * @property handleDisconnected\r\n         * @type bool\r\n         * @default true\r\n         */\r\n        handleDisconnected(): boolean\r\n        handleDisconnected(v: boolean): this\r\n        handleDisconnected(v?: boolean): any {\r\n            if (!arguments.length) return this._handleDisconnected;\r\n            this._handleDisconnected = v;\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * causes constraints to be generated such that directed graphs are laid out either from left-to-right or top-to-bottom.\r\n         * a separation constraint is generated in the selected axis for each edge that is not involved in a cycle (part of a strongly connected component)\r\n         * @param axis {string} 'x' for left-to-right, 'y' for top-to-bottom\r\n         * @param minSeparation {number|link=>number} either a number specifying a minimum spacing required across all links or a function to return the minimum spacing for each link\r\n         */\r\n        flowLayout(axis: string, minSeparation: number|((t: any)=>number)): this {\r\n            if (!arguments.length) axis = 'y';\r\n            this._directedLinkConstraints = {\r\n                axis: axis,\r\n                getMinSeparation: typeof minSeparation === 'number' ? function () { return minSeparation } : minSeparation\r\n            };\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * links defined as source, target pairs over nodes\r\n         * @property links {array}\r\n         * @default empty list\r\n         */\r\n        links(): Array<Link<Node|number>>\r\n        links(x: Array<Link<Node|number>>): this\r\n        links(x?: Array<Link<Node|number>>): any {\r\n            if (!arguments.length) return this._links;\r\n            this._links = x;\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * list of constraints of various types\r\n         * @property constraints\r\n         * @type {array}\r\n         * @default empty list\r\n         */\r\n        constraints(): Array<any>\r\n        constraints(c: Array<any>): this\r\n        constraints(c?: Array<any>): any {\r\n            if (!arguments.length) return this._constraints;\r\n            this._constraints = c;\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Matrix of ideal distances between all pairs of nodes.\r\n         * If unspecified, the ideal distances for pairs of nodes will be based on the shortest path distance between them.\r\n         * @property distanceMatrix\r\n         * @type {Array of Array of Number}\r\n         * @default null\r\n         */\r\n        distanceMatrix(): Array<Array<number>>\r\n        distanceMatrix(d: Array<Array<number>>): this\r\n        distanceMatrix(d?: any): any {\r\n            if (!arguments.length) return this._distanceMatrix;\r\n            this._distanceMatrix = d;\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Size of the layout canvas dimensions [x,y]. Currently only used to determine the midpoint which is taken as the starting position\r\n         * for nodes with no preassigned x and y.\r\n         * @property size\r\n         * @type {Array of Number}\r\n         */\r\n        size(): Array<number>\r\n        size(x: Array<number>): this\r\n        size(x?: Array<number>): any {\r\n            if (!x) return this._canvasSize;\r\n            this._canvasSize = x;\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Default size (assume nodes are square so both width and height) to use in packing if node width/height are not specified.\r\n         * @property defaultNodeSize\r\n         * @type {Number}\r\n         */\r\n        defaultNodeSize(): number\r\n        defaultNodeSize(x: number): this\r\n        defaultNodeSize(x?: any): any {\r\n            if (!x) return this._defaultNodeSize;\r\n            this._defaultNodeSize = x;\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * The strength of attraction between the group boundaries to each other.\r\n         * @property defaultNodeSize\r\n         * @type {Number}\r\n         */\r\n        groupCompactness(): number\r\n        groupCompactness(x: number): this\r\n        groupCompactness(x?: any): any {\r\n            if (!x) return this._groupCompactness;\r\n            this._groupCompactness = x;\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * links have an ideal distance, The automatic layout will compute layout that tries to keep links (AKA edges) as close as possible to this length.\r\n         */\r\n        linkDistance(): number\r\n        linkDistance(): LinkNumericPropertyAccessor\r\n        linkDistance(x: number): this\r\n        linkDistance(x: LinkNumericPropertyAccessor): this\r\n        linkDistance(x?: any): any {\r\n            if (!x) {\r\n                return this._linkDistance;\r\n            }\r\n            this._linkDistance = typeof x === \"function\" ? x : +x;\r\n            this._linkLengthCalculator = null;\r\n            return this;\r\n        }\r\n\r\n        linkType(f: Function | number): this {\r\n            this._linkType = f;\r\n            return this;\r\n        }\r\n\r\n        convergenceThreshold(): number\r\n        convergenceThreshold(x: number): this\r\n        convergenceThreshold(x?: number): any {\r\n            if (!x) return this._threshold;\r\n            this._threshold = typeof x === \"function\" ? x : +x;\r\n            return this;\r\n        }\r\n\r\n        alpha(): number\r\n        alpha(x: number): this\r\n        alpha(x?: number): any {\r\n            if (!arguments.length) return this._alpha;\r\n            else {\r\n                x = +x;\r\n                if (this._alpha) { // if we're already running\r\n                    if (x > 0) this._alpha = x; // we might keep it hot\r\n                    else this._alpha = 0; // or, next tick will dispatch \"end\"\r\n                } else if (x > 0) { // otherwise, fire it up!\r\n                    if (!this._running) {\r\n                        this._running = true;\r\n                        this.trigger({ type: EventType.start, alpha: this._alpha = x});\r\n                        this.kick();\r\n                    }\r\n                }\r\n                return this;\r\n            }\r\n        }\r\n\r\n        getLinkLength(link: Link<Node | number>): number {\r\n            return typeof this._linkDistance === \"function\" ? +((<LinkNumericPropertyAccessor>this._linkDistance)(link)) : <number>this._linkDistance;\r\n        }\r\n\r\n        static setLinkLength(link: Link<Node|number>, length: number) {\r\n            link.length = length;\r\n        }\r\n\r\n        getLinkType(link: Link<Node | number>): number {\r\n            return typeof this._linkType === \"function\" ? this._linkType(link) : 0;\r\n        }\r\n\r\n        linkAccessor: LinkLengthTypeAccessor = {\r\n            getSourceIndex: Layout.getSourceIndex,\r\n            getTargetIndex: Layout.getTargetIndex,\r\n            setLength: Layout.setLinkLength,\r\n            getType: l => typeof this._linkType === \"function\" ? this._linkType(l) : 0\r\n        };\r\n\r\n        /**\r\n         * compute an ideal length for each link based on the graph structure around that link.\r\n         * you can use this (for example) to create extra space around hub-nodes in dense graphs.\r\n         * In particular this calculation is based on the \"symmetric difference\" in the neighbour sets of the source and target:\r\n         * i.e. if neighbours of source is a and neighbours of target are b then calculation is: sqrt(|a union b| - |a intersection b|)\r\n         * Actual computation based on inspection of link structure occurs in start(), so links themselves\r\n         * don't have to have been assigned before invoking this function.\r\n         * @param {number} [idealLength] the base length for an edge when its source and start have no other common neighbours (e.g. 40)\r\n         * @param {number} [w] a multiplier for the effect of the length adjustment (e.g. 0.7)\r\n         */\r\n        symmetricDiffLinkLengths(idealLength: number, w: number = 1): this {\r\n            this.linkDistance(l => idealLength * l.length);\r\n            this._linkLengthCalculator = () => symmetricDiffLinkLengths(this._links, this.linkAccessor, w);\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * compute an ideal length for each link based on the graph structure around that link.\r\n         * you can use this (for example) to create extra space around hub-nodes in dense graphs.\r\n         * In particular this calculation is based on the \"symmetric difference\" in the neighbour sets of the source and target:\r\n         * i.e. if neighbours of source is a and neighbours of target are b then calculation is: |a intersection b|/|a union b|\r\n         * Actual computation based on inspection of link structure occurs in start(), so links themselves\r\n         * don't have to have been assigned before invoking this function.\r\n         * @param {number} [idealLength] the base length for an edge when its source and start have no other common neighbours (e.g. 40)\r\n         * @param {number} [w] a multiplier for the effect of the length adjustment (e.g. 0.7)\r\n         */\r\n        jaccardLinkLengths(idealLength: number, w: number = 1): this {\r\n            this.linkDistance(l => idealLength * l.length);\r\n            this._linkLengthCalculator = () => jaccardLinkLengths(this._links, this.linkAccessor, w);\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * start the layout process\r\n         * @method start\r\n         * @param {number} [initialUnconstrainedIterations=0] unconstrained initial layout iterations\r\n         * @param {number} [initialUserConstraintIterations=0] initial layout iterations with user-specified constraints\r\n         * @param {number} [initialAllConstraintsIterations=0] initial layout iterations with all constraints including non-overlap\r\n         * @param {number} [gridSnapIterations=0] iterations of \"grid snap\", which pulls nodes towards grid cell centers - grid of size node[0].width - only really makes sense if all nodes have the same width and height\r\n         * @param [keepRunning=true] keep iterating asynchronously via the tick method\r\n         * @param [centerGraph=true] Center graph on restart\r\n         */\r\n        start(\r\n            initialUnconstrainedIterations: number = 0,\r\n            initialUserConstraintIterations: number = 0,\r\n            initialAllConstraintsIterations: number = 0,\r\n            gridSnapIterations: number = 0,\r\n            keepRunning = true,\r\n            centerGraph = true,\r\n        ): this {\r\n            var i: number,\r\n                j: number,\r\n                n = (<Array<any>>this.nodes()).length,\r\n                N = n + 2 * this._groups.length,\r\n                m = this._links.length,\r\n                w = this._canvasSize[0],\r\n                h = this._canvasSize[1];\r\n\r\n            var x = new Array(N), y = new Array(N);\r\n\r\n            var G = null;\r\n\r\n            var ao = this._avoidOverlaps;\r\n\r\n            this._nodes.forEach((v, i) => {\r\n                v.index = i;\r\n                if (typeof v.x === 'undefined') {\r\n                    v.x = w / 2, v.y = h / 2;\r\n                }\r\n                x[i] = v.x, y[i] = v.y;\r\n            });\r\n\r\n            if (this._linkLengthCalculator) this._linkLengthCalculator();\r\n\r\n            //should we do this to clearly label groups?\r\n            //this._groups.forEach((g, i) => g.groupIndex = i);\r\n\r\n            var distances;\r\n            if (this._distanceMatrix) {\r\n                // use the user specified distanceMatrix\r\n                distances = this._distanceMatrix;\r\n            } else {\r\n                // construct an n X n distance matrix based on shortest paths through graph (with respect to edge.length).\r\n                distances = (new Calculator(N, this._links, Layout.getSourceIndex, Layout.getTargetIndex, l=> this.getLinkLength(l))).DistanceMatrix();\r\n\r\n                // G is a square matrix with G[i][j] = 1 iff there exists an edge between node i and node j\r\n                // otherwise 2. (\r\n                G = Descent.createSquareMatrix(N, () => 2);\r\n                this._links.forEach(l => {\r\n                    if (typeof l.source == \"number\") l.source = this._nodes[<number>l.source];\r\n                    if (typeof l.target == \"number\") l.target = this._nodes[<number>l.target];\r\n                });\r\n                this._links.forEach(e => {\r\n                    const u = Layout.getSourceIndex(e), v = Layout.getTargetIndex(e);\r\n                    G[u][v] = G[v][u] = e.weight || 1;\r\n                });\r\n            }\r\n\r\n            var D = Descent.createSquareMatrix(N, function (i, j) {\r\n                return distances[i][j];\r\n            });\r\n\r\n            if (this._rootGroup && typeof this._rootGroup.groups !== 'undefined') {\r\n                var i = n;\r\n                var addAttraction = (i, j, strength, idealDistance) => {\r\n                    G[i][j] = G[j][i] = strength;\r\n                    D[i][j] = D[j][i] = idealDistance;\r\n                };\r\n                this._groups.forEach(g => {\r\n                    addAttraction(i, i + 1, this._groupCompactness, 0.1);\r\n\r\n                    // todo: add terms here attracting children of the group to the group dummy nodes\r\n                    //if (typeof g.leaves !== 'undefined')\r\n                    //    g.leaves.forEach(l => {\r\n                    //        addAttraction(l.index, i, 1e-4, 0.1);\r\n                    //        addAttraction(l.index, i + 1, 1e-4, 0.1);\r\n                    //    });\r\n                    //if (typeof g.groups !== 'undefined')\r\n                    //    g.groups.forEach(g => {\r\n                    //        var gid = n + g.groupIndex * 2;\r\n                    //        addAttraction(gid, i, 0.1, 0.1);\r\n                    //        addAttraction(gid + 1, i, 0.1, 0.1);\r\n                    //        addAttraction(gid, i + 1, 0.1, 0.1);\r\n                    //        addAttraction(gid + 1, i + 1, 0.1, 0.1);\r\n                    //    });\r\n\r\n                    x[i] = 0, y[i++] = 0;\r\n                    x[i] = 0, y[i++] = 0;\r\n                });\r\n            } else this._rootGroup = { leaves: this._nodes, groups: [] };\r\n\r\n            var curConstraints = this._constraints || [];\r\n            if (this._directedLinkConstraints) {\r\n                (<any>this.linkAccessor).getMinSeparation = this._directedLinkConstraints.getMinSeparation;\r\n                curConstraints = curConstraints.concat(generateDirectedEdgeConstraints(n, this._links, this._directedLinkConstraints.axis, <any>(this.linkAccessor)));\r\n\r\n                // todo: add containment constraints between group dummy nodes and their children\r\n            }\r\n\r\n            this.avoidOverlaps(false);\r\n            this._descent = new Descent([x, y], D);\r\n\r\n            this._descent.locks.clear();\r\n            for (var i = 0; i < n; ++i) {\r\n                var o = this._nodes[i];\r\n                if (o.fixed) {\r\n                    o.px = o.x;\r\n                    o.py = o.y;\r\n                    var p = [o.x, o.y];\r\n                    this._descent.locks.add(i, p);\r\n                }\r\n            }\r\n            this._descent.threshold = this._threshold;\r\n\r\n            // apply initialIterations without user constraints or nonoverlap constraints\r\n            // if groups are specified, dummy nodes and edges will be added to untangle\r\n            // with respect to group connectivity\r\n            this.initialLayout(initialUnconstrainedIterations, x, y);\r\n\r\n            // apply initialIterations with user constraints but no nonoverlap constraints\r\n            if (curConstraints.length > 0) this._descent.project = new Projection(this._nodes, this._groups, this._rootGroup, curConstraints).projectFunctions();\r\n            this._descent.run(initialUserConstraintIterations);\r\n            this.separateOverlappingComponents(w, h, centerGraph);\r\n\r\n            // subsequent iterations will apply all constraints\r\n            this.avoidOverlaps(ao);\r\n            if (ao) {\r\n                this._nodes.forEach(function (v, i) { v.x = x[i], v.y = y[i]; });\r\n                this._descent.project = new Projection(this._nodes, this._groups, this._rootGroup, curConstraints, true).projectFunctions();\r\n                this._nodes.forEach(function (v, i) { x[i] = v.x, y[i] = v.y; });\r\n            }\r\n\r\n            // allow not immediately connected nodes to relax apart (p-stress)\r\n            this._descent.G = G;\r\n            this._descent.run(initialAllConstraintsIterations);\r\n\r\n            if (gridSnapIterations) {\r\n                this._descent.snapStrength = 1000;\r\n                this._descent.snapGridSize = this._nodes[0].width;\r\n                this._descent.numGridSnapNodes = n;\r\n                this._descent.scaleSnapByMaxH = n != N; // if we have groups then need to scale hessian so grid forces still apply\r\n                var G0 = Descent.createSquareMatrix(N,(i, j) => {\r\n                    if (i >= n || j >= n) return G[i][j];\r\n                    return 0\r\n                });\r\n                this._descent.G = G0;\r\n                this._descent.run(gridSnapIterations);\r\n            }\r\n\r\n            this.updateNodePositions();\r\n            this.separateOverlappingComponents(w, h, centerGraph);\r\n            return keepRunning ? this.resume() : this;\r\n        }\r\n\r\n        private initialLayout(iterations: number, x: number[], y: number[]) {\r\n            if (this._groups.length > 0 && iterations > 0) {\r\n                // construct a flat graph with dummy nodes for the groups and edges connecting group dummy nodes to their children\r\n                // todo: edges attached to groups are replaced with edges connected to the corresponding group dummy node\r\n                var n = this._nodes.length;\r\n                var edges = this._links.map(e => <any>{ source: (<Node>e.source).index, target: (<Node>e.target).index });\r\n                var vs = this._nodes.map(v => <any>{ index: v.index });\r\n                this._groups.forEach((g, i) => {\r\n                    vs.push(<any>{ index: g.index = n + i });\r\n                });\r\n                this._groups.forEach((g, i) => {\r\n                    if (typeof g.leaves !== 'undefined')\r\n                        g.leaves.forEach(v => edges.push({ source: g.index, target: v.index }));\r\n                    if (typeof g.groups !== 'undefined')\r\n                        g.groups.forEach(gg => edges.push({ source: g.index, target: gg.index }));\r\n                });\r\n\r\n                // layout the flat graph with dummy nodes and edges\r\n                new Layout()\r\n                    .size(this.size())\r\n                    .nodes(vs)\r\n                    .links(edges)\r\n                    .avoidOverlaps(false)\r\n                    .linkDistance(this.linkDistance())\r\n                    .symmetricDiffLinkLengths(5)\r\n                    .convergenceThreshold(1e-4)\r\n                    .start(iterations, 0, 0, 0, false);\r\n\r\n                this._nodes.forEach(v => {\r\n                    x[v.index] = vs[v.index].x;\r\n                    y[v.index] = vs[v.index].y;\r\n                });\r\n            } else {\r\n                this._descent.run(iterations);\r\n            }\r\n        }\r\n\r\n        // recalculate nodes position for disconnected graphs\r\n        private separateOverlappingComponents(width: number, height: number, centerGraph: boolean = true): void {\r\n            // recalculate nodes position for disconnected graphs\r\n            if (!this._distanceMatrix && this._handleDisconnected) {\r\n                let x = this._descent.x[0], y = this._descent.x[1];\r\n                this._nodes.forEach(function (v, i) { v.x = x[i], v.y = y[i]; });\r\n                var graphs = separateGraphs(this._nodes, this._links);\r\n                applyPacking(graphs, width, height, this._defaultNodeSize, 1, centerGraph);\r\n                this._nodes.forEach((v, i) => {\r\n                    this._descent.x[0][i] = v.x, this._descent.x[1][i] = v.y;\r\n                    if (v.bounds) {\r\n                        v.bounds.setXCentre(v.x);\r\n                        v.bounds.setYCentre(v.y);\r\n                    }\r\n                });\r\n            }\r\n        }\r\n\r\n        resume(): this {\r\n            return this.alpha(0.1);\r\n        }\r\n\r\n        stop(): this {\r\n            return this.alpha(0);\r\n        }\r\n\r\n        /// find a visibility graph over the set of nodes.  assumes all nodes have a\r\n        /// bounds property (a rectangle) and that no pair of bounds overlaps.\r\n        prepareEdgeRouting(nodeMargin: number = 0) {\r\n            this._visibilityGraph = new TangentVisibilityGraph(\r\n                this._nodes.map(function (v) {\r\n                    return v.bounds.inflate(-nodeMargin).vertices();\r\n                }));\r\n        }\r\n\r\n        /**\r\n         * find a route avoiding node bounds for the given edge.\r\n         * assumes the visibility graph has been created (by prepareEdgeRouting method)\r\n         * and also assumes that nodes have an index property giving their position in the\r\n         * node array.  This index property is created by the start() method.\r\n         * @param [edge] The edge to generate a route for.\r\n         * @param {number} [ah] The size of the arrow head, a distance to shorten the end\r\n         *                      of the edge by.  Defaults to 5.\r\n         */\r\n        routeEdge(edge, ah: number = 5, draw) {\r\n            var lineData = [];\r\n            //if (d.source.id === 10 && d.target.id === 11) {\r\n            //    debugger;\r\n            //}\r\n            var vg2 = new TangentVisibilityGraph(this._visibilityGraph.P, { V: this._visibilityGraph.V, E: this._visibilityGraph.E }),\r\n                port1 = <TVGPoint>{ x: edge.source.x, y: edge.source.y },\r\n                port2 = <TVGPoint>{ x: edge.target.x, y: edge.target.y },\r\n                start = vg2.addPoint(port1, edge.source.index),\r\n                end = vg2.addPoint(port2, edge.target.index);\r\n            vg2.addEdgeIfVisible(port1, port2, edge.source.index, edge.target.index);\r\n            if (typeof draw !== 'undefined') {\r\n                draw(vg2);\r\n            }\r\n            var sourceInd = e => e.source.id, targetInd = e => e.target.id, length = e => e.length(),\r\n                spCalc = new Calculator(vg2.V.length, vg2.E, sourceInd, targetInd, length),\r\n                shortestPath = spCalc.PathFromNodeToNode(start.id, end.id);\r\n            if (shortestPath.length === 1 || shortestPath.length === vg2.V.length) {\r\n                let route = makeEdgeBetween(edge.source.innerBounds, edge.target.innerBounds, ah);\r\n                lineData = [route.sourceIntersection, route.arrowStart];\r\n            } else {\r\n                var n = shortestPath.length - 2,\r\n                    p = vg2.V[shortestPath[n]].p,\r\n                    q = vg2.V[shortestPath[0]].p,\r\n                    lineData = [edge.source.innerBounds.rayIntersection(p.x, p.y)];\r\n                for (var i = n; i >= 0; --i)\r\n                    lineData.push(vg2.V[shortestPath[i]].p);\r\n                lineData.push(makeEdgeTo(q, edge.target.innerBounds, ah));\r\n            }\r\n            //lineData.forEach((v, i) => {\r\n            //    if (i > 0) {\r\n            //        var u = lineData[i - 1];\r\n            //        this._nodes.forEach(function (node) {\r\n            //            if (node.id === getSourceIndex(d) || node.id === getTargetIndex(d)) return;\r\n            //            var ints = node.innerBounds.lineIntersections(u.x, u.y, v.x, v.y);\r\n            //            if (ints.length > 0) {\r\n            //                debugger;\r\n            //            }\r\n            //        })\r\n            //    }\r\n            //})\r\n            return lineData;\r\n        }\r\n\r\n        //The link source and target may be just a node index, or they may be references to nodes themselves.\r\n        static getSourceIndex(e: Link<Node | number>): number {\r\n            return typeof e.source === 'number' ? <number>e.source : (<Node>e.source).index;\r\n        }\r\n\r\n        //The link source and target may be just a node index, or they may be references to nodes themselves.\r\n        static getTargetIndex(e: Link<Node | number>): number {\r\n            return typeof e.target === 'number' ? <number>e.target : (<Node>e.target).index;\r\n        }\r\n\r\n        // Get a string ID for a given link.\r\n        static linkId(e: Link<Node | number>): string {\r\n            return Layout.getSourceIndex(e) + \"-\" + Layout.getTargetIndex(e);\r\n        }\r\n\r\n        // The fixed property has three bits:\r\n        // Bit 1 can be set externally (e.g., d.fixed = true) and show persist.\r\n        // Bit 2 stores the dragging state, from mousedown to mouseup.\r\n        // Bit 3 stores the hover state, from mouseover to mouseout.\r\n        static dragStart(d: Node | Group) {\r\n            if (isGroup(d)) {\r\n                Layout.storeOffset(d, Layout.dragOrigin(d));\r\n            } else {\r\n                Layout.stopNode(d);\r\n                d.fixed |= 2; // set bit 2\r\n            }\r\n        }\r\n\r\n        // we clobber any existing desired positions for nodes\r\n        // in case another tick event occurs before the drag\r\n        private static stopNode(v: Node) {\r\n            (<any>v).px = v.x;\r\n            (<any>v).py = v.y;\r\n        }\r\n\r\n        // we store offsets for each node relative to the centre of the ancestor group\r\n        // being dragged in a pair of properties on the node\r\n        private static storeOffset(d: Group, origin: { x: number, y: number }) {\r\n            if (typeof d.leaves !== 'undefined') {\r\n                d.leaves.forEach(v => {\r\n                    v.fixed |= 2;\r\n                    Layout.stopNode(v);\r\n                    (<any>v)._dragGroupOffsetX = v.x - origin.x;\r\n                    (<any>v)._dragGroupOffsetY = v.y - origin.y;\r\n                });\r\n            }\r\n            if (typeof d.groups !== 'undefined') {\r\n                d.groups.forEach(g => Layout.storeOffset(g, origin));\r\n            }\r\n        }\r\n\r\n        // the drag origin is taken as the centre of the node or group\r\n        static dragOrigin(d: Node | Group): { x: number, y: number } {\r\n            if (isGroup(d)) {\r\n                return {\r\n                    x: d.bounds.cx(),\r\n                    y: d.bounds.cy()\r\n                };\r\n            } else {\r\n                return d;\r\n            }\r\n        }\r\n\r\n        // for groups, the drag translation is propagated down to all of the children of\r\n        // the group.\r\n        static drag(d: Node | Group, position: { x: number, y: number }) {\r\n            if (isGroup(d)) {\r\n                if (typeof d.leaves !== 'undefined') {\r\n                    d.leaves.forEach(v => {\r\n                        d.bounds.setXCentre(position.x);\r\n                        d.bounds.setYCentre(position.y);\r\n                        (<any>v).px = (<any>v)._dragGroupOffsetX + position.x;\r\n                        (<any>v).py = (<any>v)._dragGroupOffsetY + position.y;\r\n                    });\r\n                }\r\n                if (typeof d.groups !== 'undefined') {\r\n                    d.groups.forEach(g => Layout.drag(g, position));\r\n                }\r\n            } else {\r\n                (<any>d).px = position.x;\r\n                (<any>d).py = position.y;\r\n            }\r\n        }\r\n\r\n        // we unset only bits 2 and 3 so that the user can fix nodes with another a different\r\n        // bit such that the lock persists between drags\r\n        static dragEnd(d) {\r\n            if (isGroup(d)) {\r\n                if (typeof d.leaves !== 'undefined') {\r\n                    d.leaves.forEach(v => {\r\n                        Layout.dragEnd(v);\r\n                        delete (<any>v)._dragGroupOffsetX;\r\n                        delete (<any>v)._dragGroupOffsetY;\r\n                    });\r\n                }\r\n                if (typeof d.groups !== 'undefined') {\r\n                    d.groups.forEach(Layout.dragEnd);\r\n                }\r\n            } else {\r\n                d.fixed &= ~6; // unset bits 2 and 3\r\n                //d.fixed = 0;\r\n            }\r\n        }\r\n\r\n        // in d3 hover temporarily locks nodes, currently not used in cola\r\n        static mouseOver(d) {\r\n            d.fixed |= 4; // set bit 3\r\n            d.px = d.x, d.py = d.y; // set velocity to zero\r\n        }\r\n\r\n        // in d3 hover temporarily locks nodes, currently not used in cola\r\n        static mouseOut(d) {\r\n            d.fixed &= ~4; // unset bit 3\r\n        }\r\n    }\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}