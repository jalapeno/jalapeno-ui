{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nfunction unionCount(a, b) {\n  var u = {};\n  for (var i in a) u[i] = {};\n  for (var i in b) u[i] = {};\n  return Object.keys(u).length;\n}\nfunction intersectionCount(a, b) {\n  var n = 0;\n  for (var i in a) if (typeof b[i] !== 'undefined') ++n;\n  return n;\n}\nfunction getNeighbours(links, la) {\n  var neighbours = {};\n  var addNeighbours = function (u, v) {\n    if (typeof neighbours[u] === 'undefined') neighbours[u] = {};\n    neighbours[u][v] = {};\n  };\n  links.forEach(function (e) {\n    var u = la.getSourceIndex(e),\n      v = la.getTargetIndex(e);\n    addNeighbours(u, v);\n    addNeighbours(v, u);\n  });\n  return neighbours;\n}\nfunction computeLinkLengths(links, w, f, la) {\n  var neighbours = getNeighbours(links, la);\n  links.forEach(function (l) {\n    var a = neighbours[la.getSourceIndex(l)];\n    var b = neighbours[la.getTargetIndex(l)];\n    la.setLength(l, 1 + w * f(a, b));\n  });\n}\nfunction symmetricDiffLinkLengths(links, la, w) {\n  if (w === void 0) {\n    w = 1;\n  }\n  computeLinkLengths(links, w, function (a, b) {\n    return Math.sqrt(unionCount(a, b) - intersectionCount(a, b));\n  }, la);\n}\nexports.symmetricDiffLinkLengths = symmetricDiffLinkLengths;\nfunction jaccardLinkLengths(links, la, w) {\n  if (w === void 0) {\n    w = 1;\n  }\n  computeLinkLengths(links, w, function (a, b) {\n    return Math.min(Object.keys(a).length, Object.keys(b).length) < 1.1 ? 0 : intersectionCount(a, b) / unionCount(a, b);\n  }, la);\n}\nexports.jaccardLinkLengths = jaccardLinkLengths;\nfunction generateDirectedEdgeConstraints(n, links, axis, la) {\n  var components = stronglyConnectedComponents(n, links, la);\n  var nodes = {};\n  components.forEach(function (c, i) {\n    return c.forEach(function (v) {\n      return nodes[v] = i;\n    });\n  });\n  var constraints = [];\n  links.forEach(function (l) {\n    var ui = la.getSourceIndex(l),\n      vi = la.getTargetIndex(l),\n      u = nodes[ui],\n      v = nodes[vi];\n    if (u !== v) {\n      constraints.push({\n        axis: axis,\n        left: ui,\n        right: vi,\n        gap: la.getMinSeparation(l)\n      });\n    }\n  });\n  return constraints;\n}\nexports.generateDirectedEdgeConstraints = generateDirectedEdgeConstraints;\nfunction stronglyConnectedComponents(numVertices, edges, la) {\n  var nodes = [];\n  var index = 0;\n  var stack = [];\n  var components = [];\n  function strongConnect(v) {\n    v.index = v.lowlink = index++;\n    stack.push(v);\n    v.onStack = true;\n    for (var _i = 0, _a = v.out; _i < _a.length; _i++) {\n      var w = _a[_i];\n      if (typeof w.index === 'undefined') {\n        strongConnect(w);\n        v.lowlink = Math.min(v.lowlink, w.lowlink);\n      } else if (w.onStack) {\n        v.lowlink = Math.min(v.lowlink, w.index);\n      }\n    }\n    if (v.lowlink === v.index) {\n      var component = [];\n      while (stack.length) {\n        w = stack.pop();\n        w.onStack = false;\n        component.push(w);\n        if (w === v) break;\n      }\n      components.push(component.map(function (v) {\n        return v.id;\n      }));\n    }\n  }\n  for (var i = 0; i < numVertices; i++) {\n    nodes.push({\n      id: i,\n      out: []\n    });\n  }\n  for (var _i = 0, edges_1 = edges; _i < edges_1.length; _i++) {\n    var e = edges_1[_i];\n    var v_1 = nodes[la.getSourceIndex(e)],\n      w = nodes[la.getTargetIndex(e)];\n    v_1.out.push(w);\n  }\n  for (var _a = 0, nodes_1 = nodes; _a < nodes_1.length; _a++) {\n    var v = nodes_1[_a];\n    if (typeof v.index === 'undefined') strongConnect(v);\n  }\n  return components;\n}\nexports.stronglyConnectedComponents = stronglyConnectedComponents;","map":{"version":3,"names":["unionCount","a","b","u","i","Object","keys","length","intersectionCount","n","getNeighbours","links","la","neighbours","addNeighbours","v","forEach","e","getSourceIndex","getTargetIndex","computeLinkLengths","w","f","l","setLength","symmetricDiffLinkLengths","Math","sqrt","exports","jaccardLinkLengths","min","generateDirectedEdgeConstraints","axis","components","stronglyConnectedComponents","nodes","c","constraints","ui","vi","push","left","right","gap","getMinSeparation","numVertices","edges","index","stack","strongConnect","lowlink","onStack","_i","_a","out","component","pop","map","id","edges_1","v_1","nodes_1"],"sources":["/Users/brucemcdougall/go/jalapeno-github/jalapeno-ui/node_modules/webcola/WebCola/src/linklengths.ts"],"sourcesContent":["    export interface LinkAccessor<Link> {\r\n        getSourceIndex(l: Link): number;\r\n        getTargetIndex(l: Link): number;\r\n    }\r\n\r\n    export interface LinkLengthAccessor<Link> extends LinkAccessor<Link> {\r\n        setLength(l: Link, value: number): void;\r\n    }\r\n\r\n    // compute the size of the union of two sets a and b\r\n    function unionCount(a: any, b: any): number {\r\n        var u = {};\r\n        for (var i in a) u[i] = {};\r\n        for (var i in b) u[i] = {};\r\n        return Object.keys(u).length;\r\n    }\r\n\r\n    // compute the size of the intersection of two sets a and b\r\n    function intersectionCount(a: number[], b: number[]): number {\r\n        var n = 0;\r\n        for (var i in a) if (typeof b[i] !== 'undefined') ++n;\r\n        return n;\r\n    }\r\n\r\n    function getNeighbours<Link>(links: Link[], la: LinkAccessor<Link>): any {\r\n        var neighbours = {};\r\n        var addNeighbours = (u, v) => {\r\n            if (typeof neighbours[u] === 'undefined')\r\n                neighbours[u] = {};\r\n            neighbours[u][v] = {};\r\n        };\r\n        links.forEach(e => {\r\n            var u = la.getSourceIndex(e), v = la.getTargetIndex(e);\r\n            addNeighbours(u, v);\r\n            addNeighbours(v, u);\r\n        });\r\n        return neighbours;\r\n    }\r\n\r\n    // modify the lengths of the specified links by the result of function f weighted by w\r\n    function computeLinkLengths<Link>(links: Link[], w: number, f: (a: any, b: any) => number, la: LinkLengthAccessor<Link>) {\r\n        var neighbours = getNeighbours(links, la);\r\n        links.forEach(l => {\r\n            var a = neighbours[la.getSourceIndex(l)];\r\n            var b = neighbours[la.getTargetIndex(l)];\r\n            la.setLength(l, 1 + w * f(a, b));\r\n        });\r\n    }\r\n\r\n    /** modify the specified link lengths based on the symmetric difference of their neighbours\r\n     * @class symmetricDiffLinkLengths\r\n     */\r\n    export function symmetricDiffLinkLengths<Link>(links: Link[], la: LinkLengthAccessor<Link>, w: number = 1) {\r\n        computeLinkLengths(links, w, (a, b) => Math.sqrt(unionCount(a, b) - intersectionCount(a, b)), la);\r\n    }\r\n\r\n    /** modify the specified links lengths based on the jaccard difference between their neighbours\r\n     * @class jaccardLinkLengths\r\n     */\r\n    export function jaccardLinkLengths<Link>(links: Link[], la: LinkLengthAccessor<Link>, w: number = 1) {\r\n        computeLinkLengths(links, w, (a, b) =>\r\n            Math.min(Object.keys(a).length, Object.keys(b).length) < 1.1 ? 0 : intersectionCount(a, b) / unionCount(a, b)\r\n            , la);\r\n    }\r\n\r\n    export interface IConstraint {\r\n        left: number;\r\n        right: number;\r\n        gap: number;\r\n    }\r\n\r\n    export interface DirectedEdgeConstraints {\r\n        axis: string;\r\n        gap: number;\r\n    }\r\n\r\n    export interface LinkSepAccessor<Link> extends LinkAccessor<Link> {\r\n        getMinSeparation(l: Link): number;\r\n    }\r\n\r\n    /** generate separation constraints for all edges unless both their source and sink are in the same strongly connected component\r\n     * @class generateDirectedEdgeConstraints\r\n     */\r\n    export function generateDirectedEdgeConstraints<Link>(n: number, links: Link[], axis: string,\r\n        la: LinkSepAccessor<Link>): IConstraint[]\r\n    {\r\n        var components = stronglyConnectedComponents(n, links, la);\r\n        var nodes = {};\r\n        components.forEach((c,i) =>\r\n            c.forEach(v => nodes[v] = i)\r\n        );\r\n        var constraints: any[] = [];\r\n        links.forEach(l => {\r\n            var ui = la.getSourceIndex(l), vi = la.getTargetIndex(l),\r\n                u = nodes[ui], v = nodes[vi];\r\n            if (u !== v) {\r\n                constraints.push({\r\n                    axis: axis,\r\n                    left: ui,\r\n                    right: vi,\r\n                    gap: la.getMinSeparation(l)\r\n                });\r\n            }\r\n        });\r\n        return constraints;\r\n    }\r\n\r\n    /**\r\n     * Tarjan's strongly connected components algorithm for directed graphs\r\n     * returns an array of arrays of node indicies in each of the strongly connected components.\r\n     * a vertex not in a SCC of two or more nodes is it's own SCC.\r\n     * adaptation of https://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm\r\n     */\r\n    export function stronglyConnectedComponents<Link>(numVertices: number, edges: Link[], la: LinkAccessor<Link>): number[][]{\r\n        var nodes = [];\r\n        var index = 0;\r\n        var stack = [];\r\n        var components = [];\r\n        function strongConnect(v) {\r\n            // Set the depth index for v to the smallest unused index\r\n            v.index = v.lowlink = index++;\r\n            stack.push(v);\r\n            v.onStack = true;\r\n\r\n            // Consider successors of v\r\n            for (var w of v.out) {\r\n                if (typeof w.index === 'undefined') {\r\n                    // Successor w has not yet been visited; recurse on it\r\n                    strongConnect(w);\r\n                    v.lowlink = Math.min(v.lowlink, w.lowlink);\r\n                } else if (w.onStack) {\r\n                    // Successor w is in stack S and hence in the current SCC\r\n                    v.lowlink = Math.min(v.lowlink, w.index);\r\n                }\r\n            }\r\n\r\n            // If v is a root node, pop the stack and generate an SCC\r\n            if (v.lowlink === v.index) {\r\n                // start a new strongly connected component\r\n                var component = [];\r\n                while (stack.length) {\r\n                    w = stack.pop();\r\n                    w.onStack = false;\r\n                    //add w to current strongly connected component\r\n                    component.push(w);\r\n                    if (w === v) break;\r\n                }\r\n                // output the current strongly connected component\r\n                components.push(component.map(v => v.id));\r\n            }\r\n        }\r\n        for (var i = 0; i < numVertices; i++) {\r\n            nodes.push({id: i, out: []});\r\n        }\r\n        for (var e of edges) {\r\n            let v = nodes[la.getSourceIndex(e)],\r\n                w = nodes[la.getTargetIndex(e)];\r\n            v.out.push(w);\r\n        }\r\n        for (var v of nodes) if (typeof v.index === 'undefined') strongConnect(v);\r\n        return components;\r\n    }\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}