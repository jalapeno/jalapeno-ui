{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar PositionStats = function () {\n  function PositionStats(scale) {\n    this.scale = scale;\n    this.AB = 0;\n    this.AD = 0;\n    this.A2 = 0;\n  }\n  PositionStats.prototype.addVariable = function (v) {\n    var ai = this.scale / v.scale;\n    var bi = v.offset / v.scale;\n    var wi = v.weight;\n    this.AB += wi * ai * bi;\n    this.AD += wi * ai * v.desiredPosition;\n    this.A2 += wi * ai * ai;\n  };\n  PositionStats.prototype.getPosn = function () {\n    return (this.AD - this.AB) / this.A2;\n  };\n  return PositionStats;\n}();\nexports.PositionStats = PositionStats;\nvar Constraint = function () {\n  function Constraint(left, right, gap, equality) {\n    if (equality === void 0) {\n      equality = false;\n    }\n    this.left = left;\n    this.right = right;\n    this.gap = gap;\n    this.equality = equality;\n    this.active = false;\n    this.unsatisfiable = false;\n    this.left = left;\n    this.right = right;\n    this.gap = gap;\n    this.equality = equality;\n  }\n  Constraint.prototype.slack = function () {\n    return this.unsatisfiable ? Number.MAX_VALUE : this.right.scale * this.right.position() - this.gap - this.left.scale * this.left.position();\n  };\n  return Constraint;\n}();\nexports.Constraint = Constraint;\nvar Variable = function () {\n  function Variable(desiredPosition, weight, scale) {\n    if (weight === void 0) {\n      weight = 1;\n    }\n    if (scale === void 0) {\n      scale = 1;\n    }\n    this.desiredPosition = desiredPosition;\n    this.weight = weight;\n    this.scale = scale;\n    this.offset = 0;\n  }\n  Variable.prototype.dfdv = function () {\n    return 2.0 * this.weight * (this.position() - this.desiredPosition);\n  };\n  Variable.prototype.position = function () {\n    return (this.block.ps.scale * this.block.posn + this.offset) / this.scale;\n  };\n  Variable.prototype.visitNeighbours = function (prev, f) {\n    var ff = function (c, next) {\n      return c.active && prev !== next && f(c, next);\n    };\n    this.cOut.forEach(function (c) {\n      return ff(c, c.right);\n    });\n    this.cIn.forEach(function (c) {\n      return ff(c, c.left);\n    });\n  };\n  return Variable;\n}();\nexports.Variable = Variable;\nvar Block = function () {\n  function Block(v) {\n    this.vars = [];\n    v.offset = 0;\n    this.ps = new PositionStats(v.scale);\n    this.addVariable(v);\n  }\n  Block.prototype.addVariable = function (v) {\n    v.block = this;\n    this.vars.push(v);\n    this.ps.addVariable(v);\n    this.posn = this.ps.getPosn();\n  };\n  Block.prototype.updateWeightedPosition = function () {\n    this.ps.AB = this.ps.AD = this.ps.A2 = 0;\n    for (var i = 0, n = this.vars.length; i < n; ++i) this.ps.addVariable(this.vars[i]);\n    this.posn = this.ps.getPosn();\n  };\n  Block.prototype.compute_lm = function (v, u, postAction) {\n    var _this = this;\n    var dfdv = v.dfdv();\n    v.visitNeighbours(u, function (c, next) {\n      var _dfdv = _this.compute_lm(next, v, postAction);\n      if (next === c.right) {\n        dfdv += _dfdv * c.left.scale;\n        c.lm = _dfdv;\n      } else {\n        dfdv += _dfdv * c.right.scale;\n        c.lm = -_dfdv;\n      }\n      postAction(c);\n    });\n    return dfdv / v.scale;\n  };\n  Block.prototype.populateSplitBlock = function (v, prev) {\n    var _this = this;\n    v.visitNeighbours(prev, function (c, next) {\n      next.offset = v.offset + (next === c.right ? c.gap : -c.gap);\n      _this.addVariable(next);\n      _this.populateSplitBlock(next, v);\n    });\n  };\n  Block.prototype.traverse = function (visit, acc, v, prev) {\n    var _this = this;\n    if (v === void 0) {\n      v = this.vars[0];\n    }\n    if (prev === void 0) {\n      prev = null;\n    }\n    v.visitNeighbours(prev, function (c, next) {\n      acc.push(visit(c));\n      _this.traverse(visit, acc, next, v);\n    });\n  };\n  Block.prototype.findMinLM = function () {\n    var m = null;\n    this.compute_lm(this.vars[0], null, function (c) {\n      if (!c.equality && (m === null || c.lm < m.lm)) m = c;\n    });\n    return m;\n  };\n  Block.prototype.findMinLMBetween = function (lv, rv) {\n    this.compute_lm(lv, null, function () {});\n    var m = null;\n    this.findPath(lv, null, rv, function (c, next) {\n      if (!c.equality && c.right === next && (m === null || c.lm < m.lm)) m = c;\n    });\n    return m;\n  };\n  Block.prototype.findPath = function (v, prev, to, visit) {\n    var _this = this;\n    var endFound = false;\n    v.visitNeighbours(prev, function (c, next) {\n      if (!endFound && (next === to || _this.findPath(next, v, to, visit))) {\n        endFound = true;\n        visit(c, next);\n      }\n    });\n    return endFound;\n  };\n  Block.prototype.isActiveDirectedPathBetween = function (u, v) {\n    if (u === v) return true;\n    var i = u.cOut.length;\n    while (i--) {\n      var c = u.cOut[i];\n      if (c.active && this.isActiveDirectedPathBetween(c.right, v)) return true;\n    }\n    return false;\n  };\n  Block.split = function (c) {\n    c.active = false;\n    return [Block.createSplitBlock(c.left), Block.createSplitBlock(c.right)];\n  };\n  Block.createSplitBlock = function (startVar) {\n    var b = new Block(startVar);\n    b.populateSplitBlock(startVar, null);\n    return b;\n  };\n  Block.prototype.splitBetween = function (vl, vr) {\n    var c = this.findMinLMBetween(vl, vr);\n    if (c !== null) {\n      var bs = Block.split(c);\n      return {\n        constraint: c,\n        lb: bs[0],\n        rb: bs[1]\n      };\n    }\n    return null;\n  };\n  Block.prototype.mergeAcross = function (b, c, dist) {\n    c.active = true;\n    for (var i = 0, n = b.vars.length; i < n; ++i) {\n      var v = b.vars[i];\n      v.offset += dist;\n      this.addVariable(v);\n    }\n    this.posn = this.ps.getPosn();\n  };\n  Block.prototype.cost = function () {\n    var sum = 0,\n      i = this.vars.length;\n    while (i--) {\n      var v = this.vars[i],\n        d = v.position() - v.desiredPosition;\n      sum += d * d * v.weight;\n    }\n    return sum;\n  };\n  return Block;\n}();\nexports.Block = Block;\nvar Blocks = function () {\n  function Blocks(vs) {\n    this.vs = vs;\n    var n = vs.length;\n    this.list = new Array(n);\n    while (n--) {\n      var b = new Block(vs[n]);\n      this.list[n] = b;\n      b.blockInd = n;\n    }\n  }\n  Blocks.prototype.cost = function () {\n    var sum = 0,\n      i = this.list.length;\n    while (i--) sum += this.list[i].cost();\n    return sum;\n  };\n  Blocks.prototype.insert = function (b) {\n    b.blockInd = this.list.length;\n    this.list.push(b);\n  };\n  Blocks.prototype.remove = function (b) {\n    var last = this.list.length - 1;\n    var swapBlock = this.list[last];\n    this.list.length = last;\n    if (b !== swapBlock) {\n      this.list[b.blockInd] = swapBlock;\n      swapBlock.blockInd = b.blockInd;\n    }\n  };\n  Blocks.prototype.merge = function (c) {\n    var l = c.left.block,\n      r = c.right.block;\n    var dist = c.right.offset - c.left.offset - c.gap;\n    if (l.vars.length < r.vars.length) {\n      r.mergeAcross(l, c, dist);\n      this.remove(l);\n    } else {\n      l.mergeAcross(r, c, -dist);\n      this.remove(r);\n    }\n  };\n  Blocks.prototype.forEach = function (f) {\n    this.list.forEach(f);\n  };\n  Blocks.prototype.updateBlockPositions = function () {\n    this.list.forEach(function (b) {\n      return b.updateWeightedPosition();\n    });\n  };\n  Blocks.prototype.split = function (inactive) {\n    var _this = this;\n    this.updateBlockPositions();\n    this.list.forEach(function (b) {\n      var v = b.findMinLM();\n      if (v !== null && v.lm < Solver.LAGRANGIAN_TOLERANCE) {\n        b = v.left.block;\n        Block.split(v).forEach(function (nb) {\n          return _this.insert(nb);\n        });\n        _this.remove(b);\n        inactive.push(v);\n      }\n    });\n  };\n  return Blocks;\n}();\nexports.Blocks = Blocks;\nvar Solver = function () {\n  function Solver(vs, cs) {\n    this.vs = vs;\n    this.cs = cs;\n    this.vs = vs;\n    vs.forEach(function (v) {\n      v.cIn = [], v.cOut = [];\n    });\n    this.cs = cs;\n    cs.forEach(function (c) {\n      c.left.cOut.push(c);\n      c.right.cIn.push(c);\n    });\n    this.inactive = cs.map(function (c) {\n      c.active = false;\n      return c;\n    });\n    this.bs = null;\n  }\n  Solver.prototype.cost = function () {\n    return this.bs.cost();\n  };\n  Solver.prototype.setStartingPositions = function (ps) {\n    this.inactive = this.cs.map(function (c) {\n      c.active = false;\n      return c;\n    });\n    this.bs = new Blocks(this.vs);\n    this.bs.forEach(function (b, i) {\n      return b.posn = ps[i];\n    });\n  };\n  Solver.prototype.setDesiredPositions = function (ps) {\n    this.vs.forEach(function (v, i) {\n      return v.desiredPosition = ps[i];\n    });\n  };\n  Solver.prototype.mostViolated = function () {\n    var minSlack = Number.MAX_VALUE,\n      v = null,\n      l = this.inactive,\n      n = l.length,\n      deletePoint = n;\n    for (var i = 0; i < n; ++i) {\n      var c = l[i];\n      if (c.unsatisfiable) continue;\n      var slack = c.slack();\n      if (c.equality || slack < minSlack) {\n        minSlack = slack;\n        v = c;\n        deletePoint = i;\n        if (c.equality) break;\n      }\n    }\n    if (deletePoint !== n && (minSlack < Solver.ZERO_UPPERBOUND && !v.active || v.equality)) {\n      l[deletePoint] = l[n - 1];\n      l.length = n - 1;\n    }\n    return v;\n  };\n  Solver.prototype.satisfy = function () {\n    if (this.bs == null) {\n      this.bs = new Blocks(this.vs);\n    }\n    this.bs.split(this.inactive);\n    var v = null;\n    while ((v = this.mostViolated()) && (v.equality || v.slack() < Solver.ZERO_UPPERBOUND && !v.active)) {\n      var lb = v.left.block,\n        rb = v.right.block;\n      if (lb !== rb) {\n        this.bs.merge(v);\n      } else {\n        if (lb.isActiveDirectedPathBetween(v.right, v.left)) {\n          v.unsatisfiable = true;\n          continue;\n        }\n        var split = lb.splitBetween(v.left, v.right);\n        if (split !== null) {\n          this.bs.insert(split.lb);\n          this.bs.insert(split.rb);\n          this.bs.remove(lb);\n          this.inactive.push(split.constraint);\n        } else {\n          v.unsatisfiable = true;\n          continue;\n        }\n        if (v.slack() >= 0) {\n          this.inactive.push(v);\n        } else {\n          this.bs.merge(v);\n        }\n      }\n    }\n  };\n  Solver.prototype.solve = function () {\n    this.satisfy();\n    var lastcost = Number.MAX_VALUE,\n      cost = this.bs.cost();\n    while (Math.abs(lastcost - cost) > 0.0001) {\n      this.satisfy();\n      lastcost = cost;\n      cost = this.bs.cost();\n    }\n    return cost;\n  };\n  Solver.LAGRANGIAN_TOLERANCE = -1e-4;\n  Solver.ZERO_UPPERBOUND = -1e-10;\n  return Solver;\n}();\nexports.Solver = Solver;\nfunction removeOverlapInOneDimension(spans, lowerBound, upperBound) {\n  var vs = spans.map(function (s) {\n    return new Variable(s.desiredCenter);\n  });\n  var cs = [];\n  var n = spans.length;\n  for (var i = 0; i < n - 1; i++) {\n    var left = spans[i],\n      right = spans[i + 1];\n    cs.push(new Constraint(vs[i], vs[i + 1], (left.size + right.size) / 2));\n  }\n  var leftMost = vs[0],\n    rightMost = vs[n - 1],\n    leftMostSize = spans[0].size / 2,\n    rightMostSize = spans[n - 1].size / 2;\n  var vLower = null,\n    vUpper = null;\n  if (lowerBound) {\n    vLower = new Variable(lowerBound, leftMost.weight * 1000);\n    vs.push(vLower);\n    cs.push(new Constraint(vLower, leftMost, leftMostSize));\n  }\n  if (upperBound) {\n    vUpper = new Variable(upperBound, rightMost.weight * 1000);\n    vs.push(vUpper);\n    cs.push(new Constraint(rightMost, vUpper, rightMostSize));\n  }\n  var solver = new Solver(vs, cs);\n  solver.solve();\n  return {\n    newCenters: vs.slice(0, spans.length).map(function (v) {\n      return v.position();\n    }),\n    lowerBound: vLower ? vLower.position() : leftMost.position() - leftMostSize,\n    upperBound: vUpper ? vUpper.position() : rightMost.position() + rightMostSize\n  };\n}\nexports.removeOverlapInOneDimension = removeOverlapInOneDimension;","map":{"version":3,"names":["PositionStats","scale","AB","AD","A2","prototype","addVariable","v","ai","bi","offset","wi","weight","desiredPosition","getPosn","exports","Constraint","left","right","gap","equality","active","unsatisfiable","slack","Number","MAX_VALUE","position","Variable","dfdv","block","ps","posn","visitNeighbours","prev","f","ff","c","next","cOut","forEach","cIn","Block","vars","push","updateWeightedPosition","i","n","length","compute_lm","u","postAction","_this","_dfdv","lm","populateSplitBlock","traverse","visit","acc","findMinLM","m","findMinLMBetween","lv","rv","findPath","to","endFound","isActiveDirectedPathBetween","split","createSplitBlock","startVar","b","splitBetween","vl","vr","bs","constraint","lb","rb","mergeAcross","dist","cost","sum","d","Blocks","vs","list","Array","blockInd","insert","remove","last","swapBlock","merge","l","r","updateBlockPositions","inactive","Solver","LAGRANGIAN_TOLERANCE","nb","cs","map","setStartingPositions","setDesiredPositions","mostViolated","minSlack","deletePoint","ZERO_UPPERBOUND","satisfy","solve","lastcost","Math","abs","removeOverlapInOneDimension","spans","lowerBound","upperBound","s","desiredCenter","size","leftMost","rightMost","leftMostSize","rightMostSize","vLower","vUpper","solver","newCenters","slice"],"sources":["/Users/brucemcdougall/go/jalapeno-github/jalapeno-ui/node_modules/webcola/WebCola/src/vpsc.ts"],"sourcesContent":["    export class PositionStats {\r\n        AB: number = 0;\r\n        AD: number = 0;\r\n        A2: number = 0;\r\n\r\n        constructor(public scale: number) {}\r\n\r\n        addVariable(v: Variable): void {\r\n            var ai = this.scale / v.scale;\r\n            var bi = v.offset / v.scale;\r\n            var wi = v.weight;\r\n            this.AB += wi * ai * bi;\r\n            this.AD += wi * ai * v.desiredPosition;\r\n            this.A2 += wi * ai * ai;\r\n        }\r\n\r\n        getPosn(): number {\r\n            return (this.AD - this.AB) / this.A2;\r\n        }\r\n    }\r\n\r\n    export class Constraint {\r\n        lm: number;\r\n        active: boolean = false;\r\n        unsatisfiable: boolean = false;\r\n\r\n        constructor(public left: Variable, public right: Variable, public gap: number, public equality: boolean = false) {\r\n            this.left = left;\r\n            this.right = right;\r\n            this.gap = gap;\r\n            this.equality = equality;\r\n        }\r\n\r\n        slack(): number {\r\n            return this.unsatisfiable ? Number.MAX_VALUE\r\n                : this.right.scale * this.right.position() - this.gap\r\n                - this.left.scale * this.left.position();\r\n        }\r\n    }\r\n\r\n    export class Variable {\r\n        offset: number = 0;\r\n        block: Block;\r\n        cIn: Constraint[];\r\n        cOut: Constraint[];\r\n\r\n        constructor(public desiredPosition: number, public weight: number = 1, public scale: number = 1) {}\r\n\r\n        dfdv(): number {\r\n            return 2.0 * this.weight * (this.position() - this.desiredPosition);\r\n        }\r\n\r\n        position(): number {\r\n            return (this.block.ps.scale * this.block.posn + this.offset) / this.scale;\r\n        }\r\n\r\n        // visit neighbours by active constraints within the same block\r\n        visitNeighbours(prev: Variable, f: (c: Constraint, next: Variable) => void ): void {\r\n            var ff = (c, next) => c.active && prev !== next && f(c, next);\r\n            this.cOut.forEach(c=> ff(c, c.right));\r\n            this.cIn.forEach(c=> ff(c, c.left));\r\n        }\r\n    }\r\n\r\n    export class Block {\r\n        vars: Variable[] = [];\r\n        posn: number;\r\n        ps: PositionStats;\r\n        blockInd: number;\r\n\r\n        constructor(v: Variable) {\r\n            v.offset = 0;\r\n            this.ps = new PositionStats(v.scale);\r\n            this.addVariable(v);\r\n        }\r\n\r\n        private addVariable(v: Variable): void {\r\n            v.block = this;\r\n            this.vars.push(v);\r\n            this.ps.addVariable(v);\r\n            this.posn = this.ps.getPosn();\r\n        }\r\n\r\n        // move the block where it needs to be to minimize cost\r\n        updateWeightedPosition(): void {\r\n            this.ps.AB = this.ps.AD = this.ps.A2 = 0;\r\n            for (var i = 0, n = this.vars.length; i < n; ++i)\r\n                this.ps.addVariable(this.vars[i]);\r\n            this.posn = this.ps.getPosn();\r\n        }\r\n\r\n        private compute_lm(v: Variable, u: Variable, postAction: (c: Constraint)=>void): number {\r\n            var dfdv = v.dfdv();\r\n            v.visitNeighbours(u, (c, next) => {\r\n                var _dfdv = this.compute_lm(next, v, postAction);\r\n                if (next === c.right) {\r\n                    dfdv += _dfdv * c.left.scale;\r\n                    c.lm = _dfdv;\r\n                } else {\r\n                    dfdv += _dfdv * c.right.scale;\r\n                    c.lm = -_dfdv;\r\n                }\r\n                postAction(c);\r\n            });\r\n            return dfdv / v.scale;\r\n        }\r\n\r\n        private populateSplitBlock(v: Variable, prev: Variable): void {\r\n            v.visitNeighbours(prev, (c, next) => {\r\n                next.offset = v.offset + (next === c.right ? c.gap : -c.gap);\r\n                this.addVariable(next);\r\n                this.populateSplitBlock(next, v);\r\n            });\r\n        }\r\n\r\n        // traverse the active constraint tree applying visit to each active constraint\r\n        traverse(visit: (c: Constraint) => any, acc: any[], v: Variable = this.vars[0], prev: Variable=null) {\r\n            v.visitNeighbours(prev, (c, next) => {\r\n                acc.push(visit(c));\r\n                this.traverse(visit, acc, next, v);\r\n            });\r\n        }\r\n\r\n        // calculate lagrangian multipliers on constraints and\r\n        // find the active constraint in this block with the smallest lagrangian.\r\n        // if the lagrangian is negative, then the constraint is a split candidate.\r\n        findMinLM(): Constraint {\r\n            var m: Constraint = null;\r\n            this.compute_lm(this.vars[0], null, c=> {\r\n                if (!c.equality && (m === null || c.lm < m.lm)) m = c;\r\n            });\r\n            return m;\r\n        }\r\n\r\n        private findMinLMBetween(lv: Variable, rv: Variable): Constraint {\r\n            this.compute_lm(lv, null, () => {});\r\n            var m = null;\r\n            this.findPath(lv, null, rv, (c, next)=> {\r\n                if (!c.equality && c.right === next && (m === null || c.lm < m.lm)) m = c;\r\n            });\r\n            return m;\r\n        }\r\n\r\n        private findPath(v: Variable, prev: Variable, to: Variable, visit: (c: Constraint, next:Variable)=>void): boolean {\r\n            var endFound = false;\r\n            v.visitNeighbours(prev, (c, next) => {\r\n                if (!endFound && (next === to || this.findPath(next, v, to, visit)))\r\n                {\r\n                    endFound = true;\r\n                    visit(c, next);\r\n                }\r\n            });\r\n            return endFound;\r\n        }\r\n\r\n        // Search active constraint tree from u to see if there is a directed path to v.\r\n        // Returns true if path is found.\r\n        isActiveDirectedPathBetween(u: Variable, v: Variable) : boolean {\r\n            if (u === v) return true;\r\n            var i = u.cOut.length;\r\n            while(i--) {\r\n                var c = u.cOut[i];\r\n                if (c.active && this.isActiveDirectedPathBetween(c.right, v))\r\n                    return true;\r\n            }\r\n            return false;\r\n        }\r\n\r\n        // split the block into two by deactivating the specified constraint\r\n        static split(c: Constraint): Block[]{\r\n/* DEBUG\r\n            console.log(\"split on \" + c);\r\n            console.assert(c.active, \"attempt to split on inactive constraint\");\r\nDEBUG */\r\n            c.active = false;\r\n            return [Block.createSplitBlock(c.left), Block.createSplitBlock(c.right)];\r\n        }\r\n\r\n        private static createSplitBlock(startVar: Variable): Block {\r\n            var b = new Block(startVar);\r\n            b.populateSplitBlock(startVar, null);\r\n            return b;\r\n        }\r\n\r\n        // find a split point somewhere between the specified variables\r\n        splitBetween(vl: Variable, vr: Variable): { constraint: Constraint; lb: Block; rb: Block } {\r\n/* DEBUG\r\n            console.assert(vl.block === this);\r\n            console.assert(vr.block === this);\r\nDEBUG */\r\n            var c = this.findMinLMBetween(vl, vr);\r\n            if (c !== null) {\r\n                var bs = Block.split(c);\r\n                return { constraint: c, lb: bs[0], rb: bs[1] };\r\n            }\r\n            // couldn't find a split point - for example the active path is all equality constraints\r\n            return null;\r\n        }\r\n\r\n        mergeAcross(b: Block, c: Constraint, dist: number): void {\r\n            c.active = true;\r\n            for (var i = 0, n = b.vars.length; i < n; ++i) {\r\n                var v = b.vars[i];\r\n                v.offset += dist;\r\n                this.addVariable(v);\r\n            }\r\n            this.posn = this.ps.getPosn();\r\n        }\r\n\r\n        cost(): number {\r\n            var sum = 0, i = this.vars.length;\r\n            while (i--) {\r\n                var v = this.vars[i],\r\n                    d = v.position() - v.desiredPosition;\r\n                sum += d * d * v.weight;\r\n            }\r\n            return sum;\r\n        }\r\n\r\n/* DEBUG\r\n        toString(): string {\r\n            var cs = [];\r\n            this.traverse(c=> c.toString() + \"\\n\", cs)\r\n            return \"b\"+this.blockInd + \"@\" + this.posn + \": vars=\" + this.vars.map(v=> v.toString()+\":\"+v.offset) + \";\\n cons=\\n\" + cs;\r\n        }\r\nDEBUG */\r\n    }\r\n\r\n    export class Blocks {\r\n        private list: Block[];\r\n\r\n        constructor(public vs: Variable[]) {\r\n            var n = vs.length;\r\n            this.list = new Array(n);\r\n            while (n--) {\r\n                var b = new Block(vs[n]);\r\n                this.list[n] = b;\r\n                b.blockInd = n;\r\n            }\r\n        }\r\n\r\n        cost(): number {\r\n            var sum = 0, i = this.list.length;\r\n            while (i--) sum += this.list[i].cost();\r\n            return sum;\r\n        }\r\n\r\n        insert(b: Block) {\r\n/* DEBUG\r\n            console.assert(!this.contains(b), \"blocks error: tried to reinsert block \" + b.blockInd)\r\nDEBUG */\r\n            b.blockInd = this.list.length;\r\n            this.list.push(b);\r\n/* DEBUG\r\n            console.log(\"insert block: \" + b.blockInd);\r\n            this.contains(b);\r\nDEBUG */\r\n        }\r\n\r\n        remove(b: Block) {\r\n/* DEBUG\r\n            console.log(\"remove block: \" + b.blockInd);\r\n            console.assert(this.contains(b));\r\nDEBUG */\r\n            var last = this.list.length - 1;\r\n            var swapBlock = this.list[last];\r\n            this.list.length = last;\r\n            if (b !== swapBlock) {\r\n                this.list[b.blockInd] = swapBlock;\r\n                swapBlock.blockInd = b.blockInd;\r\n/* DEBUG\r\n                console.assert(this.contains(swapBlock));\r\nDEBUG */\r\n            }\r\n        }\r\n\r\n        // merge the blocks on either side of the specified constraint, by copying the smaller block into the larger\r\n        // and deleting the smaller.\r\n        merge(c: Constraint): void {\r\n            var l = c.left.block, r = c.right.block;\r\n/* DEBUG\r\n            console.assert(l!==r, \"attempt to merge within the same block\");\r\nDEBUG */\r\n            var dist = c.right.offset - c.left.offset - c.gap;\r\n            if (l.vars.length < r.vars.length) {\r\n                r.mergeAcross(l, c, dist);\r\n                this.remove(l);\r\n            } else {\r\n                l.mergeAcross(r, c, -dist);\r\n                this.remove(r);\r\n            }\r\n/* DEBUG\r\n            console.assert(Math.abs(c.slack()) < 1e-6, \"Error: Constraint should be at equality after merge!\");\r\n            console.log(\"merged on \" + c);\r\nDEBUG */\r\n        }\r\n\r\n        forEach(f: (b: Block, i: number) => void ) {\r\n            this.list.forEach(f);\r\n        }\r\n\r\n        // useful, for example, after variable desired positions change.\r\n        updateBlockPositions(): void {\r\n            this.list.forEach(b=> b.updateWeightedPosition());\r\n        }\r\n\r\n        // split each block across its constraint with the minimum lagrangian\r\n        split(inactive: Constraint[]): void {\r\n            this.updateBlockPositions();\r\n            this.list.forEach(b=> {\r\n                var v = b.findMinLM();\r\n                if (v !== null && v.lm < Solver.LAGRANGIAN_TOLERANCE) {\r\n                    b = v.left.block;\r\n                    Block.split(v).forEach(nb=>this.insert(nb));\r\n                    this.remove(b);\r\n                    inactive.push(v);\r\n/* DEBUG\r\n                    console.assert(this.contains(v.left.block));\r\n                    console.assert(this.contains(v.right.block));\r\nDEBUG */\r\n                }\r\n            });\r\n        }\r\n\r\n/* DEBUG\r\n        // checks b is in the block, and does a sanity check over list index integrity\r\n        contains(b: Block): boolean {\r\n            var result = false;\r\n            this.list.forEach((bb, i) => {\r\n                if (bb.blockInd !== i) {\r\n                    console.error(\"blocks error, blockInd \" + b.blockInd + \" found at \" + i);\r\n                    return false;\r\n                }\r\n                result = result || b === bb;\r\n            });\r\n            return result;\r\n        }\r\n\r\n        toString(): string {\r\n            return this.list.toString();\r\n        }\r\nDEBUG */\r\n    }\r\n\r\n    export class Solver {\r\n        bs: Blocks;\r\n        inactive: Constraint[];\r\n\r\n        static LAGRANGIAN_TOLERANCE = -1e-4;\r\n        static ZERO_UPPERBOUND = -1e-10;\r\n\r\n        constructor(public vs: Variable[], public cs: Constraint[]) {\r\n            this.vs = vs;\r\n            vs.forEach(v => {\r\n                v.cIn = [], v.cOut = [];\r\n/* DEBUG\r\n                v.toString = () => \"v\" + vs.indexOf(v);\r\nDEBUG */\r\n            });\r\n            this.cs = cs;\r\n            cs.forEach(c => {\r\n                c.left.cOut.push(c);\r\n                c.right.cIn.push(c);\r\n/* DEBUG\r\n                c.toString = () => c.left + \"+\" + c.gap + \"<=\" + c.right + \" slack=\" + c.slack() + \" active=\" + c.active;\r\nDEBUG */\r\n            });\r\n            this.inactive = cs.map(c=> { c.active = false; return c; });\r\n            this.bs = null;\r\n        }\r\n\r\n        cost(): number {\r\n            return this.bs.cost();\r\n        }\r\n\r\n        // set starting positions without changing desired positions.\r\n        // Note: it throws away any previous block structure.\r\n        setStartingPositions(ps: number[]): void {\r\n            this.inactive = this.cs.map(c=> { c.active = false; return c; });\r\n            this.bs = new Blocks(this.vs);\r\n            this.bs.forEach((b, i) => b.posn = ps[i]);\r\n        }\r\n\r\n        setDesiredPositions(ps: number[]): void {\r\n            this.vs.forEach((v, i) => v.desiredPosition = ps[i]);\r\n        }\r\n\r\n/* DEBUG\r\n        private getId(v: Variable): number {\r\n            return this.vs.indexOf(v);\r\n        }\r\n\r\n        // sanity check of the index integrity of the inactive list\r\n        checkInactive(): void {\r\n            var inactiveCount = 0;\r\n            this.cs.forEach(c=> {\r\n                var i = this.inactive.indexOf(c);\r\n                console.assert(!c.active && i >= 0 || c.active && i < 0, \"constraint should be in the inactive list if it is not active: \" + c);\r\n                if (i >= 0) {\r\n                    inactiveCount++;\r\n                } else {\r\n                    console.assert(c.active, \"inactive constraint not found in inactive list: \" + c);\r\n                }\r\n            });\r\n            console.assert(inactiveCount === this.inactive.length, inactiveCount + \" inactive constraints found, \" + this.inactive.length + \"in inactive list\");\r\n        }\r\n        // after every call to satisfy the following should check should pass\r\n        checkSatisfied(): void {\r\n            this.cs.forEach(c=>console.assert(c.slack() >= vpsc.Solver.ZERO_UPPERBOUND, \"Error: Unsatisfied constraint! \"+c));\r\n        }\r\nDEBUG */\r\n\r\n        private mostViolated(): Constraint {\r\n            var minSlack = Number.MAX_VALUE,\r\n                v: Constraint = null,\r\n                l = this.inactive,\r\n                n = l.length,\r\n                deletePoint = n;\r\n            for (var i = 0; i < n; ++i) {\r\n                var c = l[i];\r\n                if (c.unsatisfiable) continue;\r\n                var slack = c.slack();\r\n                if (c.equality || slack < minSlack) {\r\n                    minSlack = slack;\r\n                    v = c;\r\n                    deletePoint = i;\r\n                    if (c.equality) break;\r\n                }\r\n            }\r\n            if (deletePoint !== n &&\r\n                (minSlack < Solver.ZERO_UPPERBOUND && !v.active || v.equality))\r\n            {\r\n                l[deletePoint] = l[n - 1];\r\n                l.length = n - 1;\r\n            }\r\n            return v;\r\n        }\r\n\r\n        // satisfy constraints by building block structure over violated constraints\r\n        // and moving the blocks to their desired positions\r\n        satisfy(): void {\r\n            if (this.bs == null) {\r\n                this.bs = new Blocks(this.vs);\r\n            }\r\n/* DEBUG\r\n            console.log(\"satisfy: \" + this.bs);\r\nDEBUG */\r\n            this.bs.split(this.inactive);\r\n            var v: Constraint = null;\r\n            while ((v = this.mostViolated()) && (v.equality || v.slack() < Solver.ZERO_UPPERBOUND && !v.active)) {\r\n                var lb = v.left.block, rb = v.right.block;\r\n/* DEBUG\r\n                console.log(\"most violated is: \" + v);\r\n                this.bs.contains(lb);\r\n                this.bs.contains(rb);\r\nDEBUG */\r\n                if (lb !== rb) {\r\n                    this.bs.merge(v);\r\n                } else {\r\n                    if (lb.isActiveDirectedPathBetween(v.right, v.left)) {\r\n                        // cycle found!\r\n                        v.unsatisfiable = true;\r\n                        continue;\r\n                    }\r\n                    // constraint is within block, need to split first\r\n                    var split = lb.splitBetween(v.left, v.right);\r\n                    if (split !== null) {\r\n                        this.bs.insert(split.lb);\r\n                        this.bs.insert(split.rb);\r\n                        this.bs.remove(lb);\r\n                        this.inactive.push(split.constraint);\r\n                    } else {\r\n/* DEBUG\r\n                        console.log(\"unsatisfiable constraint found\");\r\nDEBUG */\r\n                        v.unsatisfiable = true;\r\n                        continue;\r\n                    }\r\n                    if (v.slack() >= 0) {\r\n/* DEBUG\r\n                        console.log(\"violated constraint indirectly satisfied: \" + v);\r\nDEBUG */\r\n                        // v was satisfied by the above split!\r\n                        this.inactive.push(v);\r\n                    } else {\r\n/* DEBUG\r\n                        console.log(\"merge after split:\");\r\nDEBUG */\r\n                        this.bs.merge(v);\r\n                    }\r\n                }\r\n/* DEBUG\r\n                this.bs.contains(v.left.block);\r\n                this.bs.contains(v.right.block);\r\n                this.checkInactive();\r\nDEBUG */\r\n            }\r\n/* DEBUG\r\n            this.checkSatisfied();\r\nDEBUG */\r\n        }\r\n\r\n        // repeatedly build and split block structure until we converge to an optimal solution\r\n        solve(): number {\r\n            this.satisfy();\r\n            var lastcost = Number.MAX_VALUE, cost = this.bs.cost();\r\n            while (Math.abs(lastcost - cost) > 0.0001) {\r\n                this.satisfy();\r\n                lastcost = cost;\r\n                cost = this.bs.cost();\r\n            }\r\n            return cost;\r\n        }\r\n    }\r\n    /**\r\n      * Remove overlap between spans while keeping their centers as close as possible to the specified desiredCenters.\r\n      * Lower and upper bounds will be respected if the spans physically fit between them\r\n      * (otherwise they'll be moved and their new position returned).\r\n      * If no upper/lower bound is specified then the bounds of the moved spans will be returned.\r\n      * returns a new center for each span.\r\n      */\r\n    export function removeOverlapInOneDimension(spans: { size: number, desiredCenter: number }[], lowerBound?: number, upperBound?: number)\r\n        : { newCenters: number[], lowerBound: number, upperBound: number }\r\n    {\r\n        const vs: Variable[] = spans.map(s => new Variable(s.desiredCenter));\r\n        const cs: Constraint[] = [];\r\n        const n = spans.length;\r\n        for (var i = 0; i < n - 1; i++) {\r\n            const left = spans[i], right = spans[i + 1];\r\n            cs.push(new Constraint(vs[i], vs[i + 1], (left.size + right.size) / 2));\r\n        }\r\n        const leftMost = vs[0],\r\n            rightMost = vs[n - 1],\r\n            leftMostSize = spans[0].size / 2,\r\n            rightMostSize = spans[n - 1].size / 2;\r\n        let vLower: Variable = null, vUpper: Variable = null;\r\n        if (lowerBound) {\r\n            vLower = new Variable(lowerBound, leftMost.weight * 1000);\r\n            vs.push(vLower);\r\n            cs.push(new Constraint(vLower, leftMost, leftMostSize));\r\n        }\r\n        if (upperBound) {\r\n            vUpper = new Variable(upperBound, rightMost.weight * 1000);\r\n            vs.push(vUpper);\r\n            cs.push(new Constraint(rightMost, vUpper, rightMostSize));\r\n        }\r\n        var solver = new Solver(vs, cs);\r\n        solver.solve();\r\n        return {\r\n            newCenters: vs.slice(0, spans.length).map(v => v.position()),\r\n            lowerBound: vLower ? vLower.position() : leftMost.position() - leftMostSize,\r\n            upperBound: vUpper ? vUpper.position() : rightMost.position() + rightMostSize\r\n        };\r\n    }\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}