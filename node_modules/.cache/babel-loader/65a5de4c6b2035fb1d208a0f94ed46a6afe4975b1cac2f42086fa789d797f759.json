{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar rectangle_1 = require(\"./rectangle\");\nvar vpsc_1 = require(\"./vpsc\");\nvar shortestpaths_1 = require(\"./shortestpaths\");\nvar NodeWrapper = function () {\n  function NodeWrapper(id, rect, children) {\n    this.id = id;\n    this.rect = rect;\n    this.children = children;\n    this.leaf = typeof children === 'undefined' || children.length === 0;\n  }\n  return NodeWrapper;\n}();\nexports.NodeWrapper = NodeWrapper;\nvar Vert = function () {\n  function Vert(id, x, y, node, line) {\n    if (node === void 0) {\n      node = null;\n    }\n    if (line === void 0) {\n      line = null;\n    }\n    this.id = id;\n    this.x = x;\n    this.y = y;\n    this.node = node;\n    this.line = line;\n  }\n  return Vert;\n}();\nexports.Vert = Vert;\nvar LongestCommonSubsequence = function () {\n  function LongestCommonSubsequence(s, t) {\n    this.s = s;\n    this.t = t;\n    var mf = LongestCommonSubsequence.findMatch(s, t);\n    var tr = t.slice(0).reverse();\n    var mr = LongestCommonSubsequence.findMatch(s, tr);\n    if (mf.length >= mr.length) {\n      this.length = mf.length;\n      this.si = mf.si;\n      this.ti = mf.ti;\n      this.reversed = false;\n    } else {\n      this.length = mr.length;\n      this.si = mr.si;\n      this.ti = t.length - mr.ti - mr.length;\n      this.reversed = true;\n    }\n  }\n  LongestCommonSubsequence.findMatch = function (s, t) {\n    var m = s.length;\n    var n = t.length;\n    var match = {\n      length: 0,\n      si: -1,\n      ti: -1\n    };\n    var l = new Array(m);\n    for (var i = 0; i < m; i++) {\n      l[i] = new Array(n);\n      for (var j = 0; j < n; j++) if (s[i] === t[j]) {\n        var v = l[i][j] = i === 0 || j === 0 ? 1 : l[i - 1][j - 1] + 1;\n        if (v > match.length) {\n          match.length = v;\n          match.si = i - v + 1;\n          match.ti = j - v + 1;\n        }\n        ;\n      } else l[i][j] = 0;\n    }\n    return match;\n  };\n  LongestCommonSubsequence.prototype.getSequence = function () {\n    return this.length >= 0 ? this.s.slice(this.si, this.si + this.length) : [];\n  };\n  return LongestCommonSubsequence;\n}();\nexports.LongestCommonSubsequence = LongestCommonSubsequence;\nvar GridRouter = function () {\n  function GridRouter(originalnodes, accessor, groupPadding) {\n    var _this = this;\n    if (groupPadding === void 0) {\n      groupPadding = 12;\n    }\n    this.originalnodes = originalnodes;\n    this.groupPadding = groupPadding;\n    this.leaves = null;\n    this.nodes = originalnodes.map(function (v, i) {\n      return new NodeWrapper(i, accessor.getBounds(v), accessor.getChildren(v));\n    });\n    this.leaves = this.nodes.filter(function (v) {\n      return v.leaf;\n    });\n    this.groups = this.nodes.filter(function (g) {\n      return !g.leaf;\n    });\n    this.cols = this.getGridLines('x');\n    this.rows = this.getGridLines('y');\n    this.groups.forEach(function (v) {\n      return v.children.forEach(function (c) {\n        return _this.nodes[c].parent = v;\n      });\n    });\n    this.root = {\n      children: []\n    };\n    this.nodes.forEach(function (v) {\n      if (typeof v.parent === 'undefined') {\n        v.parent = _this.root;\n        _this.root.children.push(v.id);\n      }\n      v.ports = [];\n    });\n    this.backToFront = this.nodes.slice(0);\n    this.backToFront.sort(function (x, y) {\n      return _this.getDepth(x) - _this.getDepth(y);\n    });\n    var frontToBackGroups = this.backToFront.slice(0).reverse().filter(function (g) {\n      return !g.leaf;\n    });\n    frontToBackGroups.forEach(function (v) {\n      var r = rectangle_1.Rectangle.empty();\n      v.children.forEach(function (c) {\n        return r = r.union(_this.nodes[c].rect);\n      });\n      v.rect = r.inflate(_this.groupPadding);\n    });\n    var colMids = this.midPoints(this.cols.map(function (r) {\n      return r.pos;\n    }));\n    var rowMids = this.midPoints(this.rows.map(function (r) {\n      return r.pos;\n    }));\n    var rowx = colMids[0],\n      rowX = colMids[colMids.length - 1];\n    var coly = rowMids[0],\n      colY = rowMids[rowMids.length - 1];\n    var hlines = this.rows.map(function (r) {\n      return {\n        x1: rowx,\n        x2: rowX,\n        y1: r.pos,\n        y2: r.pos\n      };\n    }).concat(rowMids.map(function (m) {\n      return {\n        x1: rowx,\n        x2: rowX,\n        y1: m,\n        y2: m\n      };\n    }));\n    var vlines = this.cols.map(function (c) {\n      return {\n        x1: c.pos,\n        x2: c.pos,\n        y1: coly,\n        y2: colY\n      };\n    }).concat(colMids.map(function (m) {\n      return {\n        x1: m,\n        x2: m,\n        y1: coly,\n        y2: colY\n      };\n    }));\n    var lines = hlines.concat(vlines);\n    lines.forEach(function (l) {\n      return l.verts = [];\n    });\n    this.verts = [];\n    this.edges = [];\n    hlines.forEach(function (h) {\n      return vlines.forEach(function (v) {\n        var p = new Vert(_this.verts.length, v.x1, h.y1);\n        h.verts.push(p);\n        v.verts.push(p);\n        _this.verts.push(p);\n        var i = _this.backToFront.length;\n        while (i-- > 0) {\n          var node = _this.backToFront[i],\n            r = node.rect;\n          var dx = Math.abs(p.x - r.cx()),\n            dy = Math.abs(p.y - r.cy());\n          if (dx < r.width() / 2 && dy < r.height() / 2) {\n            p.node = node;\n            break;\n          }\n        }\n      });\n    });\n    lines.forEach(function (l, li) {\n      _this.nodes.forEach(function (v, i) {\n        v.rect.lineIntersections(l.x1, l.y1, l.x2, l.y2).forEach(function (intersect, j) {\n          var p = new Vert(_this.verts.length, intersect.x, intersect.y, v, l);\n          _this.verts.push(p);\n          l.verts.push(p);\n          v.ports.push(p);\n        });\n      });\n      var isHoriz = Math.abs(l.y1 - l.y2) < 0.1;\n      var delta = function (a, b) {\n        return isHoriz ? b.x - a.x : b.y - a.y;\n      };\n      l.verts.sort(delta);\n      for (var i = 1; i < l.verts.length; i++) {\n        var u = l.verts[i - 1],\n          v = l.verts[i];\n        if (u.node && u.node === v.node && u.node.leaf) continue;\n        _this.edges.push({\n          source: u.id,\n          target: v.id,\n          length: Math.abs(delta(u, v))\n        });\n      }\n    });\n  }\n  GridRouter.prototype.avg = function (a) {\n    return a.reduce(function (x, y) {\n      return x + y;\n    }) / a.length;\n  };\n  GridRouter.prototype.getGridLines = function (axis) {\n    var columns = [];\n    var ls = this.leaves.slice(0, this.leaves.length);\n    while (ls.length > 0) {\n      var overlapping = ls.filter(function (v) {\n        return v.rect['overlap' + axis.toUpperCase()](ls[0].rect);\n      });\n      var col = {\n        nodes: overlapping,\n        pos: this.avg(overlapping.map(function (v) {\n          return v.rect['c' + axis]();\n        }))\n      };\n      columns.push(col);\n      col.nodes.forEach(function (v) {\n        return ls.splice(ls.indexOf(v), 1);\n      });\n    }\n    columns.sort(function (a, b) {\n      return a.pos - b.pos;\n    });\n    return columns;\n  };\n  GridRouter.prototype.getDepth = function (v) {\n    var depth = 0;\n    while (v.parent !== this.root) {\n      depth++;\n      v = v.parent;\n    }\n    return depth;\n  };\n  GridRouter.prototype.midPoints = function (a) {\n    var gap = a[1] - a[0];\n    var mids = [a[0] - gap / 2];\n    for (var i = 1; i < a.length; i++) {\n      mids.push((a[i] + a[i - 1]) / 2);\n    }\n    mids.push(a[a.length - 1] + gap / 2);\n    return mids;\n  };\n  GridRouter.prototype.findLineage = function (v) {\n    var lineage = [v];\n    do {\n      v = v.parent;\n      lineage.push(v);\n    } while (v !== this.root);\n    return lineage.reverse();\n  };\n  GridRouter.prototype.findAncestorPathBetween = function (a, b) {\n    var aa = this.findLineage(a),\n      ba = this.findLineage(b),\n      i = 0;\n    while (aa[i] === ba[i]) i++;\n    return {\n      commonAncestor: aa[i - 1],\n      lineages: aa.slice(i).concat(ba.slice(i))\n    };\n  };\n  GridRouter.prototype.siblingObstacles = function (a, b) {\n    var _this = this;\n    var path = this.findAncestorPathBetween(a, b);\n    var lineageLookup = {};\n    path.lineages.forEach(function (v) {\n      return lineageLookup[v.id] = {};\n    });\n    var obstacles = path.commonAncestor.children.filter(function (v) {\n      return !(v in lineageLookup);\n    });\n    path.lineages.filter(function (v) {\n      return v.parent !== path.commonAncestor;\n    }).forEach(function (v) {\n      return obstacles = obstacles.concat(v.parent.children.filter(function (c) {\n        return c !== v.id;\n      }));\n    });\n    return obstacles.map(function (v) {\n      return _this.nodes[v];\n    });\n  };\n  GridRouter.getSegmentSets = function (routes, x, y) {\n    var vsegments = [];\n    for (var ei = 0; ei < routes.length; ei++) {\n      var route = routes[ei];\n      for (var si = 0; si < route.length; si++) {\n        var s = route[si];\n        s.edgeid = ei;\n        s.i = si;\n        var sdx = s[1][x] - s[0][x];\n        if (Math.abs(sdx) < 0.1) {\n          vsegments.push(s);\n        }\n      }\n    }\n    vsegments.sort(function (a, b) {\n      return a[0][x] - b[0][x];\n    });\n    var vsegmentsets = [];\n    var segmentset = null;\n    for (var i = 0; i < vsegments.length; i++) {\n      var s = vsegments[i];\n      if (!segmentset || Math.abs(s[0][x] - segmentset.pos) > 0.1) {\n        segmentset = {\n          pos: s[0][x],\n          segments: []\n        };\n        vsegmentsets.push(segmentset);\n      }\n      segmentset.segments.push(s);\n    }\n    return vsegmentsets;\n  };\n  GridRouter.nudgeSegs = function (x, y, routes, segments, leftOf, gap) {\n    var n = segments.length;\n    if (n <= 1) return;\n    var vs = segments.map(function (s) {\n      return new vpsc_1.Variable(s[0][x]);\n    });\n    var cs = [];\n    for (var i = 0; i < n; i++) {\n      for (var j = 0; j < n; j++) {\n        if (i === j) continue;\n        var s1 = segments[i],\n          s2 = segments[j],\n          e1 = s1.edgeid,\n          e2 = s2.edgeid,\n          lind = -1,\n          rind = -1;\n        if (x == 'x') {\n          if (leftOf(e1, e2)) {\n            if (s1[0][y] < s1[1][y]) {\n              lind = j, rind = i;\n            } else {\n              lind = i, rind = j;\n            }\n          }\n        } else {\n          if (leftOf(e1, e2)) {\n            if (s1[0][y] < s1[1][y]) {\n              lind = i, rind = j;\n            } else {\n              lind = j, rind = i;\n            }\n          }\n        }\n        if (lind >= 0) {\n          cs.push(new vpsc_1.Constraint(vs[lind], vs[rind], gap));\n        }\n      }\n    }\n    var solver = new vpsc_1.Solver(vs, cs);\n    solver.solve();\n    vs.forEach(function (v, i) {\n      var s = segments[i];\n      var pos = v.position();\n      s[0][x] = s[1][x] = pos;\n      var route = routes[s.edgeid];\n      if (s.i > 0) route[s.i - 1][1][x] = pos;\n      if (s.i < route.length - 1) route[s.i + 1][0][x] = pos;\n    });\n  };\n  GridRouter.nudgeSegments = function (routes, x, y, leftOf, gap) {\n    var vsegmentsets = GridRouter.getSegmentSets(routes, x, y);\n    for (var i = 0; i < vsegmentsets.length; i++) {\n      var ss = vsegmentsets[i];\n      var events = [];\n      for (var j = 0; j < ss.segments.length; j++) {\n        var s = ss.segments[j];\n        events.push({\n          type: 0,\n          s: s,\n          pos: Math.min(s[0][y], s[1][y])\n        });\n        events.push({\n          type: 1,\n          s: s,\n          pos: Math.max(s[0][y], s[1][y])\n        });\n      }\n      events.sort(function (a, b) {\n        return a.pos - b.pos + a.type - b.type;\n      });\n      var open = [];\n      var openCount = 0;\n      events.forEach(function (e) {\n        if (e.type === 0) {\n          open.push(e.s);\n          openCount++;\n        } else {\n          openCount--;\n        }\n        if (openCount == 0) {\n          GridRouter.nudgeSegs(x, y, routes, open, leftOf, gap);\n          open = [];\n        }\n      });\n    }\n  };\n  GridRouter.prototype.routeEdges = function (edges, nudgeGap, source, target) {\n    var _this = this;\n    var routePaths = edges.map(function (e) {\n      return _this.route(source(e), target(e));\n    });\n    var order = GridRouter.orderEdges(routePaths);\n    var routes = routePaths.map(function (e) {\n      return GridRouter.makeSegments(e);\n    });\n    GridRouter.nudgeSegments(routes, 'x', 'y', order, nudgeGap);\n    GridRouter.nudgeSegments(routes, 'y', 'x', order, nudgeGap);\n    GridRouter.unreverseEdges(routes, routePaths);\n    return routes;\n  };\n  GridRouter.unreverseEdges = function (routes, routePaths) {\n    routes.forEach(function (segments, i) {\n      var path = routePaths[i];\n      if (path.reversed) {\n        segments.reverse();\n        segments.forEach(function (segment) {\n          segment.reverse();\n        });\n      }\n    });\n  };\n  GridRouter.angleBetween2Lines = function (line1, line2) {\n    var angle1 = Math.atan2(line1[0].y - line1[1].y, line1[0].x - line1[1].x);\n    var angle2 = Math.atan2(line2[0].y - line2[1].y, line2[0].x - line2[1].x);\n    var diff = angle1 - angle2;\n    if (diff > Math.PI || diff < -Math.PI) {\n      diff = angle2 - angle1;\n    }\n    return diff;\n  };\n  GridRouter.isLeft = function (a, b, c) {\n    return (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x) <= 0;\n  };\n  GridRouter.getOrder = function (pairs) {\n    var outgoing = {};\n    for (var i = 0; i < pairs.length; i++) {\n      var p = pairs[i];\n      if (typeof outgoing[p.l] === 'undefined') outgoing[p.l] = {};\n      outgoing[p.l][p.r] = true;\n    }\n    return function (l, r) {\n      return typeof outgoing[l] !== 'undefined' && outgoing[l][r];\n    };\n  };\n  GridRouter.orderEdges = function (edges) {\n    var edgeOrder = [];\n    for (var i = 0; i < edges.length - 1; i++) {\n      for (var j = i + 1; j < edges.length; j++) {\n        var e = edges[i],\n          f = edges[j],\n          lcs = new LongestCommonSubsequence(e, f);\n        var u, vi, vj;\n        if (lcs.length === 0) continue;\n        if (lcs.reversed) {\n          f.reverse();\n          f.reversed = true;\n          lcs = new LongestCommonSubsequence(e, f);\n        }\n        if ((lcs.si <= 0 || lcs.ti <= 0) && (lcs.si + lcs.length >= e.length || lcs.ti + lcs.length >= f.length)) {\n          edgeOrder.push({\n            l: i,\n            r: j\n          });\n          continue;\n        }\n        if (lcs.si + lcs.length >= e.length || lcs.ti + lcs.length >= f.length) {\n          u = e[lcs.si + 1];\n          vj = e[lcs.si - 1];\n          vi = f[lcs.ti - 1];\n        } else {\n          u = e[lcs.si + lcs.length - 2];\n          vi = e[lcs.si + lcs.length];\n          vj = f[lcs.ti + lcs.length];\n        }\n        if (GridRouter.isLeft(u, vi, vj)) {\n          edgeOrder.push({\n            l: j,\n            r: i\n          });\n        } else {\n          edgeOrder.push({\n            l: i,\n            r: j\n          });\n        }\n      }\n    }\n    return GridRouter.getOrder(edgeOrder);\n  };\n  GridRouter.makeSegments = function (path) {\n    function copyPoint(p) {\n      return {\n        x: p.x,\n        y: p.y\n      };\n    }\n    var isStraight = function (a, b, c) {\n      return Math.abs((b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x)) < 0.001;\n    };\n    var segments = [];\n    var a = copyPoint(path[0]);\n    for (var i = 1; i < path.length; i++) {\n      var b = copyPoint(path[i]),\n        c = i < path.length - 1 ? path[i + 1] : null;\n      if (!c || !isStraight(a, b, c)) {\n        segments.push([a, b]);\n        a = b;\n      }\n    }\n    return segments;\n  };\n  GridRouter.prototype.route = function (s, t) {\n    var _this = this;\n    var source = this.nodes[s],\n      target = this.nodes[t];\n    this.obstacles = this.siblingObstacles(source, target);\n    var obstacleLookup = {};\n    this.obstacles.forEach(function (o) {\n      return obstacleLookup[o.id] = o;\n    });\n    this.passableEdges = this.edges.filter(function (e) {\n      var u = _this.verts[e.source],\n        v = _this.verts[e.target];\n      return !(u.node && u.node.id in obstacleLookup || v.node && v.node.id in obstacleLookup);\n    });\n    for (var i = 1; i < source.ports.length; i++) {\n      var u = source.ports[0].id;\n      var v = source.ports[i].id;\n      this.passableEdges.push({\n        source: u,\n        target: v,\n        length: 0\n      });\n    }\n    for (var i = 1; i < target.ports.length; i++) {\n      var u = target.ports[0].id;\n      var v = target.ports[i].id;\n      this.passableEdges.push({\n        source: u,\n        target: v,\n        length: 0\n      });\n    }\n    var getSource = function (e) {\n        return e.source;\n      },\n      getTarget = function (e) {\n        return e.target;\n      },\n      getLength = function (e) {\n        return e.length;\n      };\n    var shortestPathCalculator = new shortestpaths_1.Calculator(this.verts.length, this.passableEdges, getSource, getTarget, getLength);\n    var bendPenalty = function (u, v, w) {\n      var a = _this.verts[u],\n        b = _this.verts[v],\n        c = _this.verts[w];\n      var dx = Math.abs(c.x - a.x),\n        dy = Math.abs(c.y - a.y);\n      if (a.node === source && a.node === b.node || b.node === target && b.node === c.node) return 0;\n      return dx > 1 && dy > 1 ? 1000 : 0;\n    };\n    var shortestPath = shortestPathCalculator.PathFromNodeToNodeWithPrevCost(source.ports[0].id, target.ports[0].id, bendPenalty);\n    var pathPoints = shortestPath.reverse().map(function (vi) {\n      return _this.verts[vi];\n    });\n    pathPoints.push(this.nodes[target.id].ports[0]);\n    return pathPoints.filter(function (v, i) {\n      return !(i < pathPoints.length - 1 && pathPoints[i + 1].node === source && v.node === source || i > 0 && v.node === target && pathPoints[i - 1].node === target);\n    });\n  };\n  GridRouter.getRoutePath = function (route, cornerradius, arrowwidth, arrowheight) {\n    var result = {\n      routepath: 'M ' + route[0][0].x + ' ' + route[0][0].y + ' ',\n      arrowpath: ''\n    };\n    if (route.length > 1) {\n      for (var i = 0; i < route.length; i++) {\n        var li = route[i];\n        var x = li[1].x,\n          y = li[1].y;\n        var dx = x - li[0].x;\n        var dy = y - li[0].y;\n        if (i < route.length - 1) {\n          if (Math.abs(dx) > 0) {\n            x -= dx / Math.abs(dx) * cornerradius;\n          } else {\n            y -= dy / Math.abs(dy) * cornerradius;\n          }\n          result.routepath += 'L ' + x + ' ' + y + ' ';\n          var l = route[i + 1];\n          var x0 = l[0].x,\n            y0 = l[0].y;\n          var x1 = l[1].x;\n          var y1 = l[1].y;\n          dx = x1 - x0;\n          dy = y1 - y0;\n          var angle = GridRouter.angleBetween2Lines(li, l) < 0 ? 1 : 0;\n          var x2, y2;\n          if (Math.abs(dx) > 0) {\n            x2 = x0 + dx / Math.abs(dx) * cornerradius;\n            y2 = y0;\n          } else {\n            x2 = x0;\n            y2 = y0 + dy / Math.abs(dy) * cornerradius;\n          }\n          var cx = Math.abs(x2 - x);\n          var cy = Math.abs(y2 - y);\n          result.routepath += 'A ' + cx + ' ' + cy + ' 0 0 ' + angle + ' ' + x2 + ' ' + y2 + ' ';\n        } else {\n          var arrowtip = [x, y];\n          var arrowcorner1, arrowcorner2;\n          if (Math.abs(dx) > 0) {\n            x -= dx / Math.abs(dx) * arrowheight;\n            arrowcorner1 = [x, y + arrowwidth];\n            arrowcorner2 = [x, y - arrowwidth];\n          } else {\n            y -= dy / Math.abs(dy) * arrowheight;\n            arrowcorner1 = [x + arrowwidth, y];\n            arrowcorner2 = [x - arrowwidth, y];\n          }\n          result.routepath += 'L ' + x + ' ' + y + ' ';\n          if (arrowheight > 0) {\n            result.arrowpath = 'M ' + arrowtip[0] + ' ' + arrowtip[1] + ' L ' + arrowcorner1[0] + ' ' + arrowcorner1[1] + ' L ' + arrowcorner2[0] + ' ' + arrowcorner2[1];\n          }\n        }\n      }\n    } else {\n      var li = route[0];\n      var x = li[1].x,\n        y = li[1].y;\n      var dx = x - li[0].x;\n      var dy = y - li[0].y;\n      var arrowtip = [x, y];\n      var arrowcorner1, arrowcorner2;\n      if (Math.abs(dx) > 0) {\n        x -= dx / Math.abs(dx) * arrowheight;\n        arrowcorner1 = [x, y + arrowwidth];\n        arrowcorner2 = [x, y - arrowwidth];\n      } else {\n        y -= dy / Math.abs(dy) * arrowheight;\n        arrowcorner1 = [x + arrowwidth, y];\n        arrowcorner2 = [x - arrowwidth, y];\n      }\n      result.routepath += 'L ' + x + ' ' + y + ' ';\n      if (arrowheight > 0) {\n        result.arrowpath = 'M ' + arrowtip[0] + ' ' + arrowtip[1] + ' L ' + arrowcorner1[0] + ' ' + arrowcorner1[1] + ' L ' + arrowcorner2[0] + ' ' + arrowcorner2[1];\n      }\n    }\n    return result;\n  };\n  return GridRouter;\n}();\nexports.GridRouter = GridRouter;","map":{"version":3,"names":["rectangle_1","require","vpsc_1","shortestpaths_1","NodeWrapper","id","rect","children","leaf","length","exports","Vert","x","y","node","line","LongestCommonSubsequence","s","t","mf","findMatch","tr","slice","reverse","mr","si","ti","reversed","m","n","match","l","Array","i","j","v","prototype","getSequence","GridRouter","originalnodes","accessor","groupPadding","_this","leaves","nodes","map","getBounds","getChildren","filter","groups","g","cols","getGridLines","rows","forEach","c","parent","root","push","ports","backToFront","sort","getDepth","frontToBackGroups","r","Rectangle","empty","union","inflate","colMids","midPoints","pos","rowMids","rowx","rowX","coly","colY","hlines","x1","x2","y1","y2","concat","vlines","lines","verts","edges","h","p","dx","Math","abs","cx","dy","cy","width","height","li","lineIntersections","intersect","isHoriz","delta","a","b","u","source","target","avg","reduce","axis","columns","ls","overlapping","toUpperCase","col","splice","indexOf","depth","gap","mids","findLineage","lineage","findAncestorPathBetween","aa","ba","commonAncestor","lineages","siblingObstacles","path","lineageLookup","obstacles","getSegmentSets","routes","vsegments","ei","route","edgeid","sdx","vsegmentsets","segmentset","segments","nudgeSegs","leftOf","vs","Variable","cs","s1","s2","e1","e2","lind","rind","Constraint","solver","Solver","solve","position","nudgeSegments","ss","events","type","min","max","open","openCount","e","routeEdges","nudgeGap","routePaths","order","orderEdges","makeSegments","unreverseEdges","segment","angleBetween2Lines","line1","line2","angle1","atan2","angle2","diff","PI","isLeft","getOrder","pairs","outgoing","edgeOrder","f","lcs","vi","vj","copyPoint","isStraight","obstacleLookup","o","passableEdges","getSource","getTarget","getLength","shortestPathCalculator","Calculator","bendPenalty","w","shortestPath","PathFromNodeToNodeWithPrevCost","pathPoints","getRoutePath","cornerradius","arrowwidth","arrowheight","result","routepath","arrowpath","x0","y0","angle","arrowtip","arrowcorner1","arrowcorner2"],"sources":["/Users/brucemcdougall/go/jalapeno-github/jalapeno-ui/node_modules/webcola/WebCola/src/gridrouter.ts"],"sourcesContent":["import {Point} from './geom'\r\nimport {Rectangle} from './rectangle'\r\nimport {Constraint, Solver, Variable} from './vpsc'\r\nimport {Calculator} from './shortestpaths'\r\n    export interface NodeAccessor<Node>{\r\n        getChildren(v:Node) : number[];\r\n        getBounds(v:Node) : Rectangle;\r\n    }\r\n    export class NodeWrapper {\r\n        leaf: boolean;\r\n        parent: NodeWrapper;\r\n        ports: Vert[];\r\n        constructor(public id: number, public rect: Rectangle, public children: number[]) {\r\n            this.leaf = typeof children === 'undefined' || children.length === 0;\r\n        }\r\n    }\r\n    export class Vert {\r\n        constructor(public id: number, public x:number, public y: number, public node: NodeWrapper = null, public line = null) {}\r\n    }\r\n\r\n    export class LongestCommonSubsequence<T> {\r\n        length: number;\r\n        si: number;\r\n        ti: number;\r\n        reversed: boolean;\r\n        constructor(public s: T[], public t: T[]) {\r\n            var mf = LongestCommonSubsequence.findMatch(s, t);\r\n            var tr = t.slice(0).reverse();\r\n            var mr = LongestCommonSubsequence.findMatch(s, tr);\r\n            if (mf.length >= mr.length) {\r\n                this.length = mf.length;\r\n                this.si = mf.si;\r\n                this.ti = mf.ti;\r\n                this.reversed = false;\r\n            } else {\r\n                this.length = mr.length;\r\n                this.si = mr.si;\r\n                this.ti = t.length - mr.ti - mr.length;\r\n                this.reversed = true;\r\n            }\r\n        }\r\n        private static findMatch<T>(s: T[], t: T[]) {\r\n            var m = s.length;\r\n            var n = t.length;\r\n            var match = { length: 0, si: -1, ti: -1 };\r\n            var l = new Array(m);\r\n            for (var i = 0; i < m; i++) {\r\n                l[i] = new Array(n);\r\n                for (var j = 0; j < n; j++)\r\n                    if (s[i] === t[j]) {\r\n                        var v = l[i][j] = (i === 0 || j === 0) ? 1 : l[i - 1][j - 1] + 1;\r\n                        if (v > match.length) {\r\n                            match.length = v;\r\n                            match.si = i - v + 1;\r\n                            match.ti = j - v + 1;\r\n                        };\r\n                    } else l[i][j] = 0;\r\n            }\r\n            return match;\r\n        }\r\n        getSequence(): T[]{\r\n            return this.length >= 0 ? this.s.slice(this.si, this.si + this.length) : [];\r\n        }\r\n    }\r\n    // a horizontal or vertical line of nodes\r\n    export interface GridLine {\r\n        nodes: NodeWrapper[];\r\n        pos: number;\r\n    }\r\n    export class GridRouter<Node> {\r\n        leaves: NodeWrapper[] = null;\r\n        groups: NodeWrapper[];\r\n        nodes: NodeWrapper[];\r\n        cols: GridLine[];\r\n        rows: GridLine[];\r\n        root;\r\n        verts: Vert[];\r\n        edges;\r\n        backToFront;\r\n        obstacles;\r\n        passableEdges;\r\n        private avg(a) { return a.reduce((x, y) => x + y) / a.length }\r\n\r\n        // in the given axis, find sets of leaves overlapping in that axis\r\n        // center of each GridLine is average of all nodes in column\r\n        private getGridLines(axis): GridLine[] {\r\n            var columns = [];\r\n            var ls = this.leaves.slice(0, this.leaves.length);\r\n            while (ls.length > 0) {\r\n                // find a column of all leaves overlapping in axis with the first leaf\r\n                let overlapping = ls.filter(v=> v.rect['overlap' + axis.toUpperCase()](ls[0].rect));\r\n                let col = {\r\n                    nodes: overlapping,\r\n                    pos: this.avg(overlapping.map(v=> v.rect['c' + axis]()))\r\n                };\r\n                columns.push(col);\r\n                col.nodes.forEach(v=> ls.splice(ls.indexOf(v), 1));\r\n            }\r\n            columns.sort((a, b) => a.pos - b.pos)\r\n            return columns;\r\n        }\r\n\r\n        // get the depth of the given node in the group hierarchy\r\n        private getDepth(v) {\r\n            var depth = 0;\r\n            while (v.parent !== this.root) {\r\n                depth++;\r\n                v = v.parent;\r\n            }\r\n            return depth;\r\n        }\r\n\r\n        // medial axes between node centres and also boundary lines for the grid\r\n        private midPoints(a) {\r\n            var gap = a[1] - a[0];\r\n            var mids = [a[0] - gap / 2];\r\n            for (var i = 1; i < a.length; i++) {\r\n                mids.push((a[i] + a[i - 1]) / 2);\r\n            }\r\n            mids.push(a[a.length - 1] + gap / 2);\r\n            return mids;\r\n        }\r\n\r\n        constructor(public originalnodes: Node[], accessor: NodeAccessor<Node>, public groupPadding: number = 12) {\r\n            this.nodes = originalnodes.map((v, i) => new NodeWrapper(i, accessor.getBounds(v), accessor.getChildren(v)));\r\n            this.leaves = this.nodes.filter(v=> v.leaf);\r\n            this.groups = this.nodes.filter(g=> !g.leaf);\r\n            this.cols = this.getGridLines('x');\r\n            this.rows = this.getGridLines('y');\r\n\r\n            // create parents for each node or group that is a member of another's children\r\n            this.groups.forEach(v=>\r\n                v.children.forEach(c=> this.nodes[<number>c].parent = v));\r\n\r\n            // root claims the remaining orphans\r\n            this.root = { children: [] };\r\n            this.nodes.forEach(v=> {\r\n                if (typeof v.parent === 'undefined') {\r\n                    v.parent = this.root;\r\n                    this.root.children.push(v.id);\r\n                }\r\n\r\n                // each node will have grid vertices associated with it,\r\n                // some inside the node and some on the boundary\r\n                // leaf nodes will have exactly one internal node at the center\r\n                // and four boundary nodes\r\n                // groups will have potentially many of each\r\n                v.ports = []\r\n            });\r\n\r\n            // nodes ordered by their position in the group hierarchy\r\n            this.backToFront = this.nodes.slice(0);\r\n            this.backToFront.sort((x, y) => this.getDepth(x) - this.getDepth(y));\r\n\r\n            // compute boundary rectangles for each group\r\n            // has to be done from front to back, i.e. inside groups to outside groups\r\n            // such that each can be made large enough to enclose its interior\r\n            var frontToBackGroups = this.backToFront.slice(0).reverse().filter(g=> !g.leaf);\r\n            frontToBackGroups.forEach(v=> {\r\n                var r = Rectangle.empty();\r\n                v.children.forEach(c=> r = r.union(this.nodes[c].rect));\r\n                v.rect = r.inflate(this.groupPadding);\r\n            });\r\n\r\n            var colMids = this.midPoints(this.cols.map(r=> r.pos));\r\n            var rowMids = this.midPoints(this.rows.map(r=> r.pos));\r\n\r\n            // setup extents of lines\r\n            var rowx = colMids[0], rowX = colMids[colMids.length - 1];\r\n            var coly = rowMids[0], colY = rowMids[rowMids.length - 1];\r\n\r\n            // horizontal lines\r\n            var hlines = this.rows.map(r=> <any>{ x1: rowx, x2: rowX, y1: r.pos, y2: r.pos })\r\n                .concat(rowMids.map(m=> <any>{ x1: rowx, x2: rowX, y1: m, y2: m }));\r\n\r\n            // vertical lines\r\n            var vlines = this.cols.map(c=> <any>{ x1: c.pos, x2: c.pos, y1: coly, y2: colY })\r\n                .concat(colMids.map(m=> <any>{ x1: m, x2: m, y1: coly, y2: colY }));\r\n\r\n            // the full set of lines\r\n            var lines = hlines.concat(vlines);\r\n\r\n            // we record the vertices associated with each line\r\n            lines.forEach(l=> l.verts = []);\r\n\r\n            // the routing graph\r\n            this.verts = [];\r\n            this.edges = [];\r\n\r\n            // create vertices at the crossings of horizontal and vertical grid-lines\r\n            hlines.forEach(h=>\r\n                vlines.forEach(v=> {\r\n                    var p = new Vert(this.verts.length, v.x1, h.y1);\r\n                    h.verts.push(p);\r\n                    v.verts.push(p);\r\n                    this.verts.push(p);\r\n\r\n                    // assign vertices to the nodes immediately under them\r\n                    var i = this.backToFront.length;\r\n                    while (i-- > 0) {\r\n                        var node = this.backToFront[i],\r\n                            r = node.rect;\r\n                        var dx = Math.abs(p.x - r.cx()),\r\n                            dy = Math.abs(p.y - r.cy());\r\n                        if (dx < r.width() / 2 && dy < r.height() / 2) {\r\n                            (<any>p).node = node;\r\n                            break;\r\n                        }\r\n                    }\r\n                })\r\n                );\r\n\r\n            lines.forEach((l, li) => {\r\n                // create vertices at the intersections of nodes and lines\r\n                this.nodes.forEach((v, i) => {\r\n                    v.rect.lineIntersections(l.x1, l.y1, l.x2, l.y2).forEach((intersect, j) => {\r\n                        //console.log(li+','+i+','+j+':'+intersect.x + ',' + intersect.y);\r\n                        var p = new Vert(this.verts.length, intersect.x, intersect.y, v, l);\r\n                        this.verts.push(p);\r\n                        l.verts.push(p);\r\n                        v.ports.push(p);\r\n                    });\r\n                });\r\n\r\n                // split lines into edges joining vertices\r\n                var isHoriz = Math.abs(l.y1 - l.y2) < 0.1;\r\n                var delta = (a, b) => isHoriz ? b.x - a.x : b.y - a.y;\r\n                l.verts.sort(delta);\r\n                for (var i = 1; i < l.verts.length; i++) {\r\n                    var u = l.verts[i - 1], v = l.verts[i];\r\n                    if (u.node && u.node === v.node && u.node.leaf) continue;\r\n                    this.edges.push({ source: u.id, target: v.id, length: Math.abs(delta(u, v)) });\r\n                }\r\n            });\r\n\r\n\r\n\r\n        }\r\n\r\n        // find path from v to root including both v and root\r\n        private findLineage(v) {\r\n            var lineage = [v];\r\n            do {\r\n                v = v.parent;\r\n                lineage.push(v);\r\n            } while (v !== this.root);\r\n            return lineage.reverse();\r\n        }\r\n\r\n        // find path connecting a and b through their lowest common ancestor\r\n        private findAncestorPathBetween(a, b) {\r\n            var aa = this.findLineage(a), ba = this.findLineage(b), i = 0;\r\n            while (aa[i] === ba[i]) i++;\r\n            // i-1 to include common ancestor only once (as first element)\r\n            return { commonAncestor: aa[i - 1], lineages: aa.slice(i).concat(ba.slice(i)) };\r\n        }\r\n\r\n        // when finding a path between two nodes a and b, siblings of a and b on the\r\n        // paths from a and b to their least common ancestor are obstacles\r\n        siblingObstacles(a, b) {\r\n            var path = this.findAncestorPathBetween(a, b);\r\n            var lineageLookup = {};\r\n            path.lineages.forEach(v=> lineageLookup[v.id] = {});\r\n            var obstacles = path.commonAncestor.children.filter(v=> !(v in lineageLookup));\r\n\r\n            path.lineages\r\n                .filter(v=> v.parent !== path.commonAncestor)\r\n                .forEach(v=> obstacles = obstacles.concat(v.parent.children.filter(c=> c !== v.id)));\r\n\r\n            return obstacles.map(v=> this.nodes[v]);\r\n        }\r\n\r\n        // for the given routes, extract all the segments orthogonal to the axis x\r\n        // and return all them grouped by x position\r\n        static getSegmentSets(routes, x, y) {\r\n            // vsegments is a list of vertical segments sorted by x position\r\n            var vsegments = [];\r\n            for (var ei = 0; ei < routes.length; ei++) {\r\n                var route = routes[ei];\r\n                for (var si = 0; si < route.length; si++) {\r\n                    var s = <any>route[si];\r\n                    s.edgeid = ei;\r\n                    s.i = si;\r\n                    var sdx = s[1][x] - s[0][x];\r\n                    if (Math.abs(sdx) < 0.1) {\r\n                        vsegments.push(s);\r\n                    }\r\n                }\r\n            }\r\n            vsegments.sort((a, b) => a[0][x] - b[0][x]);\r\n\r\n            // vsegmentsets is a set of sets of segments grouped by x position\r\n            var vsegmentsets = [];\r\n            var segmentset = null;\r\n            for (var i = 0; i < vsegments.length; i++) {\r\n                var s = vsegments[i];\r\n                if (!segmentset || Math.abs(s[0][x] - segmentset.pos) > 0.1) {\r\n                    segmentset = { pos: s[0][x], segments: [] };\r\n                    vsegmentsets.push(segmentset);\r\n                }\r\n                segmentset.segments.push(s);\r\n            }\r\n            return vsegmentsets;\r\n        }\r\n\r\n        // for all segments in this bundle create a vpsc problem such that\r\n        // each segment's x position is a variable and separation constraints\r\n        // are given by the partial order over the edges to which the segments belong\r\n        // for each pair s1,s2 of segments in the open set:\r\n        //   e1 = edge of s1, e2 = edge of s2\r\n        //   if leftOf(e1,e2) create constraint s1.x + gap <= s2.x\r\n        //   else if leftOf(e2,e1) create cons. s2.x + gap <= s1.x\r\n        static nudgeSegs(x: string, y: string, routes, segments, leftOf, gap: number) {\r\n            var n = segments.length;\r\n            if (n <= 1) return;\r\n            var vs = segments.map(s => new Variable(s[0][x]));\r\n            var cs = [];\r\n            for (var i = 0; i < n; i++) {\r\n                for (var j = 0; j < n; j++) {\r\n                    if (i === j) continue;\r\n                    var s1 = segments[i],\r\n                        s2 = segments[j],\r\n                        e1 = s1.edgeid,\r\n                        e2 = s2.edgeid,\r\n                        lind = -1,\r\n                        rind = -1;\r\n                    // in page coordinates (not cartesian) the notion of 'leftof' is flipped in the horizontal axis from the vertical axis\r\n                    // that is, when nudging vertical segments, if they increase in the y(conj) direction the segment belonging to the\r\n                    // 'left' edge actually needs to be nudged to the right\r\n                    // when nudging horizontal segments, if the segments increase in the x direction\r\n                    // then the 'left' segment needs to go higher, i.e. to have y pos less than that of the right\r\n                    if (x == 'x') {\r\n                        if (leftOf(e1, e2)) {\r\n                            //console.log('s1: ' + s1[0][x] + ',' + s1[0][y] + '-' + s1[1][x] + ',' + s1[1][y]);\r\n                            if (s1[0][y] < s1[1][y]) {\r\n                                lind = j, rind = i;\r\n                            } else {\r\n                                lind = i, rind = j;\r\n                            }\r\n                        }\r\n                    } else {\r\n                        if (leftOf(e1, e2)) {\r\n                            if (s1[0][y] < s1[1][y]) {\r\n                                lind = i, rind = j;\r\n                            } else {\r\n                                lind = j, rind = i;\r\n                            }\r\n                        }\r\n                    }\r\n                    if (lind >= 0) {\r\n                        //console.log(x+' constraint: ' + lind + '<' + rind);\r\n                        cs.push(new Constraint(vs[lind], vs[rind], gap));\r\n                    }\r\n                }\r\n            }\r\n            var solver = new Solver(vs, cs);\r\n            solver.solve();\r\n            vs.forEach((v, i) => {\r\n                var s = segments[i];\r\n                var pos = v.position();\r\n                s[0][x] = s[1][x] = pos;\r\n                var route = routes[s.edgeid];\r\n                if (s.i > 0) route[s.i - 1][1][x] = pos;\r\n                if (s.i < route.length - 1) route[s.i + 1][0][x] = pos;\r\n            });\r\n        }\r\n\r\n        static nudgeSegments(routes, x: string, y: string, leftOf: (e1: number, e2: number) => boolean, gap: number) {\r\n            var vsegmentsets = GridRouter.getSegmentSets(routes, x, y);\r\n            // scan the grouped (by x) segment sets to find co-linear bundles\r\n            for (var i = 0; i < vsegmentsets.length; i++) {\r\n                var ss = vsegmentsets[i];\r\n                var events = [];\r\n                for (var j = 0; j < ss.segments.length; j++) {\r\n                    var s = ss.segments[j];\r\n                    events.push({ type: 0, s: s, pos: Math.min(s[0][y], s[1][y]) });\r\n                    events.push({ type: 1, s: s, pos: Math.max(s[0][y], s[1][y]) });\r\n                }\r\n                events.sort((a, b) => a.pos - b.pos + a.type - b.type);\r\n                var open = [];\r\n                var openCount = 0;\r\n                events.forEach(e=> {\r\n                    if (e.type === 0) {\r\n                        open.push(e.s);\r\n                        openCount++;\r\n                    } else {\r\n                        openCount--;\r\n                    }\r\n                    if (openCount == 0) {\r\n                        GridRouter.nudgeSegs(x, y, routes, open, leftOf, gap);\r\n                        open = [];\r\n                    }\r\n                });\r\n            }\r\n        }\r\n\r\n        // obtain routes for the specified edges, nicely nudged apart\r\n        // warning: edge paths may be reversed such that common paths are ordered consistently within bundles!\r\n        // @param edges list of edges\r\n        // @param nudgeGap how much to space parallel edge segements\r\n        // @param source function to retrieve the index of the source node for a given edge\r\n        // @param target function to retrieve the index of the target node for a given edge\r\n        // @returns an array giving, for each edge, an array of segments, each segment a pair of points in an array\r\n        routeEdges<Edge>(edges: Edge[], nudgeGap: number, source: (e: Edge) => number, target: (e: Edge) => number): Point[][][] {\r\n            var routePaths = edges.map(e=> this.route(source(e), target(e)));\r\n            var order = GridRouter.orderEdges(routePaths);\r\n            var routes = routePaths.map(function (e) { return GridRouter.makeSegments(e); });\r\n            GridRouter.nudgeSegments(routes, 'x', 'y', order, nudgeGap);\r\n            GridRouter.nudgeSegments(routes, 'y', 'x', order, nudgeGap);\r\n            GridRouter.unreverseEdges(routes, routePaths);\r\n            return routes;\r\n        }\r\n\r\n        // path may have been reversed by the subsequence processing in orderEdges\r\n        // so now we need to restore the original order\r\n        static unreverseEdges(routes, routePaths) {\r\n            routes.forEach((segments, i) => {\r\n                var path = routePaths[i];\r\n                if ((<any>path).reversed) {\r\n                    segments.reverse(); // reverse order of segments\r\n                    segments.forEach(function (segment) {\r\n                        segment.reverse();  // reverse each segment\r\n                    });\r\n                }\r\n            });\r\n        }\r\n\r\n        static angleBetween2Lines(line1: Point[], line2: Point[]): number {\r\n            var angle1 = Math.atan2(line1[0].y - line1[1].y,\r\n                line1[0].x - line1[1].x);\r\n            var angle2 = Math.atan2(line2[0].y - line2[1].y,\r\n                line2[0].x - line2[1].x);\r\n            var diff = angle1 - angle2;\r\n            if (diff > Math.PI || diff < -Math.PI) {\r\n                diff = angle2 - angle1;\r\n            }\r\n            return diff;\r\n        }\r\n\r\n        // does the path a-b-c describe a left turn?\r\n        private static isLeft(a, b, c) {\r\n            return ((b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x)) <= 0;\r\n        }\r\n\r\n        // for the given list of ordered pairs, returns a function that (efficiently) looks-up a specific pair to\r\n        // see if it exists in the list\r\n        private static getOrder(pairs: { l: number; r: number }[]): (l: number, r: number) => boolean {\r\n            var outgoing = {};\r\n            for (var i = 0; i < pairs.length; i++) {\r\n                var p = pairs[i];\r\n                if (typeof outgoing[p.l] === 'undefined') outgoing[p.l] = {};\r\n                outgoing[p.l][p.r] = true;\r\n            }\r\n            return (l, r) => typeof outgoing[l] !== 'undefined' && outgoing[l][r];\r\n        }\r\n\r\n        // returns an ordering (a lookup function) that determines the correct order to nudge the\r\n        // edge paths apart to minimize crossings\r\n        static orderEdges(edges) {\r\n            var edgeOrder = [];\r\n            for (var i = 0; i < edges.length - 1; i++) {\r\n                for (var j = i + 1; j < edges.length; j++) {\r\n                    var e = edges[i],\r\n                        f = edges[j],\r\n                        lcs = new LongestCommonSubsequence(e, f);\r\n                    var u, vi, vj;\r\n                    if (lcs.length === 0)\r\n                        continue; // no common subpath\r\n                    if (lcs.reversed) {\r\n                        // if we found a common subpath but one of the edges runs the wrong way,\r\n                        // then reverse f.\r\n                        f.reverse();\r\n                        f.reversed = true;\r\n                        lcs = new LongestCommonSubsequence(e, f);\r\n                    }\r\n                    if ((lcs.si <= 0 || lcs.ti <= 0) &&\r\n                        (lcs.si + lcs.length >= e.length || lcs.ti + lcs.length >= f.length)) {\r\n                        // the paths do not diverge, so make an arbitrary ordering decision\r\n                        edgeOrder.push({ l: i, r: j });\r\n                        continue;\r\n                    }\r\n                    if (lcs.si + lcs.length >= e.length || lcs.ti + lcs.length >= f.length) {\r\n                        // if the common subsequence of the\r\n                        // two edges being considered goes all the way to the\r\n                        // end of one (or both) of the lines then we have to\r\n                        // base our ordering decision on the other end of the\r\n                        // common subsequence\r\n                        u = e[lcs.si + 1];\r\n                        vj = e[lcs.si - 1];\r\n                        vi = f[lcs.ti - 1];\r\n                    } else {\r\n                        u = e[lcs.si + lcs.length - 2];\r\n                        vi = e[lcs.si + lcs.length];\r\n                        vj = f[lcs.ti + lcs.length];\r\n                    }\r\n                    if (GridRouter.isLeft(u, vi, vj)) {\r\n                        edgeOrder.push({ l: j, r: i });\r\n                    } else {\r\n                        edgeOrder.push({ l: i, r: j });\r\n                    }\r\n                }\r\n            }\r\n            //edgeOrder.forEach(function (e) { console.log('l:' + e.l + ',r:' + e.r) });\r\n            return GridRouter.getOrder(edgeOrder);\r\n        }\r\n\r\n        // for an orthogonal path described by a sequence of points, create a list of segments\r\n        // if consecutive segments would make a straight line they are merged into a single segment\r\n        // segments are over cloned points, not the original vertices\r\n        static makeSegments(path: Point[]): Point[][] {\r\n            function copyPoint(p: Point) {\r\n                return <Point>{ x: p.x, y: p.y };\r\n            }\r\n            var isStraight = (a, b, c) => Math.abs((b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x)) < 0.001;\r\n            var segments = [];\r\n            var a = copyPoint(path[0]);\r\n            for (var i = 1; i < path.length; i++) {\r\n                var b = copyPoint(path[i]), c = i < path.length - 1 ? path[i + 1] : null;\r\n                if (!c || !isStraight(a, b, c)) {\r\n                    segments.push([a, b]);\r\n                    a = b;\r\n                }\r\n            }\r\n            return segments;\r\n        }\r\n\r\n        // find a route between node s and node t\r\n        // returns an array of indices to verts\r\n        route(s: number, t: number): Point[] {\r\n            var source = this.nodes[<number>s], target = this.nodes[<number>t];\r\n            this.obstacles = this.siblingObstacles(source, target);\r\n\r\n            var obstacleLookup = {};\r\n            this.obstacles.forEach(o => obstacleLookup[o.id] = o);\r\n            this.passableEdges = this.edges.filter(e=> {\r\n                var u = this.verts[e.source],\r\n                    v = this.verts[e.target];\r\n                return !(u.node && u.node.id in obstacleLookup\r\n                    || v.node && v.node.id in obstacleLookup);\r\n            });\r\n\r\n            // add dummy segments linking ports inside source and target\r\n            for (var i = 1; i < source.ports.length; i++) {\r\n                var u = source.ports[0].id;\r\n                var v = source.ports[i].id;\r\n                this.passableEdges.push({\r\n                    source: u,\r\n                    target: v,\r\n                    length: 0\r\n                });\r\n            }\r\n            for (var i = 1; i < target.ports.length; i++) {\r\n                var u = target.ports[0].id;\r\n                var v = target.ports[i].id;\r\n                this.passableEdges.push({\r\n                    source: u,\r\n                    target: v,\r\n                    length: 0\r\n                });\r\n            }\r\n\r\n            var getSource = e=> e.source,\r\n                getTarget = e=> e.target,\r\n                getLength = e=> e.length;\r\n\r\n            var shortestPathCalculator = new Calculator(this.verts.length, this.passableEdges, getSource, getTarget, getLength);\r\n            var bendPenalty = (u, v, w) => {\r\n                var a = this.verts[u], b = this.verts[v], c = this.verts[w];\r\n                var dx = Math.abs(c.x - a.x), dy = Math.abs(c.y - a.y);\r\n                // don't count bends from internal node edges\r\n                if (a.node === source && a.node === b.node || b.node === target && b.node === c.node)\r\n                    return 0;\r\n                return dx > 1 && dy > 1 ? 1000 : 0;\r\n            };\r\n\r\n            // get shortest path\r\n            var shortestPath = shortestPathCalculator.PathFromNodeToNodeWithPrevCost(\r\n                source.ports[0].id, target.ports[0].id,\r\n                bendPenalty);\r\n\r\n            // shortest path is reversed and does not include the target port\r\n            var pathPoints = shortestPath.reverse().map(vi => this.verts[vi]);\r\n            pathPoints.push(this.nodes[target.id].ports[0]);\r\n\r\n            // filter out any extra end points that are inside the source or target (i.e. the dummy segments above)\r\n            return pathPoints.filter((v, i) =>\r\n                !(i < pathPoints.length - 1 && pathPoints[i + 1].node === source && v.node === source\r\n                    || i > 0 && v.node === target && pathPoints[i - 1].node === target));\r\n        }\r\n\r\n        static getRoutePath(route: Point[][], cornerradius: number, arrowwidth: number, arrowheight: number): { routepath: string; arrowpath: string } {\r\n            var result = {\r\n                routepath: 'M ' + route[0][0].x + ' ' + route[0][0].y + ' ',\r\n                arrowpath: ''\r\n            };\r\n            if (route.length > 1) {\r\n                for (var i = 0; i < route.length; i++) {\r\n                    var li = route[i];\r\n                    var x = li[1].x, y = li[1].y;\r\n                    var dx = x - li[0].x;\r\n                    var dy = y - li[0].y;\r\n                    if (i < route.length - 1) {\r\n                        if (Math.abs(dx) > 0) {\r\n                            x -= dx / Math.abs(dx) * cornerradius;\r\n                        } else {\r\n                            y -= dy / Math.abs(dy) * cornerradius;\r\n                        }\r\n                        result.routepath += 'L ' + x + ' ' + y + ' ';\r\n                        var l = route[i + 1];\r\n                        var x0 = l[0].x, y0 = l[0].y;\r\n                        var x1 = l[1].x;\r\n                        var y1 = l[1].y;\r\n                        dx = x1 - x0;\r\n                        dy = y1 - y0;\r\n                        var angle = GridRouter.angleBetween2Lines(li, l) < 0 ? 1 : 0;\r\n                        //console.log(cola.GridRouter.angleBetween2Lines(li, l))\r\n                        var x2, y2;\r\n                        if (Math.abs(dx) > 0) {\r\n                            x2 = x0 + dx / Math.abs(dx) * cornerradius;\r\n                            y2 = y0;\r\n                        } else {\r\n                            x2 = x0;\r\n                            y2 = y0 + dy / Math.abs(dy) * cornerradius;\r\n                        }\r\n                        var cx = Math.abs(x2 - x);\r\n                        var cy = Math.abs(y2 - y);\r\n                        result.routepath += 'A ' + cx + ' ' + cy + ' 0 0 ' + angle + ' ' + x2 + ' ' + y2 + ' ';\r\n                    } else {\r\n                        var arrowtip = [x, y];\r\n                        var arrowcorner1, arrowcorner2;\r\n                        if (Math.abs(dx) > 0) {\r\n                            x -= dx / Math.abs(dx) * arrowheight;\r\n                            arrowcorner1 = [x, y + arrowwidth];\r\n                            arrowcorner2 = [x, y - arrowwidth];\r\n                        } else {\r\n                            y -= dy / Math.abs(dy) * arrowheight;\r\n                            arrowcorner1 = [x + arrowwidth, y];\r\n                            arrowcorner2 = [x - arrowwidth, y];\r\n                        }\r\n                        result.routepath += 'L ' + x + ' ' + y + ' ';\r\n                        if (arrowheight > 0) {\r\n                            result.arrowpath = 'M ' + arrowtip[0] + ' ' + arrowtip[1] + ' L ' + arrowcorner1[0] + ' ' + arrowcorner1[1]\r\n                            + ' L ' + arrowcorner2[0] + ' ' + arrowcorner2[1];\r\n                        }\r\n                    }\r\n                }\r\n            } else {\r\n                var li = route[0];\r\n                var x = li[1].x, y = li[1].y;\r\n                var dx = x - li[0].x;\r\n                var dy = y - li[0].y;\r\n                var arrowtip = [x, y];\r\n                var arrowcorner1, arrowcorner2;\r\n                if (Math.abs(dx) > 0) {\r\n                    x -= dx / Math.abs(dx) * arrowheight;\r\n                    arrowcorner1 = [x, y + arrowwidth];\r\n                    arrowcorner2 = [x, y - arrowwidth];\r\n                } else {\r\n                    y -= dy / Math.abs(dy) * arrowheight;\r\n                    arrowcorner1 = [x + arrowwidth, y];\r\n                    arrowcorner2 = [x - arrowwidth, y];\r\n                }\r\n                result.routepath += 'L ' + x + ' ' + y + ' ';\r\n                if (arrowheight > 0) {\r\n                    result.arrowpath = 'M ' + arrowtip[0] + ' ' + arrowtip[1] + ' L ' + arrowcorner1[0] + ' ' + arrowcorner1[1]\r\n                    + ' L ' + arrowcorner2[0] + ' ' + arrowcorner2[1];\r\n                }\r\n            }\r\n            return result;\r\n        }\r\n    }\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}