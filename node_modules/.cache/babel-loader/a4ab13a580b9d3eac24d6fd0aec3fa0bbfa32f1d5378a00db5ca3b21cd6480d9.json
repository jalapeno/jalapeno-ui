{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar rectangle_1 = require(\"./rectangle\");\nvar Point = function () {\n  function Point() {}\n  return Point;\n}();\nexports.Point = Point;\nvar LineSegment = function () {\n  function LineSegment(x1, y1, x2, y2) {\n    this.x1 = x1;\n    this.y1 = y1;\n    this.x2 = x2;\n    this.y2 = y2;\n  }\n  return LineSegment;\n}();\nexports.LineSegment = LineSegment;\nvar PolyPoint = function (_super) {\n  __extends(PolyPoint, _super);\n  function PolyPoint() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  return PolyPoint;\n}(Point);\nexports.PolyPoint = PolyPoint;\nfunction isLeft(P0, P1, P2) {\n  return (P1.x - P0.x) * (P2.y - P0.y) - (P2.x - P0.x) * (P1.y - P0.y);\n}\nexports.isLeft = isLeft;\nfunction above(p, vi, vj) {\n  return isLeft(p, vi, vj) > 0;\n}\nfunction below(p, vi, vj) {\n  return isLeft(p, vi, vj) < 0;\n}\nfunction ConvexHull(S) {\n  var P = S.slice(0).sort(function (a, b) {\n    return a.x !== b.x ? b.x - a.x : b.y - a.y;\n  });\n  var n = S.length,\n    i;\n  var minmin = 0;\n  var xmin = P[0].x;\n  for (i = 1; i < n; ++i) {\n    if (P[i].x !== xmin) break;\n  }\n  var minmax = i - 1;\n  var H = [];\n  H.push(P[minmin]);\n  if (minmax === n - 1) {\n    if (P[minmax].y !== P[minmin].y) H.push(P[minmax]);\n  } else {\n    var maxmin,\n      maxmax = n - 1;\n    var xmax = P[n - 1].x;\n    for (i = n - 2; i >= 0; i--) if (P[i].x !== xmax) break;\n    maxmin = i + 1;\n    i = minmax;\n    while (++i <= maxmin) {\n      if (isLeft(P[minmin], P[maxmin], P[i]) >= 0 && i < maxmin) continue;\n      while (H.length > 1) {\n        if (isLeft(H[H.length - 2], H[H.length - 1], P[i]) > 0) break;else H.length -= 1;\n      }\n      if (i != minmin) H.push(P[i]);\n    }\n    if (maxmax != maxmin) H.push(P[maxmax]);\n    var bot = H.length;\n    i = maxmin;\n    while (--i >= minmax) {\n      if (isLeft(P[maxmax], P[minmax], P[i]) >= 0 && i > minmax) continue;\n      while (H.length > bot) {\n        if (isLeft(H[H.length - 2], H[H.length - 1], P[i]) > 0) break;else H.length -= 1;\n      }\n      if (i != minmin) H.push(P[i]);\n    }\n  }\n  return H;\n}\nexports.ConvexHull = ConvexHull;\nfunction clockwiseRadialSweep(p, P, f) {\n  P.slice(0).sort(function (a, b) {\n    return Math.atan2(a.y - p.y, a.x - p.x) - Math.atan2(b.y - p.y, b.x - p.x);\n  }).forEach(f);\n}\nexports.clockwiseRadialSweep = clockwiseRadialSweep;\nfunction nextPolyPoint(p, ps) {\n  if (p.polyIndex === ps.length - 1) return ps[0];\n  return ps[p.polyIndex + 1];\n}\nfunction prevPolyPoint(p, ps) {\n  if (p.polyIndex === 0) return ps[ps.length - 1];\n  return ps[p.polyIndex - 1];\n}\nfunction tangent_PointPolyC(P, V) {\n  var Vclosed = V.slice(0);\n  Vclosed.push(V[0]);\n  return {\n    rtan: Rtangent_PointPolyC(P, Vclosed),\n    ltan: Ltangent_PointPolyC(P, Vclosed)\n  };\n}\nfunction Rtangent_PointPolyC(P, V) {\n  var n = V.length - 1;\n  var a, b, c;\n  var upA, dnC;\n  if (below(P, V[1], V[0]) && !above(P, V[n - 1], V[0])) return 0;\n  for (a = 0, b = n;;) {\n    if (b - a === 1) if (above(P, V[a], V[b])) return a;else return b;\n    c = Math.floor((a + b) / 2);\n    dnC = below(P, V[c + 1], V[c]);\n    if (dnC && !above(P, V[c - 1], V[c])) return c;\n    upA = above(P, V[a + 1], V[a]);\n    if (upA) {\n      if (dnC) b = c;else {\n        if (above(P, V[a], V[c])) b = c;else a = c;\n      }\n    } else {\n      if (!dnC) a = c;else {\n        if (below(P, V[a], V[c])) b = c;else a = c;\n      }\n    }\n  }\n}\nfunction Ltangent_PointPolyC(P, V) {\n  var n = V.length - 1;\n  var a, b, c;\n  var dnA, dnC;\n  if (above(P, V[n - 1], V[0]) && !below(P, V[1], V[0])) return 0;\n  for (a = 0, b = n;;) {\n    if (b - a === 1) if (below(P, V[a], V[b])) return a;else return b;\n    c = Math.floor((a + b) / 2);\n    dnC = below(P, V[c + 1], V[c]);\n    if (above(P, V[c - 1], V[c]) && !dnC) return c;\n    dnA = below(P, V[a + 1], V[a]);\n    if (dnA) {\n      if (!dnC) b = c;else {\n        if (below(P, V[a], V[c])) b = c;else a = c;\n      }\n    } else {\n      if (dnC) a = c;else {\n        if (above(P, V[a], V[c])) b = c;else a = c;\n      }\n    }\n  }\n}\nfunction tangent_PolyPolyC(V, W, t1, t2, cmp1, cmp2) {\n  var ix1, ix2;\n  ix1 = t1(W[0], V);\n  ix2 = t2(V[ix1], W);\n  var done = false;\n  while (!done) {\n    done = true;\n    while (true) {\n      if (ix1 === V.length - 1) ix1 = 0;\n      if (cmp1(W[ix2], V[ix1], V[ix1 + 1])) break;\n      ++ix1;\n    }\n    while (true) {\n      if (ix2 === 0) ix2 = W.length - 1;\n      if (cmp2(V[ix1], W[ix2], W[ix2 - 1])) break;\n      --ix2;\n      done = false;\n    }\n  }\n  return {\n    t1: ix1,\n    t2: ix2\n  };\n}\nexports.tangent_PolyPolyC = tangent_PolyPolyC;\nfunction LRtangent_PolyPolyC(V, W) {\n  var rl = RLtangent_PolyPolyC(W, V);\n  return {\n    t1: rl.t2,\n    t2: rl.t1\n  };\n}\nexports.LRtangent_PolyPolyC = LRtangent_PolyPolyC;\nfunction RLtangent_PolyPolyC(V, W) {\n  return tangent_PolyPolyC(V, W, Rtangent_PointPolyC, Ltangent_PointPolyC, above, below);\n}\nexports.RLtangent_PolyPolyC = RLtangent_PolyPolyC;\nfunction LLtangent_PolyPolyC(V, W) {\n  return tangent_PolyPolyC(V, W, Ltangent_PointPolyC, Ltangent_PointPolyC, below, below);\n}\nexports.LLtangent_PolyPolyC = LLtangent_PolyPolyC;\nfunction RRtangent_PolyPolyC(V, W) {\n  return tangent_PolyPolyC(V, W, Rtangent_PointPolyC, Rtangent_PointPolyC, above, above);\n}\nexports.RRtangent_PolyPolyC = RRtangent_PolyPolyC;\nvar BiTangent = function () {\n  function BiTangent(t1, t2) {\n    this.t1 = t1;\n    this.t2 = t2;\n  }\n  return BiTangent;\n}();\nexports.BiTangent = BiTangent;\nvar BiTangents = function () {\n  function BiTangents() {}\n  return BiTangents;\n}();\nexports.BiTangents = BiTangents;\nvar TVGPoint = function (_super) {\n  __extends(TVGPoint, _super);\n  function TVGPoint() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  return TVGPoint;\n}(Point);\nexports.TVGPoint = TVGPoint;\nvar VisibilityVertex = function () {\n  function VisibilityVertex(id, polyid, polyvertid, p) {\n    this.id = id;\n    this.polyid = polyid;\n    this.polyvertid = polyvertid;\n    this.p = p;\n    p.vv = this;\n  }\n  return VisibilityVertex;\n}();\nexports.VisibilityVertex = VisibilityVertex;\nvar VisibilityEdge = function () {\n  function VisibilityEdge(source, target) {\n    this.source = source;\n    this.target = target;\n  }\n  VisibilityEdge.prototype.length = function () {\n    var dx = this.source.p.x - this.target.p.x;\n    var dy = this.source.p.y - this.target.p.y;\n    return Math.sqrt(dx * dx + dy * dy);\n  };\n  return VisibilityEdge;\n}();\nexports.VisibilityEdge = VisibilityEdge;\nvar TangentVisibilityGraph = function () {\n  function TangentVisibilityGraph(P, g0) {\n    this.P = P;\n    this.V = [];\n    this.E = [];\n    if (!g0) {\n      var n = P.length;\n      for (var i = 0; i < n; i++) {\n        var p = P[i];\n        for (var j = 0; j < p.length; ++j) {\n          var pj = p[j],\n            vv = new VisibilityVertex(this.V.length, i, j, pj);\n          this.V.push(vv);\n          if (j > 0) this.E.push(new VisibilityEdge(p[j - 1].vv, vv));\n        }\n        if (p.length > 1) this.E.push(new VisibilityEdge(p[0].vv, p[p.length - 1].vv));\n      }\n      for (var i = 0; i < n - 1; i++) {\n        var Pi = P[i];\n        for (var j = i + 1; j < n; j++) {\n          var Pj = P[j],\n            t = tangents(Pi, Pj);\n          for (var q in t) {\n            var c = t[q],\n              source = Pi[c.t1],\n              target = Pj[c.t2];\n            this.addEdgeIfVisible(source, target, i, j);\n          }\n        }\n      }\n    } else {\n      this.V = g0.V.slice(0);\n      this.E = g0.E.slice(0);\n    }\n  }\n  TangentVisibilityGraph.prototype.addEdgeIfVisible = function (u, v, i1, i2) {\n    if (!this.intersectsPolys(new LineSegment(u.x, u.y, v.x, v.y), i1, i2)) {\n      this.E.push(new VisibilityEdge(u.vv, v.vv));\n    }\n  };\n  TangentVisibilityGraph.prototype.addPoint = function (p, i1) {\n    var n = this.P.length;\n    this.V.push(new VisibilityVertex(this.V.length, n, 0, p));\n    for (var i = 0; i < n; ++i) {\n      if (i === i1) continue;\n      var poly = this.P[i],\n        t = tangent_PointPolyC(p, poly);\n      this.addEdgeIfVisible(p, poly[t.ltan], i1, i);\n      this.addEdgeIfVisible(p, poly[t.rtan], i1, i);\n    }\n    return p.vv;\n  };\n  TangentVisibilityGraph.prototype.intersectsPolys = function (l, i1, i2) {\n    for (var i = 0, n = this.P.length; i < n; ++i) {\n      if (i != i1 && i != i2 && intersects(l, this.P[i]).length > 0) {\n        return true;\n      }\n    }\n    return false;\n  };\n  return TangentVisibilityGraph;\n}();\nexports.TangentVisibilityGraph = TangentVisibilityGraph;\nfunction intersects(l, P) {\n  var ints = [];\n  for (var i = 1, n = P.length; i < n; ++i) {\n    var int = rectangle_1.Rectangle.lineIntersection(l.x1, l.y1, l.x2, l.y2, P[i - 1].x, P[i - 1].y, P[i].x, P[i].y);\n    if (int) ints.push(int);\n  }\n  return ints;\n}\nfunction tangents(V, W) {\n  var m = V.length - 1,\n    n = W.length - 1;\n  var bt = new BiTangents();\n  for (var i = 0; i < m; ++i) {\n    for (var j = 0; j < n; ++j) {\n      var v1 = V[i == 0 ? m - 1 : i - 1];\n      var v2 = V[i];\n      var v3 = V[i + 1];\n      var w1 = W[j == 0 ? n - 1 : j - 1];\n      var w2 = W[j];\n      var w3 = W[j + 1];\n      var v1v2w2 = isLeft(v1, v2, w2);\n      var v2w1w2 = isLeft(v2, w1, w2);\n      var v2w2w3 = isLeft(v2, w2, w3);\n      var w1w2v2 = isLeft(w1, w2, v2);\n      var w2v1v2 = isLeft(w2, v1, v2);\n      var w2v2v3 = isLeft(w2, v2, v3);\n      if (v1v2w2 >= 0 && v2w1w2 >= 0 && v2w2w3 < 0 && w1w2v2 >= 0 && w2v1v2 >= 0 && w2v2v3 < 0) {\n        bt.ll = new BiTangent(i, j);\n      } else if (v1v2w2 <= 0 && v2w1w2 <= 0 && v2w2w3 > 0 && w1w2v2 <= 0 && w2v1v2 <= 0 && w2v2v3 > 0) {\n        bt.rr = new BiTangent(i, j);\n      } else if (v1v2w2 <= 0 && v2w1w2 > 0 && v2w2w3 <= 0 && w1w2v2 >= 0 && w2v1v2 < 0 && w2v2v3 >= 0) {\n        bt.rl = new BiTangent(i, j);\n      } else if (v1v2w2 >= 0 && v2w1w2 < 0 && v2w2w3 >= 0 && w1w2v2 <= 0 && w2v1v2 > 0 && w2v2v3 <= 0) {\n        bt.lr = new BiTangent(i, j);\n      }\n    }\n  }\n  return bt;\n}\nexports.tangents = tangents;\nfunction isPointInsidePoly(p, poly) {\n  for (var i = 1, n = poly.length; i < n; ++i) if (below(poly[i - 1], poly[i], p)) return false;\n  return true;\n}\nfunction isAnyPInQ(p, q) {\n  return !p.every(function (v) {\n    return !isPointInsidePoly(v, q);\n  });\n}\nfunction polysOverlap(p, q) {\n  if (isAnyPInQ(p, q)) return true;\n  if (isAnyPInQ(q, p)) return true;\n  for (var i = 1, n = p.length; i < n; ++i) {\n    var v = p[i],\n      u = p[i - 1];\n    if (intersects(new LineSegment(u.x, u.y, v.x, v.y), q).length > 0) return true;\n  }\n  return false;\n}\nexports.polysOverlap = polysOverlap;","map":{"version":3,"names":["rectangle_1","require","Point","exports","LineSegment","x1","y1","x2","y2","PolyPoint","_super","__extends","isLeft","P0","P1","P2","x","y","above","p","vi","vj","below","ConvexHull","S","P","slice","sort","a","b","n","length","i","minmin","xmin","minmax","H","push","maxmin","maxmax","xmax","bot","clockwiseRadialSweep","f","Math","atan2","forEach","nextPolyPoint","ps","polyIndex","prevPolyPoint","tangent_PointPolyC","V","Vclosed","rtan","Rtangent_PointPolyC","ltan","Ltangent_PointPolyC","c","upA","dnC","floor","dnA","tangent_PolyPolyC","W","t1","t2","cmp1","cmp2","ix1","ix2","done","LRtangent_PolyPolyC","rl","RLtangent_PolyPolyC","LLtangent_PolyPolyC","RRtangent_PolyPolyC","BiTangent","BiTangents","TVGPoint","VisibilityVertex","id","polyid","polyvertid","vv","VisibilityEdge","source","target","prototype","dx","dy","sqrt","TangentVisibilityGraph","g0","E","j","pj","Pi","Pj","t","tangents","q","addEdgeIfVisible","u","v","i1","i2","intersectsPolys","addPoint","poly","l","intersects","ints","int","Rectangle","lineIntersection","m","bt","v1","v2","v3","w1","w2","w3","v1v2w2","v2w1w2","v2w2w3","w1w2v2","w2v1v2","w2v2v3","ll","rr","lr","isPointInsidePoly","isAnyPInQ","every","polysOverlap"],"sources":["/Users/brucemcdougall/go/jalapeno-github/jalapeno-ui/node_modules/webcola/WebCola/src/geom.ts"],"sourcesContent":["import {Rectangle} from './rectangle'\r\n    export class Point {\r\n        x: number;\r\n        y: number;\r\n    }\r\n\r\n    export class LineSegment {\r\n        constructor(public x1: number, public y1: number, public x2: number, public y2: number) { }\r\n    }\r\n\r\n    export class PolyPoint extends Point {\r\n        polyIndex: number;\r\n    }\r\n\r\n    /** tests if a point is Left|On|Right of an infinite line.\r\n     * @param points P0, P1, and P2\r\n     * @return >0 for P2 left of the line through P0 and P1\r\n     *            =0 for P2 on the line\r\n     *            <0 for P2 right of the line\r\n     */\r\n    export function isLeft(P0: Point, P1: Point, P2: Point): number {\r\n        return (P1.x - P0.x) * (P2.y - P0.y) - (P2.x - P0.x) * (P1.y - P0.y);\r\n    }\r\n\r\n    function above(p: Point, vi: Point, vj: Point): boolean {\r\n        return isLeft(p, vi, vj) > 0;\r\n    }\r\n\r\n    function below(p: Point, vi: Point, vj: Point): boolean {\r\n        return isLeft(p, vi, vj) < 0;\r\n    }\r\n\r\n\r\n    /**\r\n     * returns the convex hull of a set of points using Andrew's monotone chain algorithm\r\n     * see: http://geomalgorithms.com/a10-_hull-1.html#Monotone%20Chain\r\n     * @param S array of points\r\n     * @return the convex hull as an array of points\r\n     */\r\n    export function ConvexHull(S: Point[]): Point[] {\r\n        var P = S.slice(0).sort((a, b) => a.x !== b.x ? b.x - a.x : b.y - a.y);\r\n        var n = S.length, i;\r\n        var minmin = 0;\r\n        var xmin = P[0].x;\r\n        for (i = 1; i < n; ++i) {\r\n            if (P[i].x !== xmin) break;\r\n        }\r\n        var minmax = i - 1;\r\n        var H: Point[] = [];\r\n        H.push(P[minmin]); // push minmin point onto stack\r\n        if (minmax === n - 1) { // degenerate case: all x-coords == xmin\r\n            if (P[minmax].y !== P[minmin].y) // a  nontrivial segment\r\n                H.push(P[minmax]);\r\n        } else {\r\n            // Get the indices of points with max x-coord and min|max y-coord\r\n            var maxmin, maxmax = n - 1;\r\n            var xmax = P[n - 1].x;\r\n            for (i = n - 2; i >= 0; i--)\r\n                if (P[i].x !== xmax) break;\r\n            maxmin = i + 1;\r\n\r\n            // Compute the lower hull on the stack H\r\n            i = minmax;\r\n            while (++i <= maxmin) {\r\n                // the lower line joins P[minmin]  with P[maxmin]\r\n                if (isLeft(P[minmin], P[maxmin], P[i]) >= 0 && i < maxmin)\r\n                    continue; // ignore P[i] above or on the lower line\r\n\r\n                while (H.length > 1) // there are at least 2 points on the stack\r\n                {\r\n                    // test if  P[i] is left of the line at the stack top\r\n                    if (isLeft(H[H.length - 2], H[H.length - 1], P[i]) > 0)\r\n                        break; // P[i] is a new hull  vertex\r\n                    else\r\n                        H.length -= 1; // pop top point off  stack\r\n                }\r\n                if (i != minmin) H.push(P[i]);\r\n            }\r\n\r\n            // Next, compute the upper hull on the stack H above the bottom hull\r\n            if (maxmax != maxmin) // if  distinct xmax points\r\n                H.push(P[maxmax]); // push maxmax point onto stack\r\n            var bot = H.length; // the bottom point of the upper hull stack\r\n            i = maxmin;\r\n            while (--i >= minmax) {\r\n                // the upper line joins P[maxmax]  with P[minmax]\r\n                if (isLeft(P[maxmax], P[minmax], P[i]) >= 0 && i > minmax)\r\n                    continue; // ignore P[i] below or on the upper line\r\n\r\n                while (H.length > bot) // at least 2 points on the upper stack\r\n                {\r\n                    // test if  P[i] is left of the line at the stack top\r\n                    if (isLeft(H[H.length - 2], H[H.length - 1], P[i]) > 0)\r\n                        break; // P[i] is a new hull  vertex\r\n                    else\r\n                        H.length -= 1; // pop top point off  stack\r\n                }\r\n                if (i != minmin) H.push(P[i]); // push P[i] onto stack\r\n            }\r\n        }\r\n        return H;\r\n    }\r\n\r\n    // apply f to the points in P in clockwise order around the point p\r\n    export function clockwiseRadialSweep(p: Point, P: Point[], f: (p: Point) => void) {\r\n        P.slice(0).sort(\r\n            (a, b) => Math.atan2(a.y - p.y, a.x - p.x) - Math.atan2(b.y - p.y, b.x - p.x)\r\n            ).forEach(f);\r\n    }\r\n\r\n    function nextPolyPoint(p: PolyPoint, ps: PolyPoint[]): PolyPoint {\r\n        if (p.polyIndex === ps.length - 1) return ps[0];\r\n        return ps[p.polyIndex + 1];\r\n    }\r\n\r\n    function prevPolyPoint(p: PolyPoint, ps: PolyPoint[]): PolyPoint {\r\n        if (p.polyIndex === 0) return ps[ps.length - 1];\r\n        return ps[p.polyIndex - 1];\r\n    }\r\n\r\n    // tangent_PointPolyC(): fast binary search for tangents to a convex polygon\r\n    //    Input:  P = a 2D point (exterior to the polygon)\r\n    //            n = number of polygon vertices\r\n    //            V = array of vertices for a 2D convex polygon\r\n    //    Output: rtan = index of rightmost tangent point V[rtan]\r\n    //            ltan = index of leftmost tangent point V[ltan]\r\n    function tangent_PointPolyC(P: Point, V: Point[]): { rtan: number; ltan: number } {\r\n        // Rtangent_PointPolyC and Ltangent_PointPolyC require polygon to be\r\n        // \"closed\" with the first vertex duplicated at end, so V[n-1] = V[0].\r\n        let Vclosed = V.slice(0);  // Copy V\r\n        Vclosed.push(V[0]);        // Add V[0] at end\r\n\r\n        return { rtan: Rtangent_PointPolyC(P, Vclosed), ltan: Ltangent_PointPolyC(P, Vclosed) };\r\n    }\r\n\r\n\r\n    // Rtangent_PointPolyC(): binary search for convex polygon right tangent\r\n    //    Input:  P = a 2D point (exterior to the polygon)\r\n    //            n = number of polygon vertices\r\n    //            V = array of vertices for a 2D convex polygon with first\r\n    //                vertex duplicated as last, so V[n-1] = V[0]\r\n    //    Return: index \"i\" of rightmost tangent point V[i]\r\n    function Rtangent_PointPolyC(P: Point, V: Point[]): number {\r\n        var n = V.length - 1;\r\n\r\n        // use binary search for large convex polygons\r\n        var a: number, b: number, c: number;            // indices for edge chain endpoints\r\n        var upA: boolean, dnC: boolean;           // test for up direction of edges a and c\r\n\r\n        // rightmost tangent = maximum for the isLeft() ordering\r\n        // test if V[0] is a local maximum\r\n        if (below(P, V[1], V[0]) && !above(P, V[n - 1], V[0]))\r\n            return 0;               // V[0] is the maximum tangent point\r\n\r\n        for (a = 0, b = n; ;) {          // start chain = [0,n] with V[n]=V[0]\r\n            if (b - a === 1)\r\n                if (above(P, V[a], V[b]))\r\n                    return a;\r\n                else\r\n                    return b;\r\n\r\n            c = Math.floor((a + b) / 2);        // midpoint of [a,b], and 0<c<n\r\n            dnC = below(P, V[c + 1], V[c]);\r\n            if (dnC && !above(P, V[c - 1], V[c]))\r\n                return c;          // V[c] is the maximum tangent point\r\n\r\n            // no max yet, so continue with the binary search\r\n            // pick one of the two subchains [a,c] or [c,b]\r\n            upA = above(P, V[a + 1], V[a]);\r\n            if (upA) {                       // edge a points up\r\n                if (dnC)                         // edge c points down\r\n                    b = c;                           // select [a,c]\r\n                else {                           // edge c points up\r\n                    if (above(P, V[a], V[c]))     // V[a] above V[c]\r\n                        b = c;                       // select [a,c]\r\n                    else                          // V[a] below V[c]\r\n                        a = c;                       // select [c,b]\r\n                }\r\n            }\r\n            else {                           // edge a points down\r\n                if (!dnC)                        // edge c points up\r\n                    a = c;                           // select [c,b]\r\n                else {                           // edge c points down\r\n                    if (below(P, V[a], V[c]))     // V[a] below V[c]\r\n                        b = c;                       // select [a,c]\r\n                    else                          // V[a] above V[c]\r\n                        a = c;                       // select [c,b]\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // Ltangent_PointPolyC(): binary search for convex polygon left tangent\r\n    //    Input:  P = a 2D point (exterior to the polygon)\r\n    //            n = number of polygon vertices\r\n    //            V = array of vertices for a 2D convex polygon with first\r\n    //                vertex duplicated as last, so V[n-1] = V[0]\r\n    //    Return: index \"i\" of leftmost tangent point V[i]\r\n    function Ltangent_PointPolyC(P: Point, V: Point[]): number {\r\n        var n = V.length - 1;\r\n        // use binary search for large convex polygons\r\n        var a: number, b: number, c: number;             // indices for edge chain endpoints\r\n        var dnA: boolean, dnC: boolean;           // test for down direction of edges a and c\r\n\r\n        // leftmost tangent = minimum for the isLeft() ordering\r\n        // test if V[0] is a local minimum\r\n        if (above(P, V[n - 1], V[0]) && !below(P, V[1], V[0]))\r\n            return 0;               // V[0] is the minimum tangent point\r\n\r\n        for (a = 0, b = n; ;) {          // start chain = [0,n] with V[n] = V[0]\r\n            if (b - a === 1)\r\n                if (below(P, V[a], V[b]))\r\n                    return a;\r\n                else\r\n                    return b;\r\n\r\n            c = Math.floor((a + b) / 2);        // midpoint of [a,b], and 0<c<n\r\n            dnC = below(P, V[c + 1], V[c]);\r\n            if (above(P, V[c - 1], V[c]) && !dnC)\r\n                return c;          // V[c] is the minimum tangent point\r\n\r\n            // no min yet, so continue with the binary search\r\n            // pick one of the two subchains [a,c] or [c,b]\r\n            dnA = below(P, V[a + 1], V[a]);\r\n            if (dnA) {                       // edge a points down\r\n                if (!dnC)                        // edge c points up\r\n                    b = c;                           // select [a,c]\r\n                else {                           // edge c points down\r\n                    if (below(P, V[a], V[c]))     // V[a] below V[c]\r\n                        b = c;                       // select [a,c]\r\n                    else                          // V[a] above V[c]\r\n                        a = c;                       // select [c,b]\r\n                }\r\n            }\r\n            else {                           // edge a points up\r\n                if (dnC)                         // edge c points down\r\n                    a = c;                           // select [c,b]\r\n                else {                           // edge c points up\r\n                    if (above(P, V[a], V[c]))     // V[a] above V[c]\r\n                        b = c;                       // select [a,c]\r\n                    else                          // V[a] below V[c]\r\n                        a = c;                       // select [c,b]\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // RLtangent_PolyPolyC(): get the RL tangent between two convex polygons\r\n    //    Input:  m = number of vertices in polygon 1\r\n    //            V = array of vertices for convex polygon 1 with V[m]=V[0]\r\n    //            n = number of vertices in polygon 2\r\n    //            W = array of vertices for convex polygon 2 with W[n]=W[0]\r\n    //    Output: *t1 = index of tangent point V[t1] for polygon 1\r\n    //            *t2 = index of tangent point W[t2] for polygon 2\r\n    export function tangent_PolyPolyC(V: Point[], W: Point[], t1: (a: Point, b: Point[]) => number, t2: (a: Point, b: Point[]) => number, cmp1: (a: Point, b: Point, c: Point) => boolean, cmp2: (a: Point, b: Point, c: Point) => boolean): { t1: number; t2: number } {\r\n        var ix1: number, ix2: number;      // search indices for polygons 1 and 2\r\n\r\n        // first get the initial vertex on each polygon\r\n        ix1 = t1(W[0], V);   // right tangent from W[0] to V\r\n        ix2 = t2(V[ix1], W); // left tangent from V[ix1] to W\r\n\r\n        // ping-pong linear search until it stabilizes\r\n        var done = false;                    // flag when done\r\n        while (!done) {\r\n            done = true;                     // assume done until...\r\n            while (true) {\r\n                if (ix1 === V.length - 1) ix1 = 0;\r\n                if (cmp1(W[ix2], V[ix1], V[ix1 + 1])) break;\r\n                ++ix1;                       // get Rtangent from W[ix2] to V\r\n            }\r\n            while (true) {\r\n                if (ix2 === 0) ix2 = W.length - 1;\r\n                if (cmp2(V[ix1], W[ix2], W[ix2 - 1])) break;\r\n                --ix2;                       // get Ltangent from V[ix1] to W\r\n                done = false;                // not done if had to adjust this\r\n            }\r\n        }\r\n        return { t1: ix1, t2: ix2 };\r\n    }\r\n\r\n    export function LRtangent_PolyPolyC(V: Point[], W: Point[]): { t1: number; t2: number } {\r\n        var rl = RLtangent_PolyPolyC(W, V);\r\n        return { t1: rl.t2, t2: rl.t1 };\r\n    }\r\n\r\n    export function RLtangent_PolyPolyC(V: Point[], W: Point[]): { t1: number; t2: number } {\r\n        return tangent_PolyPolyC(V, W, Rtangent_PointPolyC, Ltangent_PointPolyC, above, below);\r\n    }\r\n\r\n    export function LLtangent_PolyPolyC(V: Point[], W: Point[]): { t1: number; t2: number } {\r\n        return tangent_PolyPolyC(V, W, Ltangent_PointPolyC, Ltangent_PointPolyC, below, below);\r\n    }\r\n\r\n    export function RRtangent_PolyPolyC(V: Point[], W: Point[]): { t1: number; t2: number } {\r\n        return tangent_PolyPolyC(V, W, Rtangent_PointPolyC, Rtangent_PointPolyC, above, above);\r\n    }\r\n\r\n    export class BiTangent {\r\n        constructor(public t1: number, public t2: number) { }\r\n    }\r\n\r\n    export class BiTangents {\r\n        rl: BiTangent;\r\n        lr: BiTangent;\r\n        ll: BiTangent;\r\n        rr: BiTangent;\r\n    }\r\n\r\n    export class TVGPoint extends Point {\r\n        vv: VisibilityVertex;\r\n    }\r\n\r\n    export class VisibilityVertex {\r\n        constructor(\r\n            public id: number,\r\n            public polyid: number,\r\n            public polyvertid: number,\r\n            public p: TVGPoint)\r\n        {\r\n            p.vv = this;\r\n        }\r\n    }\r\n\r\n    export class VisibilityEdge {\r\n        constructor(\r\n            public source: VisibilityVertex,\r\n            public target: VisibilityVertex) { }\r\n        length(): number {\r\n            var dx = this.source.p.x - this.target.p.x;\r\n            var dy = this.source.p.y - this.target.p.y;\r\n            return Math.sqrt(dx * dx + dy * dy);\r\n        }\r\n    }\r\n\r\n    export class TangentVisibilityGraph {\r\n        V: VisibilityVertex[] = [];\r\n        E: VisibilityEdge[] = [];\r\n        constructor(public P: TVGPoint[][], g0?: { V: VisibilityVertex[]; E: VisibilityEdge[] }) {\r\n            if (!g0) {\r\n                var n = P.length;\r\n                // For each node...\r\n                for (var i = 0; i < n; i++) {\r\n                    var p = P[i];\r\n                    // For each node vertex.\r\n                    for (var j = 0; j < p.length; ++j) {\r\n                        var pj = p[j],\r\n                            vv = new VisibilityVertex(this.V.length, i, j, pj);\r\n                        this.V.push(vv);\r\n                        // For the every iteration but the first, generate an\r\n                        // edge from the previous visibility vertex to the\r\n                        // current one.\r\n                        if (j > 0) this.E.push(new VisibilityEdge(p[j - 1].vv, vv));\r\n                    }\r\n                    // Add a visibility edge from the first vertex to the last.\r\n                    if (p.length > 1) this.E.push(new VisibilityEdge(p[0].vv, p[p.length - 1].vv));\r\n                }\r\n                for (var i = 0; i < n - 1; i++) {\r\n                    var Pi = P[i];\r\n                    for (var j = i + 1; j < n; j++) {\r\n                        var Pj = P[j],\r\n                            t = tangents(Pi, Pj);\r\n                        for (var q in t) {\r\n                            var c = t[q],\r\n                                source = Pi[c.t1], target = Pj[c.t2];\r\n                            this.addEdgeIfVisible(source, target, i, j);\r\n                        }\r\n                    }\r\n                }\r\n            } else {\r\n                this.V = g0.V.slice(0);\r\n                this.E = g0.E.slice(0);\r\n            }\r\n        }\r\n        addEdgeIfVisible(u: TVGPoint, v: TVGPoint, i1: number, i2: number) {\r\n            if (!this.intersectsPolys(new LineSegment(u.x, u.y, v.x, v.y), i1, i2)) {\r\n                this.E.push(new VisibilityEdge(u.vv, v.vv));\r\n            }\r\n        }\r\n        addPoint(p: TVGPoint, i1: number): VisibilityVertex {\r\n            var n = this.P.length;\r\n            this.V.push(new VisibilityVertex(this.V.length, n, 0, p));\r\n            for (var i = 0; i < n; ++i) {\r\n                if (i === i1) continue;\r\n                var poly = this.P[i],\r\n                    t = tangent_PointPolyC(p, poly);\r\n                this.addEdgeIfVisible(p, poly[t.ltan], i1, i);\r\n                this.addEdgeIfVisible(p, poly[t.rtan], i1, i);\r\n            }\r\n            return p.vv;\r\n        }\r\n        private intersectsPolys(l: LineSegment, i1: number, i2: number): boolean {\r\n            for (var i = 0, n = this.P.length; i < n; ++i) {\r\n                if (i != i1 && i != i2 && intersects(l, this.P[i]).length > 0) {\r\n                    return true;\r\n                }\r\n            }\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function intersects(l: LineSegment, P: Point[]) {\r\n        var ints = [];\r\n        for (var i = 1, n = P.length; i < n; ++i) {\r\n            var int = Rectangle.lineIntersection(\r\n                l.x1, l.y1,\r\n                l.x2, l.y2,\r\n                P[i - 1].x, P[i - 1].y,\r\n                P[i].x, P[i].y\r\n                );\r\n            if (int) ints.push(int);\r\n        }\r\n        return ints;\r\n    }\r\n\r\n    export function tangents(V: Point[], W: Point[]): BiTangents\r\n    {\r\n        var m = V.length - 1, n = W.length - 1;\r\n        var bt = new BiTangents();\r\n        for (var i = 0; i < m; ++i) {\r\n            for (var j = 0; j < n; ++j) {\r\n                var v1 = V[i == 0 ? m - 1 : i - 1];\r\n                var v2 = V[i];\r\n                var v3 = V[i + 1];\r\n                var w1 = W[j == 0 ? n - 1 : j - 1];\r\n                var w2 = W[j];\r\n                var w3 = W[j + 1];\r\n                var v1v2w2 = isLeft(v1, v2, w2);\r\n                var v2w1w2 = isLeft(v2, w1, w2);\r\n                var v2w2w3 = isLeft(v2, w2, w3);\r\n                var w1w2v2 = isLeft(w1, w2, v2);\r\n                var w2v1v2 = isLeft(w2, v1, v2);\r\n                var w2v2v3 = isLeft(w2, v2, v3);\r\n                if (v1v2w2 >= 0 && v2w1w2 >= 0 && v2w2w3 < 0\r\n                    && w1w2v2 >= 0 && w2v1v2 >= 0 && w2v2v3 < 0) {\r\n                        bt.ll = new BiTangent(i, j);\r\n                } else if (v1v2w2 <= 0 && v2w1w2 <= 0 && v2w2w3 > 0\r\n                    && w1w2v2 <= 0 && w2v1v2 <= 0 && w2v2v3 > 0) {\r\n                        bt.rr = new BiTangent(i, j);\r\n                } else if (v1v2w2 <= 0 && v2w1w2 > 0 && v2w2w3 <= 0\r\n                    && w1w2v2 >= 0 && w2v1v2 < 0 && w2v2v3 >= 0) {\r\n                        bt.rl = new BiTangent(i, j);\r\n                } else if (v1v2w2 >= 0 && v2w1w2 < 0 && v2w2w3 >= 0\r\n                    && w1w2v2 <= 0 && w2v1v2 > 0 && w2v2v3 <= 0) {\r\n                        bt.lr = new BiTangent(i, j);\r\n                }\r\n            }\r\n        }\r\n        return bt;\r\n    }\r\n\r\n    function isPointInsidePoly(p: Point, poly: Point[]): boolean {\r\n        for (var i = 1, n = poly.length; i < n; ++i)\r\n            if (below(poly[i - 1], poly[i], p)) return false;\r\n        return true;\r\n    }\r\n\r\n    function isAnyPInQ(p: Point[], q: Point[]): boolean {\r\n        return !p.every(v => !isPointInsidePoly(v, q));\r\n    }\r\n\r\n    export function polysOverlap(p: Point[], q: Point[]): boolean {\r\n        if (isAnyPInQ(p, q)) return true;\r\n        if (isAnyPInQ(q, p)) return true;\r\n        for (var i = 1, n = p.length; i < n; ++i) {\r\n            var v = p[i], u = p[i - 1];\r\n            if (intersects(new LineSegment(u.x, u.y, v.x, v.y), q).length > 0) return true;\r\n        }\r\n        return false;\r\n    }\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}