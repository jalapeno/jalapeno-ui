{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar layout_1 = require(\"./layout\");\nvar D3StyleLayoutAdaptor = function (_super) {\n  __extends(D3StyleLayoutAdaptor, _super);\n  function D3StyleLayoutAdaptor(d3Context) {\n    var _this = _super.call(this) || this;\n    _this.d3Context = d3Context;\n    _this.event = d3Context.dispatch(layout_1.EventType[layout_1.EventType.start], layout_1.EventType[layout_1.EventType.tick], layout_1.EventType[layout_1.EventType.end]);\n    var d3layout = _this;\n    var drag;\n    _this.drag = function () {\n      if (!drag) {\n        var drag = d3Context.drag().subject(layout_1.Layout.dragOrigin).on(\"start.d3adaptor\", layout_1.Layout.dragStart).on(\"drag.d3adaptor\", function (d) {\n          layout_1.Layout.drag(d, d3Context.event);\n          d3layout.resume();\n        }).on(\"end.d3adaptor\", layout_1.Layout.dragEnd);\n      }\n      if (!arguments.length) return drag;\n      arguments[0].call(drag);\n    };\n    return _this;\n  }\n  D3StyleLayoutAdaptor.prototype.trigger = function (e) {\n    var d3event = {\n      type: layout_1.EventType[e.type],\n      alpha: e.alpha,\n      stress: e.stress\n    };\n    this.event.call(d3event.type, d3event);\n  };\n  D3StyleLayoutAdaptor.prototype.kick = function () {\n    var _this = this;\n    var t = this.d3Context.timer(function () {\n      return _super.prototype.tick.call(_this) && t.stop();\n    });\n  };\n  D3StyleLayoutAdaptor.prototype.on = function (eventType, listener) {\n    if (typeof eventType === 'string') {\n      this.event.on(eventType, listener);\n    } else {\n      this.event.on(layout_1.EventType[eventType], listener);\n    }\n    return this;\n  };\n  return D3StyleLayoutAdaptor;\n}(layout_1.Layout);\nexports.D3StyleLayoutAdaptor = D3StyleLayoutAdaptor;","map":{"version":3,"names":["layout_1","require","D3StyleLayoutAdaptor","_super","__extends","d3Context","_this","call","event","dispatch","EventType","start","tick","end","d3layout","drag","subject","Layout","dragOrigin","on","dragStart","d","resume","dragEnd","arguments","length","prototype","trigger","e","d3event","type","alpha","stress","kick","t","timer","stop","eventType","listener","exports"],"sources":["/Users/brucemcdougall/go/jalapeno-github/jalapeno-ui/node_modules/webcola/WebCola/src/d3v4adaptor.ts"],"sourcesContent":["import {dispatch} from 'd3-dispatch'\r\nimport {timer} from 'd3-timer'\r\nimport {drag as d3drag} from 'd3-drag'\r\nimport {Layout, EventType, Event} from './layout'\r\nimport {ID3StyleLayoutAdaptor} from './d3adaptor'\r\n\r\nexport interface D3Context {\r\n    timer: typeof timer; \r\n    drag: typeof d3drag; \r\n    dispatch: typeof dispatch;\r\n    event: any;\r\n}\r\n\r\nexport class D3StyleLayoutAdaptor extends Layout implements ID3StyleLayoutAdaptor {\r\n    event:any;\r\n    trigger(e: Event) {\r\n        var d3event = { type: EventType[e.type], alpha: e.alpha, stress: e.stress };\r\n        // the dispatcher is actually expecting something of type EventTarget as the second argument\r\n        // so passing the thing above is totally abusing the pattern... not sure what to do about this yet\r\n        this.event.call(d3event.type, <any>d3event); // via d3 dispatcher, e.g. event.start(e);\r\n    }\r\n\r\n    // iterate layout using a d3.timer, which queues calls to tick repeatedly until tick returns true\r\n    kick() {\r\n        var t = this.d3Context.timer(() => super.tick() && t.stop());\r\n    }\r\n\r\n    // a function to allow for dragging of nodes\r\n    drag: () => any;\r\n\r\n    constructor(private d3Context: D3Context) {\r\n        super();\r\n        this.event = d3Context.dispatch(EventType[EventType.start], EventType[EventType.tick], EventType[EventType.end]);\r\n\r\n        // bit of trickyness remapping 'this' so we can reference it in the function body.\r\n        var d3layout = this;\r\n        var drag;\r\n        this.drag = function () {\r\n            if (!drag) {\r\n                var drag = d3Context.drag()\r\n                    .subject(Layout.dragOrigin)\r\n                    .on(\"start.d3adaptor\", Layout.dragStart)\r\n                    .on(\"drag.d3adaptor\", d => {\r\n                        Layout.drag(<any>d, d3Context.event);\r\n                        d3layout.resume(); // restart annealing\r\n                    })\r\n                    .on(\"end.d3adaptor\", Layout.dragEnd);\r\n            }\r\n\r\n            if (!arguments.length) return drag;\r\n\r\n            // this is the context of the function, i.e. the d3 selection\r\n            //this//.on(\"mouseover.adaptor\", colaMouseover)\r\n            //.on(\"mouseout.adaptor\", colaMouseout)\r\n            arguments[0].call(drag);\r\n        }\r\n    }\r\n\r\n    // a function for binding to events on the adapter\r\n    on(eventType: EventType | string, listener: () => void): this {\r\n        if (typeof eventType === 'string') {\r\n            this.event.on(eventType, listener);\r\n        } else {\r\n            this.event.on(EventType[eventType], listener);\r\n        }\r\n        return this;\r\n    }\r\n}\r\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;AAGA,IAAAA,QAAA,GAAAC,OAAA;AAUA,IAAAC,oBAAA,aAAAC,MAAA;EAA0CC,SAAA,CAAAF,oBAAA,EAAAC,MAAA;EAiBtC,SAAAD,qBAAoBG,SAAoB;IAAxC,IAAAC,KAAA,GACIH,MAAA,CAAAI,IAAA,MAAO;IADSD,KAAA,CAAAD,SAAS,GAATA,SAAS;IAEzBC,KAAI,CAACE,KAAK,GAAGH,SAAS,CAACI,QAAQ,CAACT,QAAA,CAAAU,SAAS,CAACV,QAAA,CAAAU,SAAS,CAACC,KAAK,CAAC,EAAEX,QAAA,CAAAU,SAAS,CAACV,QAAA,CAAAU,SAAS,CAACE,IAAI,CAAC,EAAEZ,QAAA,CAAAU,SAAS,CAACV,QAAA,CAAAU,SAAS,CAACG,GAAG,CAAC,CAAC;IAGhH,IAAIC,QAAQ,GAAGR,KAAI;IACnB,IAAIS,IAAI;IACRT,KAAI,CAACS,IAAI,GAAG;MACR,IAAI,CAACA,IAAI,EAAE;QACP,IAAIA,IAAI,GAAGV,SAAS,CAACU,IAAI,EAAE,CACtBC,OAAO,CAAChB,QAAA,CAAAiB,MAAM,CAACC,UAAU,CAAC,CAC1BC,EAAE,CAAC,iBAAiB,EAAEnB,QAAA,CAAAiB,MAAM,CAACG,SAAS,CAAC,CACvCD,EAAE,CAAC,gBAAgB,EAAE,UAAAE,CAAC;UACnBrB,QAAA,CAAAiB,MAAM,CAACF,IAAI,CAAMM,CAAC,EAAEhB,SAAS,CAACG,KAAK,CAAC;UACpCM,QAAQ,CAACQ,MAAM,EAAE;QACrB,CAAC,CAAC,CACDH,EAAE,CAAC,eAAe,EAAEnB,QAAA,CAAAiB,MAAM,CAACM,OAAO,CAAC;;MAG5C,IAAI,CAACC,SAAS,CAACC,MAAM,EAAE,OAAOV,IAAI;MAKlCS,SAAS,CAAC,CAAC,CAAC,CAACjB,IAAI,CAACQ,IAAI,CAAC;IAC3B,CAAC;;EACL;EAzCAb,oBAAA,CAAAwB,SAAA,CAAAC,OAAO,GAAP,UAAQC,CAAQ;IACZ,IAAIC,OAAO,GAAG;MAAEC,IAAI,EAAE9B,QAAA,CAAAU,SAAS,CAACkB,CAAC,CAACE,IAAI,CAAC;MAAEC,KAAK,EAAEH,CAAC,CAACG,KAAK;MAAEC,MAAM,EAAEJ,CAAC,CAACI;IAAM,CAAE;IAG3E,IAAI,CAACxB,KAAK,CAACD,IAAI,CAACsB,OAAO,CAACC,IAAI,EAAOD,OAAO,CAAC;EAC/C,CAAC;EAGD3B,oBAAA,CAAAwB,SAAA,CAAAO,IAAI,GAAJ;IAAA,IAAA3B,KAAA;IACI,IAAI4B,CAAC,GAAG,IAAI,CAAC7B,SAAS,CAAC8B,KAAK,CAAC;MAAM,OAAAhC,MAAA,CAAAuB,SAAA,CAAMd,IAAI,CAAAL,IAAA,CAAAD,KAAA,CAAE,IAAI4B,CAAC,CAACE,IAAI,EAAE;IAAxB,CAAwB,CAAC;EAChE,CAAC;EAkCDlC,oBAAA,CAAAwB,SAAA,CAAAP,EAAE,GAAF,UAAGkB,SAA6B,EAAEC,QAAoB;IAClD,IAAI,OAAOD,SAAS,KAAK,QAAQ,EAAE;MAC/B,IAAI,CAAC7B,KAAK,CAACW,EAAE,CAACkB,SAAS,EAAEC,QAAQ,CAAC;KACrC,MAAM;MACH,IAAI,CAAC9B,KAAK,CAACW,EAAE,CAACnB,QAAA,CAAAU,SAAS,CAAC2B,SAAS,CAAC,EAAEC,QAAQ,CAAC;;IAEjD,OAAO,IAAI;EACf,CAAC;EACL,OAAApC,oBAAC;AAAD,CAAC,CAtDyCF,QAAA,CAAAiB,MAAM;AAAnCsB,OAAA,CAAArC,oBAAA,GAAAA,oBAAA","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}