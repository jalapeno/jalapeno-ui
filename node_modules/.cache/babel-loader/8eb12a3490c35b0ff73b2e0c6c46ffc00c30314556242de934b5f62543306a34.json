{"ast":null,"code":"var _jsxFileName = \"/Users/brucemcdougall/go/jalapeno-github/jalapeno-ui/src/components/NetworkGraph.js\",\n  _s = $RefreshSig$();\nimport React, { useEffect, useRef, useState } from 'react';\nimport CytoscapeComponent from 'react-cytoscapejs';\nimport cytoscape from 'cytoscape';\nimport cola from 'cytoscape-cola';\nimport { apiUrl } from '../config';\nimport '../styles/NetworkGraph.css';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst COLORS = {\n  node: '#CC4A04',\n  // Default node color (Cayenne orange)\n  prefix: '#002921',\n  // Color for prefixes\n  host: '#1E88E5',\n  // Blue for future host nodes\n  service: '#7CB342',\n  // Green for future service nodes\n  gpu: '#6D4C41',\n  // Brown for future GPU nodes\n  text: '#000',\n  // Black\n  edge: '#1a365d' // Blue\n};\ncytoscape.use(cola);\nconst Legend = () => /*#__PURE__*/_jsxDEV(\"div\", {\n  className: \"graph-legend\",\n  children: [/*#__PURE__*/_jsxDEV(\"h3\", {\n    children: \"Legend\"\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 22,\n    columnNumber: 5\n  }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"legend-item\",\n    children: [/*#__PURE__*/_jsxDEV(\"span\", {\n      className: \"legend-color\",\n      style: {\n        backgroundColor: COLORS.node\n      }\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 24,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"span\", {\n      children: \"Nodes\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 25,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 23,\n    columnNumber: 5\n  }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"legend-item\",\n    children: [/*#__PURE__*/_jsxDEV(\"span\", {\n      className: \"legend-color\",\n      style: {\n        backgroundColor: COLORS.prefix\n      }\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 28,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"span\", {\n      children: \"Prefixes\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 29,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 27,\n    columnNumber: 5\n  }, this)]\n}, void 0, true, {\n  fileName: _jsxFileName,\n  lineNumber: 21,\n  columnNumber: 3\n}, this);\n_c = Legend;\nconst NetworkGraph = ({\n  collection\n}) => {\n  _s();\n  const cyRef = useRef(null);\n  const [graphData, setGraphData] = useState(null);\n  const [verticesData, setVerticesData] = useState({});\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(null);\n  useEffect(() => {\n    const loadGraphData = async () => {\n      if (!collection) return;\n      setIsLoading(true);\n      setError(null);\n      try {\n        const response = await fetch(`${apiUrl}/api/v1/collections/${collection}/topology`);\n        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);\n        const data = await response.json();\n        console.log('Topology data:', data); // Debug log\n        const elements = transformDataToCytoscape(data);\n        setGraphData(elements);\n      } catch (err) {\n        console.error('Detailed error:', err);\n        setError(`Failed to load graph data: ${err.message}`);\n      } finally {\n        setIsLoading(false);\n      }\n    };\n    loadGraphData();\n  }, [collection]);\n  const transformDataToCytoscape = data => {\n    const elements = {\n      nodes: new Set(),\n      edges: new Set()\n    };\n    if (!(data !== null && data !== void 0 && data.edges) || !(data !== null && data !== void 0 && data.vertices)) {\n      console.warn('Missing edges or vertices in data');\n      return [];\n    }\n\n    // Store vertices data for tooltips\n    setVerticesData(data.vertices);\n\n    // Create a Set to track processed edge pairs\n    const processedEdges = new Set();\n\n    // Process edges\n    Object.entries(data.edges).forEach(([_, edge]) => {\n      if (edge._from && edge._to) {\n        // Create a consistent edge identifier by sorting the vertex IDs\n        const vertices = [edge._from, edge._to].sort();\n        const edgeKey = vertices.join('_');\n\n        // Skip if we've already processed this edge pair\n        if (processedEdges.has(edgeKey)) {\n          return;\n        }\n        processedEdges.add(edgeKey);\n        const fromVertex = data.vertices[edge._from] || {};\n        const toVertex = data.vertices[edge._to] || {};\n\n        // Add nodes with their vertex data\n        elements.nodes.add({\n          data: {\n            id: edge._from,\n            label: fromVertex.name || edge._from.split('/')[1],\n            type: edge._from.split('/')[0],\n            vertexData: fromVertex\n          }\n        });\n        elements.nodes.add({\n          data: {\n            id: edge._to,\n            label: toVertex.name || edge._to.split('/')[1],\n            type: edge._to.split('/')[0],\n            vertexData: toVertex\n          }\n        });\n\n        // Add single edge\n        elements.edges.add({\n          data: {\n            id: edgeKey,\n            source: vertices[0],\n            // Use sorted vertices for consistent direction\n            target: vertices[1]\n          }\n        });\n      }\n    });\n    return [...Array.from(elements.nodes), ...Array.from(elements.edges)];\n  };\n  const getTooltipContent = node => {\n    const vertexData = node.data('vertexData') || {};\n    const type = node.data('type');\n    let content = `<div class=\"tooltip-header\">${type}</div><div class=\"tooltip-body\">`;\n\n    // Add common fields if they exist\n    if (vertexData.name) {\n      content += `<div>Name: ${vertexData.name}</div>`;\n    }\n    if (vertexData.asn) {\n      content += `<div>ASN: ${vertexData.asn}</div>`;\n    }\n\n    // Add type-specific fields\n    switch (type) {\n      case 'igp_node':\n        if (vertexData.protocol) {\n          content += `<div>Protocol: ${vertexData.protocol}</div>`;\n        }\n        if (vertexData.sids && vertexData.sids.length > 0) {\n          content += `<div>SIDs: ${vertexData.sids.join(', ')}</div>`;\n        }\n        break;\n      case 'ls_prefix':\n        if (vertexData.prefix) {\n          content += `<div>Prefix: ${vertexData.prefix}</div>`;\n        }\n        break;\n      case 'bgp_node':\n        if (vertexData.peer_ip) {\n          content += `<div>Peer IP: ${vertexData.peer_ip}</div>`;\n        }\n        if (vertexData.address_family) {\n          content += `<div>Address Family: ${vertexData.address_family}</div>`;\n        }\n        break;\n    }\n    content += '</div>';\n    return content;\n  };\n\n  // Setup hover events after the graph is rendered\n  useEffect(() => {\n    if (cyRef.current) {\n      const cy = cyRef.current;\n\n      // Remove any existing event listeners\n      cy.nodes().unbind('mouseover mouseout');\n\n      // Add hover events\n      cy.nodes().bind('mouseover', event => {\n        const node = event.target;\n        const type = node.data('type');\n        const label = node.data('label');\n\n        // Create and position the tooltip div\n        let tooltip = document.getElementById('cy-tooltip');\n        if (!tooltip) {\n          tooltip = document.createElement('div');\n          tooltip.setAttribute('id', 'cy-tooltip');\n          document.body.appendChild(tooltip);\n        }\n        tooltip.innerHTML = `\n          <div class=\"tooltip-header\">${type}</div>\n          <div class=\"tooltip-body\">\n            <div>ID: ${label}</div>\n          </div>\n        `;\n        const renderedPosition = node.renderedPosition();\n        const zoom = cy.zoom();\n        tooltip.style.display = 'block';\n        tooltip.style.left = `${renderedPosition.x}px`;\n        tooltip.style.top = `${renderedPosition.y - 70}px`; // Offset above the node\n      });\n      cy.nodes().bind('mouseout', () => {\n        const tooltip = document.getElementById('cy-tooltip');\n        if (tooltip) {\n          tooltip.style.display = 'none';\n        }\n      });\n    }\n  }, [graphData]);\n  const detectTopology = (nodes, edges) => {\n    console.log('Detecting topology for:', {\n      nodeCount: nodes.length,\n      edgeCount: edges.length,\n      nodes: nodes,\n      edges: edges\n    });\n\n    // Convert edges to adjacency list for analysis\n    const adjacencyList = {};\n    edges.forEach(edge => {\n      const {\n        source,\n        target\n      } = edge.data;\n      if (!adjacencyList[source]) adjacencyList[source] = new Set();\n      if (!adjacencyList[target]) adjacencyList[target] = new Set();\n      adjacencyList[source].add(target);\n      adjacencyList[target].add(source);\n    });\n\n    // Get IGP nodes\n    const igpNodes = nodes.filter(node => node.data.type === 'igp_node');\n\n    // CLOS detection criteria:\n    // 1. Should have enough IGP nodes (at least 3 for minimal CLOS)\n    // 2. Node degrees should follow CLOS pattern (spines highly connected, leaves less connected)\n    // 3. Clear spine/leaf separation in connectivity\n\n    if (igpNodes.length < 3) {\n      return {\n        isClos: false,\n        reason: 'Too few IGP nodes'\n      };\n    }\n\n    // Calculate node degrees\n    const nodeDegrees = {};\n    igpNodes.forEach(node => {\n      var _adjacencyList$node$d;\n      nodeDegrees[node.data.id] = ((_adjacencyList$node$d = adjacencyList[node.data.id]) === null || _adjacencyList$node$d === void 0 ? void 0 : _adjacencyList$node$d.size) || 0;\n    });\n\n    // Sort nodes by degree\n    const sortedDegrees = Object.values(nodeDegrees).sort((a, b) => b - a);\n\n    // In CLOS:\n    // - Spine nodes should have similar (high) degrees\n    // - Leaf nodes should have similar (lower) degrees\n    // - Clear separation between spine and leaf degrees\n\n    if (sortedDegrees.length > 0) {\n      const maxDegree = sortedDegrees[0];\n      const minDegree = sortedDegrees[sortedDegrees.length - 1];\n      const medianIndex = Math.floor(sortedDegrees.length / 2);\n      const medianDegree = sortedDegrees[medianIndex];\n\n      // Check for degree separation characteristic of CLOS\n      const isDegreeDistributionClos = maxDegree > medianDegree * 1.5 &&\n      // Spines should have significantly higher degree\n      maxDegree > minDegree * 2; // Clear separation between spine and leaf degrees\n\n      return {\n        isClos: isDegreeDistributionClos,\n        reason: isDegreeDistributionClos ? 'CLOS pattern detected' : 'Node degree distribution does not match CLOS pattern'\n      };\n    }\n    return {\n      isClos: false,\n      reason: 'Unable to analyze node degrees'\n    };\n  };\n  const getLayout = elements => {\n    if (!elements || elements.length === 0) {\n      console.warn('No elements to layout');\n      return null;\n    }\n    const nodes = elements.filter(ele => ele.group === 'nodes');\n    const edges = elements.filter(ele => ele.group === 'edges');\n    console.log('Getting layout for:', {\n      totalElements: elements.length,\n      nodes: nodes.length,\n      edges: edges.length\n    });\n    const topology = detectTopology(nodes, edges);\n    console.log('Topology detection result:', topology);\n    if (topology.isClos) {\n      console.log('Applying CLOS layout');\n      return {\n        name: 'preset',\n        positions: node => {\n          var _cyRef$current, _cyRef$current2;\n          const width = ((_cyRef$current = cyRef.current) === null || _cyRef$current === void 0 ? void 0 : _cyRef$current.width()) || 1000;\n          const height = ((_cyRef$current2 = cyRef.current) === null || _cyRef$current2 === void 0 ? void 0 : _cyRef$current2.height()) || 800;\n          const type = node.data('type');\n          console.log('Positioning node:', {\n            id: node.data('id'),\n            type: type,\n            width: width,\n            height: height\n          });\n\n          // Group nodes by type for counting\n          const nodesByType = {\n            spine: nodes.filter(n => {\n              var _n$data$vertexData;\n              return n.data.type === 'igp_node' && ((_n$data$vertexData = n.data.vertexData) === null || _n$data$vertexData === void 0 ? void 0 : _n$data$vertexData.role) === 'spine';\n            }),\n            leaf: nodes.filter(n => {\n              var _n$data$vertexData2;\n              return n.data.type === 'igp_node' && ((_n$data$vertexData2 = n.data.vertexData) === null || _n$data$vertexData2 === void 0 ? void 0 : _n$data$vertexData2.role) !== 'spine';\n            }),\n            bgp: nodes.filter(n => n.data.type === 'bgp_node'),\n            prefix: nodes.filter(n => n.data.type === 'ls_prefix')\n          };\n\n          // Calculate position based on node type\n          if (type === 'igp_node') {\n            var _node$data;\n            const isSpine = ((_node$data = node.data('vertexData')) === null || _node$data === void 0 ? void 0 : _node$data.role) === 'spine';\n            const typeNodes = isSpine ? nodesByType.spine : nodesByType.leaf;\n            const index = typeNodes.indexOf(node);\n            const total = typeNodes.length;\n            return {\n              x: width * (index + 1) / (total + 1),\n              y: isSpine ? height * 0.2 : height * 0.5\n            };\n          } else if (type === 'bgp_node') {\n            const index = nodesByType.bgp.indexOf(node);\n            const total = nodesByType.bgp.length;\n            return {\n              x: width * (index + 1) / (total + 1),\n              y: height * 0.35\n            };\n          } else if (type === 'ls_prefix') {\n            const index = nodesByType.prefix.indexOf(node);\n            const total = nodesByType.prefix.length;\n            return {\n              x: width * (index + 1) / (total + 1),\n              y: height * 0.8\n            };\n          }\n          return {\n            x: width / 2,\n            y: height / 2\n          };\n        },\n        fit: true,\n        padding: 50\n      };\n    } else {\n      console.log('Applying force-directed layout');\n      return {\n        name: 'cola',\n        animate: true,\n        refresh: 1,\n        maxSimulationTime: 3000,\n        nodeSpacing: 100,\n        edgeLength: 200,\n        randomize: true,\n        infinite: true\n      };\n    }\n  };\n\n  // Ensure layout is applied after graph data changes\n  useEffect(() => {\n    if (graphData && cyRef.current) {\n      console.log('Applying layout to graph');\n      const layout = getLayout(graphData);\n      if (layout) {\n        cyRef.current.layout(layout).run();\n      }\n    }\n  }, [graphData]);\n  const stylesheet = [{\n    selector: 'node',\n    style: {\n      'background-color': ele => {\n        const nodeType = ele.data('type');\n        switch (nodeType) {\n          case 'igp_node':\n            return COLORS.node;\n          case 'bgp_node':\n            return COLORS.host;\n          case 'ls_prefix':\n            return COLORS.prefix;\n          default:\n            return COLORS.node;\n        }\n      },\n      'label': 'data(label)',\n      'width': 30,\n      'height': 30,\n      'color': COLORS.text,\n      'text-outline-width': 2,\n      'text-outline-color': '#fff',\n      'font-family': 'Consolas',\n      'font-size': '10px',\n      'text-wrap': 'wrap',\n      'text-max-width': '100px'\n    }\n  }, {\n    selector: 'edge',\n    style: {\n      'width': 1.5,\n      'line-color': COLORS.edge,\n      'curve-style': 'bezier',\n      'target-arrow-color': COLORS.edge,\n      'target-arrow-shape': 'triangle',\n      'arrow-scale': 0.8\n    }\n  }];\n  if (isLoading) {\n    return /*#__PURE__*/_jsxDEV(\"div\", {\n      style: {\n        padding: '20px',\n        fontFamily: 'Consolas'\n      },\n      children: \"Loading graph data...\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 429,\n      columnNumber: 12\n    }, this);\n  }\n  if (error) {\n    return /*#__PURE__*/_jsxDEV(\"div\", {\n      style: {\n        padding: '20px',\n        color: 'red',\n        fontFamily: 'Consolas'\n      },\n      children: error\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 433,\n      columnNumber: 12\n    }, this);\n  }\n  if (!graphData) {\n    return /*#__PURE__*/_jsxDEV(\"div\", {\n      style: {\n        padding: '20px',\n        fontFamily: 'Consolas'\n      },\n      children: \"Select a graph to visualize\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 437,\n      columnNumber: 12\n    }, this);\n  }\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"network-graph-container\",\n    children: [/*#__PURE__*/_jsxDEV(Legend, {}, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 442,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"graph-area\",\n      children: /*#__PURE__*/_jsxDEV(CytoscapeComponent, {\n        elements: graphData,\n        layout: getLayout(graphData),\n        stylesheet: stylesheet,\n        cy: cy => {\n          cyRef.current = cy;\n        },\n        style: {\n          width: '100%',\n          height: '100%'\n        }\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 444,\n        columnNumber: 9\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 443,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 441,\n    columnNumber: 5\n  }, this);\n};\n_s(NetworkGraph, \"zfD1i51Y64EV2AGtN6zwmxwQ5FA=\");\n_c2 = NetworkGraph;\nexport default NetworkGraph;\nvar _c, _c2;\n$RefreshReg$(_c, \"Legend\");\n$RefreshReg$(_c2, \"NetworkGraph\");","map":{"version":3,"names":["React","useEffect","useRef","useState","CytoscapeComponent","cytoscape","cola","apiUrl","jsxDEV","_jsxDEV","COLORS","node","prefix","host","service","gpu","text","edge","use","Legend","className","children","fileName","_jsxFileName","lineNumber","columnNumber","style","backgroundColor","_c","NetworkGraph","collection","_s","cyRef","graphData","setGraphData","verticesData","setVerticesData","isLoading","setIsLoading","error","setError","loadGraphData","response","fetch","ok","Error","status","data","json","console","log","elements","transformDataToCytoscape","err","message","nodes","Set","edges","vertices","warn","processedEdges","Object","entries","forEach","_","_from","_to","sort","edgeKey","join","has","add","fromVertex","toVertex","id","label","name","split","type","vertexData","source","target","Array","from","getTooltipContent","content","asn","protocol","sids","length","peer_ip","address_family","current","cy","unbind","bind","event","tooltip","document","getElementById","createElement","setAttribute","body","appendChild","innerHTML","renderedPosition","zoom","display","left","x","top","y","detectTopology","nodeCount","edgeCount","adjacencyList","igpNodes","filter","isClos","reason","nodeDegrees","_adjacencyList$node$d","size","sortedDegrees","values","a","b","maxDegree","minDegree","medianIndex","Math","floor","medianDegree","isDegreeDistributionClos","getLayout","ele","group","totalElements","topology","positions","_cyRef$current","_cyRef$current2","width","height","nodesByType","spine","n","_n$data$vertexData","role","leaf","_n$data$vertexData2","bgp","_node$data","isSpine","typeNodes","index","indexOf","total","fit","padding","animate","refresh","maxSimulationTime","nodeSpacing","edgeLength","randomize","infinite","layout","run","stylesheet","selector","nodeType","fontFamily","color","_c2","$RefreshReg$"],"sources":["/Users/brucemcdougall/go/jalapeno-github/jalapeno-ui/src/components/NetworkGraph.js"],"sourcesContent":["import React, { useEffect, useRef, useState } from 'react';\nimport CytoscapeComponent from 'react-cytoscapejs';\nimport cytoscape from 'cytoscape';\nimport cola from 'cytoscape-cola';\nimport { apiUrl } from '../config';\nimport '../styles/NetworkGraph.css';\n\nconst COLORS = {\n  node: '#CC4A04',     // Default node color (Cayenne orange)\n  prefix: '#002921',   // Color for prefixes\n  host: '#1E88E5',     // Blue for future host nodes\n  service: '#7CB342',  // Green for future service nodes\n  gpu: '#6D4C41',      // Brown for future GPU nodes\n  text: '#000',        // Black\n  edge: '#1a365d'      // Blue\n};\n\ncytoscape.use(cola);\n\nconst Legend = () => (\n  <div className=\"graph-legend\">\n    <h3>Legend</h3>\n    <div className=\"legend-item\">\n      <span className=\"legend-color\" style={{ backgroundColor: COLORS.node }}></span>\n      <span>Nodes</span>\n    </div>\n    <div className=\"legend-item\">\n      <span className=\"legend-color\" style={{ backgroundColor: COLORS.prefix }}></span>\n      <span>Prefixes</span>\n    </div>\n  </div>\n);\n\nconst NetworkGraph = ({ collection }) => {\n  const cyRef = useRef(null);\n  const [graphData, setGraphData] = useState(null);\n  const [verticesData, setVerticesData] = useState({});\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(null);\n\n  useEffect(() => {\n    const loadGraphData = async () => {\n      if (!collection) return;\n      setIsLoading(true);\n      setError(null);\n\n      try {\n        const response = await fetch(`${apiUrl}/api/v1/collections/${collection}/topology`);\n        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);\n        const data = await response.json();\n        console.log('Topology data:', data); // Debug log\n        const elements = transformDataToCytoscape(data);\n        setGraphData(elements);\n      } catch (err) {\n        console.error('Detailed error:', err);\n        setError(`Failed to load graph data: ${err.message}`);\n      } finally {\n        setIsLoading(false);\n      }\n    };\n\n    loadGraphData();\n  }, [collection]);\n\n  const transformDataToCytoscape = (data) => {\n    const elements = {\n      nodes: new Set(),\n      edges: new Set()\n    };\n\n    if (!data?.edges || !data?.vertices) {\n      console.warn('Missing edges or vertices in data');\n      return [];\n    }\n    \n    // Store vertices data for tooltips\n    setVerticesData(data.vertices);\n\n    // Create a Set to track processed edge pairs\n    const processedEdges = new Set();\n\n    // Process edges\n    Object.entries(data.edges).forEach(([_, edge]) => {\n      if (edge._from && edge._to) {\n        // Create a consistent edge identifier by sorting the vertex IDs\n        const vertices = [edge._from, edge._to].sort();\n        const edgeKey = vertices.join('_');\n\n        // Skip if we've already processed this edge pair\n        if (processedEdges.has(edgeKey)) {\n          return;\n        }\n        processedEdges.add(edgeKey);\n\n        const fromVertex = data.vertices[edge._from] || {};\n        const toVertex = data.vertices[edge._to] || {};\n\n        // Add nodes with their vertex data\n        elements.nodes.add({\n          data: {\n            id: edge._from,\n            label: fromVertex.name || edge._from.split('/')[1],\n            type: edge._from.split('/')[0],\n            vertexData: fromVertex\n          }\n        });\n\n        elements.nodes.add({\n          data: {\n            id: edge._to,\n            label: toVertex.name || edge._to.split('/')[1],\n            type: edge._to.split('/')[0],\n            vertexData: toVertex\n          }\n        });\n\n        // Add single edge\n        elements.edges.add({\n          data: {\n            id: edgeKey,\n            source: vertices[0], // Use sorted vertices for consistent direction\n            target: vertices[1]\n          }\n        });\n      }\n    });\n\n    return [...Array.from(elements.nodes), ...Array.from(elements.edges)];\n  };\n\n  const getTooltipContent = (node) => {\n    const vertexData = node.data('vertexData') || {};\n    const type = node.data('type');\n    \n    let content = `<div class=\"tooltip-header\">${type}</div><div class=\"tooltip-body\">`;\n    \n    // Add common fields if they exist\n    if (vertexData.name) {\n      content += `<div>Name: ${vertexData.name}</div>`;\n    }\n    if (vertexData.asn) {\n      content += `<div>ASN: ${vertexData.asn}</div>`;\n    }\n\n    // Add type-specific fields\n    switch (type) {\n      case 'igp_node':\n        if (vertexData.protocol) {\n          content += `<div>Protocol: ${vertexData.protocol}</div>`;\n        }\n        if (vertexData.sids && vertexData.sids.length > 0) {\n          content += `<div>SIDs: ${vertexData.sids.join(', ')}</div>`;\n        }\n        break;\n      \n      case 'ls_prefix':\n        if (vertexData.prefix) {\n          content += `<div>Prefix: ${vertexData.prefix}</div>`;\n        }\n        break;\n\n      case 'bgp_node':\n        if (vertexData.peer_ip) {\n          content += `<div>Peer IP: ${vertexData.peer_ip}</div>`;\n        }\n        if (vertexData.address_family) {\n          content += `<div>Address Family: ${vertexData.address_family}</div>`;\n        }\n        break;\n    }\n    \n    content += '</div>';\n    return content;\n  };\n\n  // Setup hover events after the graph is rendered\n  useEffect(() => {\n    if (cyRef.current) {\n      const cy = cyRef.current;\n      \n      // Remove any existing event listeners\n      cy.nodes().unbind('mouseover mouseout');\n      \n      // Add hover events\n      cy.nodes().bind('mouseover', (event) => {\n        const node = event.target;\n        const type = node.data('type');\n        const label = node.data('label');\n        \n        // Create and position the tooltip div\n        let tooltip = document.getElementById('cy-tooltip');\n        if (!tooltip) {\n          tooltip = document.createElement('div');\n          tooltip.setAttribute('id', 'cy-tooltip');\n          document.body.appendChild(tooltip);\n        }\n        \n        tooltip.innerHTML = `\n          <div class=\"tooltip-header\">${type}</div>\n          <div class=\"tooltip-body\">\n            <div>ID: ${label}</div>\n          </div>\n        `;\n        \n        const renderedPosition = node.renderedPosition();\n        const zoom = cy.zoom();\n        \n        tooltip.style.display = 'block';\n        tooltip.style.left = `${renderedPosition.x}px`;\n        tooltip.style.top = `${renderedPosition.y - 70}px`; // Offset above the node\n      });\n      \n      cy.nodes().bind('mouseout', () => {\n        const tooltip = document.getElementById('cy-tooltip');\n        if (tooltip) {\n          tooltip.style.display = 'none';\n        }\n      });\n    }\n  }, [graphData]);\n\n  const detectTopology = (nodes, edges) => {\n    console.log('Detecting topology for:', {\n      nodeCount: nodes.length,\n      edgeCount: edges.length,\n      nodes: nodes,\n      edges: edges\n    });\n\n    // Convert edges to adjacency list for analysis\n    const adjacencyList = {};\n    edges.forEach(edge => {\n      const { source, target } = edge.data;\n      if (!adjacencyList[source]) adjacencyList[source] = new Set();\n      if (!adjacencyList[target]) adjacencyList[target] = new Set();\n      adjacencyList[source].add(target);\n      adjacencyList[target].add(source);\n    });\n\n    // Get IGP nodes\n    const igpNodes = nodes.filter(node => node.data.type === 'igp_node');\n    \n    // CLOS detection criteria:\n    // 1. Should have enough IGP nodes (at least 3 for minimal CLOS)\n    // 2. Node degrees should follow CLOS pattern (spines highly connected, leaves less connected)\n    // 3. Clear spine/leaf separation in connectivity\n\n    if (igpNodes.length < 3) {\n      return { isClos: false, reason: 'Too few IGP nodes' };\n    }\n\n    // Calculate node degrees\n    const nodeDegrees = {};\n    igpNodes.forEach(node => {\n      nodeDegrees[node.data.id] = adjacencyList[node.data.id]?.size || 0;\n    });\n\n    // Sort nodes by degree\n    const sortedDegrees = Object.values(nodeDegrees).sort((a, b) => b - a);\n    \n    // In CLOS:\n    // - Spine nodes should have similar (high) degrees\n    // - Leaf nodes should have similar (lower) degrees\n    // - Clear separation between spine and leaf degrees\n    \n    if (sortedDegrees.length > 0) {\n      const maxDegree = sortedDegrees[0];\n      const minDegree = sortedDegrees[sortedDegrees.length - 1];\n      const medianIndex = Math.floor(sortedDegrees.length / 2);\n      const medianDegree = sortedDegrees[medianIndex];\n\n      // Check for degree separation characteristic of CLOS\n      const isDegreeDistributionClos = \n        maxDegree > medianDegree * 1.5 && // Spines should have significantly higher degree\n        maxDegree > minDegree * 2;        // Clear separation between spine and leaf degrees\n\n      return {\n        isClos: isDegreeDistributionClos,\n        reason: isDegreeDistributionClos ? 'CLOS pattern detected' : 'Node degree distribution does not match CLOS pattern'\n      };\n    }\n\n    return { isClos: false, reason: 'Unable to analyze node degrees' };\n  };\n\n  const getLayout = (elements) => {\n    if (!elements || elements.length === 0) {\n      console.warn('No elements to layout');\n      return null;\n    }\n\n    const nodes = elements.filter(ele => ele.group === 'nodes');\n    const edges = elements.filter(ele => ele.group === 'edges');\n    \n    console.log('Getting layout for:', {\n      totalElements: elements.length,\n      nodes: nodes.length,\n      edges: edges.length\n    });\n\n    const topology = detectTopology(nodes, edges);\n    console.log('Topology detection result:', topology);\n\n    if (topology.isClos) {\n      console.log('Applying CLOS layout');\n      return {\n        name: 'preset',\n        positions: (node) => {\n          const width = cyRef.current?.width() || 1000;\n          const height = cyRef.current?.height() || 800;\n          const type = node.data('type');\n          \n          console.log('Positioning node:', {\n            id: node.data('id'),\n            type: type,\n            width: width,\n            height: height\n          });\n\n          // Group nodes by type for counting\n          const nodesByType = {\n            spine: nodes.filter(n => n.data.type === 'igp_node' && n.data.vertexData?.role === 'spine'),\n            leaf: nodes.filter(n => n.data.type === 'igp_node' && n.data.vertexData?.role !== 'spine'),\n            bgp: nodes.filter(n => n.data.type === 'bgp_node'),\n            prefix: nodes.filter(n => n.data.type === 'ls_prefix')\n          };\n\n          // Calculate position based on node type\n          if (type === 'igp_node') {\n            const isSpine = node.data('vertexData')?.role === 'spine';\n            const typeNodes = isSpine ? nodesByType.spine : nodesByType.leaf;\n            const index = typeNodes.indexOf(node);\n            const total = typeNodes.length;\n\n            return {\n              x: width * (index + 1) / (total + 1),\n              y: isSpine ? height * 0.2 : height * 0.5\n            };\n          } else if (type === 'bgp_node') {\n            const index = nodesByType.bgp.indexOf(node);\n            const total = nodesByType.bgp.length;\n            return {\n              x: width * (index + 1) / (total + 1),\n              y: height * 0.35\n            };\n          } else if (type === 'ls_prefix') {\n            const index = nodesByType.prefix.indexOf(node);\n            const total = nodesByType.prefix.length;\n            return {\n              x: width * (index + 1) / (total + 1),\n              y: height * 0.8\n            };\n          }\n\n          return { x: width / 2, y: height / 2 };\n        },\n        fit: true,\n        padding: 50\n      };\n    } else {\n      console.log('Applying force-directed layout');\n      return {\n        name: 'cola',\n        animate: true,\n        refresh: 1,\n        maxSimulationTime: 3000,\n        nodeSpacing: 100,\n        edgeLength: 200,\n        randomize: true,\n        infinite: true\n      };\n    }\n  };\n\n  // Ensure layout is applied after graph data changes\n  useEffect(() => {\n    if (graphData && cyRef.current) {\n      console.log('Applying layout to graph');\n      const layout = getLayout(graphData);\n      if (layout) {\n        cyRef.current.layout(layout).run();\n      }\n    }\n  }, [graphData]);\n\n  const stylesheet = [\n    {\n      selector: 'node',\n      style: {\n        'background-color': (ele) => {\n          const nodeType = ele.data('type');\n          switch (nodeType) {\n            case 'igp_node':\n              return COLORS.node;\n            case 'bgp_node':\n              return COLORS.host;\n            case 'ls_prefix':\n              return COLORS.prefix;\n            default:\n              return COLORS.node;\n          }\n        },\n        'label': 'data(label)',\n        'width': 30,\n        'height': 30,\n        'color': COLORS.text,\n        'text-outline-width': 2,\n        'text-outline-color': '#fff',\n        'font-family': 'Consolas',\n        'font-size': '10px',\n        'text-wrap': 'wrap',\n        'text-max-width': '100px'\n      }\n    },\n    {\n      selector: 'edge',\n      style: {\n        'width': 1.5,\n        'line-color': COLORS.edge,\n        'curve-style': 'bezier',\n        'target-arrow-color': COLORS.edge,\n        'target-arrow-shape': 'triangle',\n        'arrow-scale': 0.8\n      }\n    }\n  ];\n\n  if (isLoading) {\n    return <div style={{ padding: '20px', fontFamily: 'Consolas' }}>Loading graph data...</div>;\n  }\n\n  if (error) {\n    return <div style={{ padding: '20px', color: 'red', fontFamily: 'Consolas' }}>{error}</div>;\n  }\n\n  if (!graphData) {\n    return <div style={{ padding: '20px', fontFamily: 'Consolas' }}>Select a graph to visualize</div>;\n  }\n\n  return (\n    <div className=\"network-graph-container\">\n      <Legend />\n      <div className=\"graph-area\">\n        <CytoscapeComponent\n          elements={graphData}\n          layout={getLayout(graphData)}\n          stylesheet={stylesheet}\n          cy={(cy) => { cyRef.current = cy; }}\n          style={{ width: '100%', height: '100%' }}\n        />\n      </div>\n    </div>\n  );\n};\n\nexport default NetworkGraph; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}